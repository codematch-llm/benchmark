clone_code_id,base_code_id,task,domain,subdomain,clone_language,clone_type,clone_sub_type,code
z4tt_1_1,z4tt,100 doors,Game Development,Puzzles,python,T1,Identical Clone,"doors = [False] * 100
for i in range(100):
   for j in range(i, 100, i+1):
       doors[j] = not doors[j]
   print(% (i+1), 'open' if doors[i] else 'close')"
z4tt_1_2,z4tt,100 doors,Game Development,Puzzles,python,T1,Different Whitespaces,"doors=[False]*100
for i in range(100):
 for j in range(i,100,i+1):
  doors[j]=not doors[j]
 print(""%d %s"" % (i+1,'open' if doors[i] else 'close'))"
z4tt_1_3,z4tt,100 doors,Game Development,Puzzles,python,T1,Different Comments,"doors = [False] * 100
for i in range(100):
   for j in range(i, 100, i + 1):
       doors[j] = not doors[j]
   print(""%d is %s"" % (i + 1, 'open' if doors[i] else 'closed'))"
z4tt_1_4,z4tt,100 doors,Game Development,Puzzles,python,T1,Different Formatting,"doors = [False] * 100
for i in range(100):
    for j in range(i, 100, i + 1):
        doors[j] = not doors[j]
    print((i + 1), 'open' if doors[i] else 'close')"
z4tt_2_1,z4tt,100 doors,Game Development,Puzzles,python,T2,Different Variable Names,"entrances = [False] * 100
for index in range(100):
   for step in range(index, 100, index + 1):
       entrances[step] = not entrances[step]
   print(% (index + 1), 'open' if entrances[index] else 'close')"
z4tt_2_2,z4tt,100 doors,Game Development,Puzzles,python,T2,Different Data Types,"doors = [0] * 100
for i in range(100):
    for j in range(i, 100, i + 1):
        doors[j] = 1 - doors[j]
    print(str(i + 1) + ' open' if doors[i] else ' close')"
z4tt_2_3,z4tt,100 doors,Game Development,Puzzles,python,T2,Different Function Names,"doors = [False] * 100
for index in range(100):
   for multiple in range(index, 100, index+1):
       doors[multiple] = not doors[multiple]
   print(% (index+1), 'open' if doors[index] else 'close')"
z4tt_3_1,z4tt,100 doors,Game Development,Puzzles,python,T3,Added Statements,"doors = [False] * 100
for i in range(100):
   step = i + 1
   for j in range(i, 100, step):
       doors[j] = not doors[j]
   status = 'open' if doors[i] else 'close'
   print(f""{i + 1} is {status}"")"
z4tt_3_2,z4tt,100 doors,Game Development,Puzzles,python,T3,Removed Statements,"doors = [False] * 100
for i in range(100):
   for j in range(i, 100, i+1):
       doors[j] = not doors[j]
   print(i + 1, 'open' if doors[i] else 'close')"
z4tt_3_3,z4tt,100 doors,Game Development,Puzzles,python,T3,Reordered Statements,"doors = [False] * 100
for i in range(100):
   print('%d' % (i+1), 'open' if doors[i] else 'close')
   for j in range(i, 100, i + 1):
       doors[j] = not doors[j]"
z4tt_3_4,z4tt,100 doors,Game Development,Puzzles,python,T3,Control Flow Modifications,"doors = [False] * 100
for i in range(1, 101):
    for j in range(i-1, 100, i):
        doors[j] = not doors[j]
    status = 'open' if doors[i-1] else 'close'
    print(i, status)"
z4tt_4_1,z4tt,100 doors,Game Development,Puzzles,python,T4,Same Language,"doors = [False] * 100
for i in range(100):
    for j in range(i, 100, i + 1):
        doors[j] ^= True
    status = 'open' if doors[i] else 'close'
    print(f""{i + 1} {status}"")"
z4tt_4_2,z4tt,100 doors,Game Development,Puzzles,go,T4,Different Language,"package main

import ""fmt""

func main() {
    doors := [100]bool{}"
z4tt_4_2,z4tt,100 doors,Game Development,Puzzles,java,T4,Different Language,"class HundredDoors {
    public static void main(String[] args) {
        boolean[] doors = new boolean[101];

        for (int i = 1; i < doors.length; i++) {
            for (int j = i; j < doors.length; j += i) {
                doors[j] = !doors[j];
            }
        }

        for (int i = 1; i < doors.length; i++) {
            if (doors[i]) {
                System.out.printf(""Door%d is open.%n"", i);
            }
        }
    }
}"
z4tt_4_2,z4tt,100 doors,Game Development,Puzzles,javascript,T4,Different Language,"var doors=[];
for (var i=0;i<100;i++)
    doors[i]=false;
for (var i=1;i<=100;i++)
    for (var i2=i-1,g;i2<100;i2+=i)
        doors[i2]=!doors[i2];
for (var i=1;i<=100;i++)
    console.log(""Door%d is%s"",i,doors[i-1]?""open"":""closed"")"
z4tt_4_2,z4tt,100 doors,Game Development,Puzzles,php,T4,Different Language,"<?php
for ($i = 1; $i <= 100; $i++) {
	$root = sqrt($i);
	$state = ($root == ceil($root))? 'open' : 'closed';
	echo ;
}
?>"
z4tt_4_2,z4tt,100 doors,Game Development,Puzzles,ruby,T4,Different Language,"doors = Array.new(101,0)
print 
(1..100).step(){ |i|
(i..100).step(i) { |d|
    doors[d] = doors[d]^= 1
    if i == d and doors[d] == 1 then
      print 
    end
  }
}"
vu129_1_1,vu129,100 prisoners,Game Development,Puzzles,python,T1,Identical Clone,"import random

def play_random(n):
    
    pardoned = 0
    in_drawer = list(range(100))
    sampler = list(range(100))
    for _round in range(n):
        random.shuffle(in_drawer)
        found = False
        for prisoner in range(100):
            found = False
            for reveal in random.sample(sampler, 50):
                card = in_drawer[reveal]
                if card == prisoner:
                    found = True
                    break
            if not found:
                break
        if found:
            pardoned += 1
    return pardoned / n * 100   

def play_optimal(n):
    
    pardoned = 0
    in_drawer = list(range(100))
    for _round in range(n):
        random.shuffle(in_drawer)
        for prisoner in range(100):
            reveal = prisoner
            found = False
            for go in range(50):
                card = in_drawer[reveal]
                if card == prisoner:
                    found = True
                    break
                reveal = card
            if not found:
                break
        if found:
            pardoned += 1
    return pardoned / n * 100   

if __name__ == '__main__':
    n = 100_000
    print(, n)
    print(f)
    print(f)"
vu129_1_2,vu129,100 prisoners,Game Development,Puzzles,python,T1,Different Whitespaces,"import random
def play_random(n):
 pardoned = 0
 in_drawer = list(range(100))
 sampler = list(range(100))
 for _round in range(n):
  random.shuffle(in_drawer)
  found = False
  for prisoner in range(100):
   found = False
   for reveal in random.sample(sampler, 50):
    card = in_drawer[reveal]
    if card == prisoner:
     found = True
     break
   if not found:
    break
  if found:
   pardoned += 1
 return pardoned / n * 100   
def play_optimal(n):
 pardoned = 0
 in_drawer = list(range(100))
 for _round in range(n):
  random.shuffle(in_drawer)
  for prisoner in range(100):
   reveal = prisoner
   found = False
   for go in range(50):
    card = in_drawer[reveal]
    if card == prisoner:
     found = True
     break
    reveal = card
   if not found:
    break
  if found:
   pardoned += 1
 return pardoned / n * 100   
if __name__ == '__main__':
 n = 100_000
 print(n)
 print(play_random(n))
 print(play_optimal(n))"
vu129_1_3,vu129,100 prisoners,Game Development,Puzzles,python,T1,Different Comments,"import random

def play_random(n):
    
    pardoned_count = 0
    drawer_contents = list(range(100))
    sample_set = list(range(100))
    for attempt in range(n):
        random.shuffle(drawer_contents)
        success = False
        for inmate in range(100):
            success = False
            for chosen in random.sample(sample_set, 50):
                box = drawer_contents[chosen]
                if box == inmate:
                    success = True
                    break
            if not success:
                break
        if success:
            pardoned_count += 1
    return pardoned_count / n * 100   

def play_optimal(n):
    
    pardoned_count = 0
    drawer_contents = list(range(100))
    for attempt in range(n):
        random.shuffle(drawer_contents)
        for inmate in range(100):
            current_box = inmate
            success = False
            for tries in range(50):
                box = drawer_contents[current_box]
                if box == inmate:
                    success = True
                    break
                current_box = box
            if not success:
                break
        if success:
            pardoned_count += 1
    return pardoned_count / n * 100   

if __name__ == '__main__':
    n = 100_000
    print(play_random(n))
    print(play_optimal(n))"
vu129_1_4,vu129,100 prisoners,Game Development,Puzzles,python,T1,Different Formatting,"import random

def play_random(n):
    pardoned = 0
    in_drawer = list(range(100))
    sampler = list(range(100))
    for _round in range(n):
        random.shuffle(in_drawer)
        found = False
        for prisoner in range(100):
            found = False
            for reveal in random.sample(sampler, 50):
                card = in_drawer[reveal]
                if card == prisoner:
                    found = True
                    break
            if not found:
                break
        if found:
            pardoned += 1
    return pardoned / n * 100

def play_optimal(n):
    pardoned = 0
    in_drawer = list(range(100))
    for _round in range(n):
        random.shuffle(in_drawer)
        for prisoner in range(100):
            reveal = prisoner
            found = False
            for go in range(50):
                card = in_drawer[reveal]
                if card == prisoner:
                    found = True
                    break
                reveal = card
            if not found:
                break
        if found:
            pardoned += 1
    return pardoned / n * 100

if __name__ == '__main__':
    n = 100_000
    print(n)
    print(play_random(n))
    print(play_optimal(n))"
vu129_2_1,vu129,100 prisoners,Game Development,Puzzles,python,T2,Different Variable Names,"import random

def execute_random(times):
    
    released = 0
    container = list(range(100))
    sampler = list(range(100))
    for iteration in range(times):
        random.shuffle(container)
        located = False
        for inmate in range(100):
            located = False
            for display in random.sample(sampler, 50):
                ticket = container[display]
                if ticket == inmate:
                    located = True
                    break
            if not located:
                break
        if located:
            released += 1
    return released / times * 100   

def execute_optimal(times):
    
    released = 0
    container = list(range(100))
    for iteration in range(times):
        random.shuffle(container)
        for inmate in range(100):
            display = inmate
            located = False
            for attempt in range(50):
                ticket = container[display]
                if ticket == inmate:
                    located = True
                    break
                display = ticket
            if not located:
                break
        if located:
            released += 1
    return released / times * 100   

if __name__ == '__main__':
    times = 100_000
    print(execute_random(times))
    print(execute_optimal(times))"
vu129_2_2,vu129,100 prisoners,Game Development,Puzzles,python,T2,Different Data Types,"import random

def play_random(n: int) -> float:
    
    pardoned: int = 0
    in_drawer: list[int] = list(range(100))
    sampler: list[int] = list(range(100))
    for _round in range(n):
        random.shuffle(in_drawer)
        found: bool = False
        for prisoner in range(100):
            found = False
            for reveal in random.sample(sampler, 50):
                card: int = in_drawer[reveal]
                if card == prisoner:
                    found = True
                    break
            if not found:
                break
        if found:
            pardoned += 1
    return pardoned / n * 100   

def play_optimal(n: int) -> float:
    
    pardoned: int = 0
    in_drawer: list[int] = list(range(100))
    for _round in range(n):
        random.shuffle(in_drawer)
        for prisoner in range(100):
            reveal: int = prisoner
            found: bool = False
            for go in range(50):
                card: int = in_drawer[reveal]
                if card == prisoner:
                    found = True
                    break
                reveal = card
            if not found:
                break
        if found:
            pardoned += 1
    return pardoned / n * 100   

if __name__ == '__main__':
    n: int = 100_000
    print(n)
    print(play_random(n))
    print(play_optimal(n))"
vu129_2_3,vu129,100 prisoners,Game Development,Puzzles,python,T2,Different Function Names,"import random

def execute_random(n):
    
    pardoned = 0
    in_drawer = list(range(100))
    sampler = list(range(100))
    for _round in range(n):
        random.shuffle(in_drawer)
        found = False
        for prisoner in range(100):
            found = False
            for reveal in random.sample(sampler, 50):
                card = in_drawer[reveal]
                if card == prisoner:
                    found = True
                    break
            if not found:
                break
        if found:
            pardoned += 1
    return pardoned / n * 100   

def execute_optimal(n):
    
    pardoned = 0
    in_drawer = list(range(100))
    for _round in range(n):
        random.shuffle(in_drawer)
        for prisoner in range(100):
            reveal = prisoner
            found = False
            for go in range(50):
                card = in_drawer[reveal]
                if card == prisoner:
                    found = True
                    break
                reveal = card
            if not found:
                break
        if found:
            pardoned += 1
    return pardoned / n * 100   

if __name__ == '__main__':
    n = 100_000
    print(execute_random(n))
    print(execute_optimal(n))"
vu129_3_1,vu129,100 prisoners,Game Development,Puzzles,python,T3,Added Statements,"import random

def play_random(n):
    pardoned = 0
    in_drawer = list(range(100))
    sampler = list(range(100))
    for _round in range(n):
        random.shuffle(in_drawer)
        found = False
        for prisoner in range(100):
            found = False
            for reveal in random.sample(sampler, 50):
                card = in_drawer[reveal]
                if card == prisoner:
                    found = True
                    break
            if not found:
                break
        if found:
            pardoned += 1
    return pardoned / n * 100   

def play_optimal(n):
    pardoned = 0
    in_drawer = list(range(100))
    for _round in range(n):
        random.shuffle(in_drawer)
        for prisoner in range(100):
            reveal = prisoner
            found = False
            for go in range(50):
                card = in_drawer[reveal]
                if card == prisoner:
                    found = True
                    break
                reveal = card
            if not found:
                break
        if found:
            pardoned += 1
    return pardoned / n * 100   

if __name__ == '__main__':
    n = 100_000
    random_results = play_random(n)
    optimal_results = play_optimal(n)
    print(random_results, n)
    print(optimal_results)
    print(random_results)"
vu129_3_2,vu129,100 prisoners,Game Development,Puzzles,python,T3,Removed Statements,"import random

def play_random(n):
    pardoned = 0
    for _round in range(n):
        in_drawer = list(range(100))
        random.shuffle(in_drawer)
        for prisoner in range(100):
            if any(in_drawer[reveal] == prisoner for reveal in random.sample(range(100), 50)):
                pardoned += 1
                break
    return pardoned / n * 100   

def play_optimal(n):
    pardoned = 0
    for _round in range(n):
        in_drawer = list(range(100))
        random.shuffle(in_drawer)
        for prisoner in range(100):
            reveal = prisoner
            if any(in_drawer[reveal := in_drawer[reveal]] == prisoner for _ in range(50)):
                pardoned += 1
                break
    return pardoned / n * 100   

if __name__ == '__main__':
    n = 100_000
    print(play_random(n))
    print(play_optimal(n))"
vu129_3_3,vu129,100 prisoners,Game Development,Puzzles,python,T3,Reordered Statements,"import random

def play_random(n):
    pardoned = 0
    in_drawer = list(range(100))
    sampler = list(range(100))
    for _round in range(n):
        random.shuffle(in_drawer)
        found = False
        for prisoner in range(100):
            found = False
            for reveal in random.sample(sampler, 50):
                card = in_drawer[reveal]
                if card == prisoner:
                    found = True
                    break
            if not found:
                break
        if found:
            pardoned += 1
    return pardoned / n * 100   

def play_optimal(n):
    pardoned = 0
    in_drawer = list(range(100))
    for _round in range(n):
        random.shuffle(in_drawer)
        for prisoner in range(100):
            found = False
            reveal = prisoner
            for go in range(50):
                card = in_drawer[reveal]
                if card == prisoner:
                    found = True
                    break
                reveal = card
            if not found:
                break
        if found:
            pardoned += 1
    return pardoned / n * 100   

if __name__ == '__main__':
    n = 100_000
    print(play_random(n))
    print(play_optimal(n))"
vu129_3_4,vu129,100 prisoners,Game Development,Puzzles,python,T3,Control Flow Modifications,"import random

def play_random(n):
    
    pardoned = 0
    in_drawer = list(range(100))
    sampler = list(range(100))
    for _round in range(n):
        random.shuffle(in_drawer)
        for prisoner in range(100):
            for reveal in random.sample(sampler, 50):
                if in_drawer[reveal] == prisoner:
                    break
            else:
                break
        else:
            pardoned += 1
    return pardoned / n * 100   

def play_optimal(n):
    
    pardoned = 0
    in_drawer = list(range(100))
    for _round in range(n):
        random.shuffle(in_drawer)
        for prisoner in range(100):
            reveal = prisoner
            for go in range(50):
                if in_drawer[reveal] == prisoner:
                    pardoned += 1
                    break
                reveal = in_drawer[reveal]
            else:
                break
    return pardoned / n * 100   

if __name__ == '__main__':
    n = 100_000
    print(play_random(n))
    print(play_optimal(n))"
vu129_4_1,vu129,100 prisoners,Game Development,Puzzles,python,T4,Same Language,"import random

def play_random(n):
    pardoned = 0
    for _ in range(n):
        in_drawer = random.sample(range(100), 100)
        if all(any(in_drawer[reveal] == prisoner for reveal in random.sample(range(100), 50)) for prisoner in range(100)):
            pardoned += 1
    return (pardoned / n) * 100   

def play_optimal(n):
    pardoned = 0
    for _ in range(n):
        in_drawer = random.sample(range(100), 100)
        if all(any(in_drawer[reveal] == prisoner for reveal in traverse(in_drawer, prisoner)) for prisoner in range(100)):
            pardoned += 1
    return (pardoned / n) * 100

def traverse(in_drawer, start):
    for _ in range(50):
        yield start
        start = in_drawer[start]

if __name__ == '__main__':
    n = 100_000
    print(play_random(n))
    print(play_optimal(n))"
vu129_4_2,vu129,100 prisoners,Game Development,Puzzles,go,T4,Different Language,"package main

import (
    ""fmt""
    ""math/rand""
    ""time""
)"
vu129_4_2,vu129,100 prisoners,Game Development,Puzzles,java,T4,Different Language,"import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class Main {
    private static boolean playOptimal(int n) {
        List<Integer> secretList = IntStream.range(0, n).boxed().collect(Collectors.toList());
        Collections.shuffle(secretList);

        prisoner:
        for (int i = 0; i < secretList.size(); ++i) {
            int prev = i;
            for (int j = 0; j < secretList.size() / 2; ++j) {
                if (secretList.get(prev) == i) {
                    continue prisoner;
                }
                prev = secretList.get(prev);
            }
            return false;
        }
        return true;
    }

    private static boolean playRandom(int n) {
        List<Integer> secretList = IntStream.range(0, n).boxed().collect(Collectors.toList());
        Collections.shuffle(secretList);

        prisoner:
        for (Integer i : secretList) {
            List<Integer> trialList = IntStream.range(0, n).boxed().collect(Collectors.toList());
            Collections.shuffle(trialList);

            for (int j = 0; j < trialList.size() / 2; ++j) {
                if (Objects.equals(trialList.get(j), i)) {
                    continue prisoner;
                }
            }

            return false;
        }
        return true;
    }

    private static double exec(int n, int p, Function<Integer, Boolean> play) {
        int succ = 0;
        for (int i = 0; i < n; ++i) {
            if (play.apply(p)) {
                succ++;
            }
        }
        return (succ * 100.0) / n;
    }

    public static void main(String[] args) {
        final int n = 100_000;
        final int p = 100;
        System.out.printf(""# of executions:%d\n"", n);
        System.out.printf(""Optimal play success rate:%f%%\n"", exec(n, p, Main::playOptimal));
        System.out.printf(""Random play success rate:%f%%\n"", exec(n, p, Main::playRandom));
    }
}"
vu129_4_2,vu129,100 prisoners,Game Development,Puzzles,javascript,T4,Different Language,"const _ = require('lodash');

const numPlays = 100000;

const setupSecrets = () => {"
vu129_4_2,vu129,100 prisoners,Game Development,Puzzles,ruby,T4,Different Language,"prisoners = [*1..100]
N = 10_000
generate_rooms = ->{ [nil]+[*1..100].shuffle }

res = N.times.count do
  rooms = generate_rooms[]
  prisoners.all? {|pr| rooms[1,100].sample(50).include?(pr)}
end
puts  % (res.fdiv(N) * 100)

res = N.times.count do
  rooms = generate_rooms[]
  prisoners.all? do |pr|
    cur_room = pr
    50.times.any? do
      found = (rooms[cur_room] == pr)
      cur_room = rooms[cur_room]
      found
    end
  end
end
puts  % (res.fdiv(N) * 100)"
clr9q_1_1,clr9q,15 puzzle game,Game Development,Puzzles,python,T1,Identical Clone,"''' Structural Game for 15 - Puzzle with different difficulty levels'''
from random import randint


class Puzzle:
    def __init__(self):
        self.items = {}
        self.position = None

    def main_frame(self):
        d = self.items
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|'% (d[1], d[2], d[3], d[4]))
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|'% (d[5], d[6], d[7], d[8]))
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|'% (d[9], d[10], d[11], d[12]))
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|'% (d[13], d[14], d[15], d[16]))
        print('+-----+-----+-----+-----+')

    def format(self, ch):
        ch = ch.strip()
        if len(ch) == 1:
            return '  ' + ch + '  '
        elif len(ch) == 2:
            return '  ' + ch + ' '
        elif len(ch) == 0:
            return '     '

    def change(self, to):
        fro = self.position
        for a, b in self.items.items():
            if b == self.format(str(to)):
                to = a
                break
        self.items[fro], self.items[to] = self.items[to], self.items[fro]
        self.position = to

    def build_board(self, difficulty):
        for i in range(1, 17):
            self.items[i] = self.format(str(i))
        tmp = 0
        for a, b in self.items.items():
            if b == '  16 ':
                self.items[a] = '     '
                tmp = a
                break
        self.position = tmp
        if difficulty == 0:
            diff = 10
        elif difficulty == 1:
            diff = 50
        else:
            diff = 100
        for _ in range(diff):
            lst = self.valid_moves()
            lst1 = []
            for j in lst:
                lst1.append(int(j.strip()))
            self.change(lst1[randint(0, len(lst1)-1)])

    def valid_moves(self):
        pos = self.position
        if pos in [6, 7, 10, 11]:
            return self.items[pos - 4], self.items[pos - 1],\
                   self.items[pos + 1], self.items[pos + 4]
        elif pos in [5, 9]:
            return self.items[pos - 4], self.items[pos + 4],\
                   self.items[pos + 1]
        elif pos in [8, 12]:
            return self.items[pos - 4], self.items[pos + 4],\
                   self.items[pos - 1]
        elif pos in [2, 3]:
            return self.items[pos - 1], self.items[pos + 1], self.items[pos + 4]
        elif pos in [14, 15]:
            return self.items[pos - 1], self.items[pos + 1],\
                  self.items[pos - 4]
        elif pos == 1:
            return self.items[pos + 1], self.items[pos + 4]
        elif pos == 4:
            return self.items[pos - 1], self.items[pos + 4]
        elif pos == 13:
            return self.items[pos + 1], self.items[pos - 4]
        elif pos == 16:
            return self.items[pos - 1], self.items[pos - 4]

    def game_over(self):
        flag = False
        for a, b in self.items.items():
            if b == '     ':
                pass
            else:
                if a == int(b.strip()):
                    flag = True
                else:
                    flag = False
        return flag


g = Puzzle()
g.build_board(int(input('Enter the difficulty: 0 1 2\n2 '
                        '=> highest 0=> lowest\n')))
g.main_frame()
print('Enter 0 to exit')
while True:
    print('Hello user:\nTo change the position just enter the no. near it')
    lst = g.valid_moves()
    lst1 = []
    for i in lst:
        lst1.append(int(i.strip()))
        print(i.strip(), '\t', end='')
    print()
    x = int(input())
    if x == 0:
        break
    elif x not in lst1:
        print('Wrong move')
    else:
        g.change(x)
    g.main_frame()
    if g.game_over():
        print('You WON')
        break"
clr9q_1_2,clr9q,15 puzzle game,Game Development,Puzzles,python,T1,Different Whitespaces,"'''Structural Game for 15 - Puzzle with different difficulty levels'''
from random import randint
class Puzzle:
 def __init__(self):
  self.items = {}
  self.position = None
 def main_frame(self):
  d = self.items
  print('+-----+-----+-----+-----+')
  print('|%s|%s|%s|%s|' % (d[1], d[2], d[3], d[4]))
  print('+-----+-----+-----+-----+')
  print('|%s|%s|%s|%s|' % (d[5], d[6], d[7], d[8]))
  print('+-----+-----+-----+-----+')
  print('|%s|%s|%s|%s|' % (d[9], d[10], d[11], d[12]))
  print('+-----+-----+-----+-----+')
  print('|%s|%s|%s|%s|' % (d[13], d[14], d[15], d[16]))
  print('+-----+-----+-----+-----+')
 def format(self, ch):
  ch = ch.strip()
  if len(ch) == 1:
   return '  ' + ch + '  '
  elif len(ch) == 2:
   return '  ' + ch + ' '
  elif len(ch) == 0:
   return '     '
 def change(self, to):
  fro = self.position
  for a, b in self.items.items():
   if b == self.format(str(to)):
    to = a
    break
  self.items[fro], self.items[to] = self.items[to], self.items[fro]
  self.position = to
 def build_board(self, difficulty):
  for i in range(1, 17):
   self.items[i] = self.format(str(i))
  tmp = 0
  for a, b in self.items.items():
   if b == '  16 ':
    self.items[a] = '     '
    tmp = a
    break
  self.position = tmp
  if difficulty == 0:
   diff = 10
  elif difficulty == 1:
   diff = 50
  else:
   diff = 100
  for _ in range(diff):
   lst = self.valid_moves()
   lst1 = []
   for j in lst:
    lst1.append(int(j.strip()))
   self.change(lst1[randint(0, len(lst1) - 1)])
 def valid_moves(self):
  pos = self.position
  if pos in [6, 7, 10, 11]:
   return self.items[pos - 4], self.items[pos - 1], self.items[pos + 1], self.items[pos + 4]
  elif pos in [5, 9]:
   return self.items[pos - 4], self.items[pos + 4], self.items[pos + 1]
  elif pos in [8, 12]:
   return self.items[pos - 4], self.items[pos + 4], self.items[pos - 1]
  elif pos in [2, 3]:
   return self.items[pos - 1], self.items[pos + 1], self.items[pos + 4]
  elif pos in [14, 15]:
   return self.items[pos - 1], self.items[pos + 1], self.items[pos - 4]
  elif pos == 1:
   return self.items[pos + 1], self.items[pos + 4]
  elif pos == 4:
   return self.items[pos - 1], self.items[pos + 4]
  elif pos == 13:
   return self.items[pos + 1], self.items[pos - 4]
  elif pos == 16:
   return self.items[pos - 1], self.items[pos - 4]
 def game_over(self):
  flag = False
  for a, b in self.items.items():
   if b == '     ':
    pass
   else:
    if a == int(b.strip()):
     flag = True
    else:
     flag = False
  return flag
g = Puzzle()
g.build_board(int(input('Enter the difficulty: 0 1 2\n2 => highest 0=> lowest\n')))
g.main_frame()
print('Enter 0 to exit')
while True:
 print('Hello user:\nTo change the position just enter the no. near it')
 lst = g.valid_moves()
 lst1 = []
 for i in lst:
  lst1.append(int(i.strip()))
  print(i.strip(), '\t', end='')
 print()
 x = int(input())
 if x == 0:
  break
 elif x not in lst1:
  print('Wrong move')
 else:
  g.change(x)
 g.main_frame()
 if g.game_over():
  print('You WON')
  break"
clr9q_1_3,clr9q,15 puzzle game,Game Development,Puzzles,python,T1,Different Comments,"from random import randint

class Puzzle:
    def __init__(self):
        self.items = {}
        self.position = None

    def main_frame(self):
        d = self.items
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|' % (d[1], d[2], d[3], d[4]))
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|' % (d[5], d[6], d[7], d[8]))
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|' % (d[9], d[10], d[11], d[12]))
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|' % (d[13], d[14], d[15], d[16]))
        print('+-----+-----+-----+-----+')

    def format(self, ch):
        ch = ch.strip()
        if len(ch) == 1:
            return '  ' + ch + '  '
        elif len(ch) == 2:
            return '  ' + ch + ' '
        elif len(ch) == 0:
            return '     '

    def change(self, to):
        fro = self.position
        for a, b in self.items.items():
            if b == self.format(str(to)):
                to = a
                break
        self.items[fro], self.items[to] = self.items[to], self.items[fro]
        self.position = to

    def build_board(self, difficulty):
        for i in range(1, 17):
            self.items[i] = self.format(str(i))
        tmp = 0
        for a, b in self.items.items():
            if b == '  16 ':
                self.items[a] = '     '
                tmp = a
                break
        self.position = tmp
        if difficulty == 0:
            diff = 10
        elif difficulty == 1:
            diff = 50
        else:
            diff = 100
        for _ in range(diff):
            lst = self.valid_moves()
            lst1 = []
            for j in lst:
                lst1.append(int(j.strip()))
            self.change(lst1[randint(0, len(lst1)-1)])

    def valid_moves(self):
        pos = self.position
        if pos in [6, 7, 10, 11]:
            return self.items[pos - 4], self.items[pos - 1],\
                   self.items[pos + 1], self.items[pos + 4]
        elif pos in [5, 9]:
            return self.items[pos - 4], self.items[pos + 4],\
                   self.items[pos + 1]
        elif pos in [8, 12]:
            return self.items[pos - 4], self.items[pos + 4],\
                   self.items[pos - 1]
        elif pos in [2, 3]:
            return self.items[pos - 1], self.items[pos + 1], self.items[pos + 4]
        elif pos in [14, 15]:
            return self.items[pos - 1], self.items[pos + 1],\
                  self.items[pos - 4]
        elif pos == 1:
            return self.items[pos + 1], self.items[pos + 4]
        elif pos == 4:
            return self.items[pos - 1], self.items[pos + 4]
        elif pos == 13:
            return self.items[pos + 1], self.items[pos - 4]
        elif pos == 16:
            return self.items[pos - 1], self.items[pos - 4]

    def game_over(self):
        flag = False
        for a, b in self.items.items():
            if b == '     ':
                pass
            else:
                if a == int(b.strip()):
                    flag = True
                else:
                    flag = False
        return flag


g = Puzzle()
g.build_board(int(input('Select difficulty level: 0 1 2\n2 => hardest 0=> easiest\n')))
g.main_frame()
print('Enter 0 to exit')
while True:
    print('User prompt:\nTo move, enter the number adjacent to the blank space')
    lst = g.valid_moves()
    lst1 = []
    for i in lst:
        lst1.append(int(i.strip()))
        print(i.strip(), '\t', end='')
    print()
    x = int(input())
    if x == 0:
        break
    elif x not in lst1:
        print('Invalid move')
    else:
        g.change(x)
    g.main_frame()
    if g.game_over():
        print('Congratulations, you WIN')
        break"
clr9q_1_4,clr9q,15 puzzle game,Game Development,Puzzles,python,T1,Different Formatting,"```python
''' Structural Game for 15 - Puzzle with different difficulty levels'''
from random import randint

class Puzzle:
    def __init__(self):
        self.items = {}
        self.position = None

    def main_frame(self):
        d = self.items
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|' % (d[1], d[2], d[3], d[4]))
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|' % (d[5], d[6], d[7], d[8]))
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|' % (d[9], d[10], d[11], d[12]))
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|' % (d[13], d[14], d[15], d[16]))
        print('+-----+-----+-----+-----+')

    def format(self, ch):
        ch = ch.strip()
        if len(ch) == 1:
            return '  ' + ch + '  '
        elif len(ch) == 2:
            return '  ' + ch + ' '
        elif len(ch) == 0:
            return '     '

    def change(self, to):
        fro = self.position
        for a, b in self.items.items():
            if b == self.format(str(to)):
                to = a
                break
        self.items[fro], self.items[to] = self.items[to], self.items[fro]
        self.position = to

    def build_board(self, difficulty):
        for i in range(1, 17):
            self.items[i] = self.format(str(i))
        tmp = 0
        for a, b in self.items.items():
            if b == '  16 ':
                self.items[a] = '     '
                tmp = a
                break
        self.position = tmp
        if difficulty == 0:
            diff = 10
        elif difficulty == 1:
            diff = 50
        else:
            diff = 100
        for _ in range(diff):
            lst = self.valid_moves()
            lst1 = []
            for j in lst:
                lst1.append(int(j.strip()))
            self.change(lst1[randint(0, len(lst1) - 1)])

    def valid_moves(self):
        pos = self.position
        if pos in [6, 7, 10, 11]:
            return self.items[pos - 4], self.items[pos - 1], \
                   self.items[pos + 1], self.items[pos + 4]
        elif pos in [5, 9]:
            return self.items[pos - 4], self.items[pos + 4], \
                   self.items[pos + 1]
        elif pos in [8, 12]:
            return self.items[pos - 4], self.items[pos + 4], \
                   self.items[pos - 1]
        elif pos in [2, 3]:
            return self.items[pos - 1], self.items[pos + 1], self.items[pos + 4]
        elif pos in [14, 15]:
            return self.items[pos - 1], self.items[pos + 1], \
                   self.items[pos - 4]
        elif pos == 1:
            return self.items[pos + 1], self.items[pos + 4]
        elif pos == 4:
            return self.items[pos - 1], self.items[pos + 4]
        elif pos == 13:
            return self.items[pos + 1], self.items[pos - 4]
        elif pos == 16:
            return self.items[pos - 1], self.items[pos - 4]

    def game_over(self):
        flag = False
        for a, b in self.items.items():
            if b == '     ':
                pass
            else:
                if a == int(b.strip()):
                    flag = True
                else:
                    flag = False
        return flag

g = Puzzle()
g.build_board(int(input('Enter the difficulty: 0 1 2\n2 '
                        '=> highest 0=> lowest\n')))
g.main_frame()
print('Enter 0 to exit')
while True:
    print('Hello user:\nTo change the position just enter the no. near it')
    lst = g.valid_moves()
    lst1 = []
    for i in lst:
        lst1.append(int(i.strip()))
        print(i.strip(), '\t', end='')
    print()
    x = int(input())
    if x == 0:
        break
    elif x not in lst1:
        print('Wrong move')
    else:
        g.change(x)
    g.main_frame()
    if g.game_over():
        print('You WON')
        break
```"
clr9q_2_1,clr9q,15 puzzle game,Game Development,Puzzles,python,T2,Different Variable Names,"from random import randint


class Game:
    def __init__(self):
        self.tiles = {}
        self.empty_position = None

    def display_board(self):
        board = self.tiles
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|' % (board[1], board[2], board[3], board[4]))
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|' % (board[5], board[6], board[7], board[8]))
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|' % (board[9], board[10], board[11], board[12]))
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|' % (board[13], board[14], board[15], board[16]))
        print('+-----+-----+-----+-----+')

    def format_tile(self, value):
        value = value.strip()
        if len(value) == 1:
            return '  ' + value + '  '
        elif len(value) == 2:
            return '  ' + value + ' '
        elif len(value) == 0:
            return '     '

    def swap(self, new_position):
        current_position = self.empty_position
        for index, tile in self.tiles.items():
            if tile == self.format_tile(str(new_position)):
                new_position = index
                break
        self.tiles[current_position], self.tiles[new_position] = self.tiles[new_position], self.tiles[current_position]
        self.empty_position = new_position

    def initialize_board(self, level):
        for i in range(1, 17):
            self.tiles[i] = self.format_tile(str(i))
        tmp = 0
        for index, tile in self.tiles.items():
            if tile == '  16 ':
                self.tiles[index] = '     '
                tmp = index
                break
        self.empty_position = tmp
        if level == 0:
            moves = 10
        elif level == 1:
            moves = 50
        else:
            moves = 100
        for _ in range(moves):
            possible_moves = self.get_valid_moves()
            move_options = []
            for move in possible_moves:
                move_options.append(int(move.strip()))
            self.swap(move_options[randint(0, len(move_options)-1)])

    def get_valid_moves(self):
        empty_pos = self.empty_position
        if empty_pos in [6, 7, 10, 11]:
            return self.tiles[empty_pos - 4], self.tiles[empty_pos - 1],\
                   self.tiles[empty_pos + 1], self.tiles[empty_pos + 4]
        elif empty_pos in [5, 9]:
            return self.tiles[empty_pos - 4], self.tiles[empty_pos + 4],\
                   self.tiles[empty_pos + 1]
        elif empty_pos in [8, 12]:
            return self.tiles[empty_pos - 4], self.tiles[empty_pos + 4],\
                   self.tiles[empty_pos - 1]
        elif empty_pos in [2, 3]:
            return self.tiles[empty_pos - 1], self.tiles[empty_pos + 1], self.tiles[empty_pos + 4]
        elif empty_pos in [14, 15]:
            return self.tiles[empty_pos - 1], self.tiles[empty_pos + 1],\
                  self.tiles[empty_pos - 4]
        elif empty_pos == 1:
            return self.tiles[empty_pos + 1], self.tiles[empty_pos + 4]
        elif empty_pos == 4:
            return self.tiles[empty_pos - 1], self.tiles[empty_pos + 4]
        elif empty_pos == 13:
            return self.tiles[empty_pos + 1], self.tiles[empty_pos - 4]
        elif empty_pos == 16:
            return self.tiles[empty_pos - 1], self.tiles[empty_pos - 4]

    def is_solved(self):
        is_complete = False
        for index, tile in self.tiles.items():
            if tile == '     ':
                pass
            else:
                if index == int(tile.strip()):
                    is_complete = True
                else:
                    is_complete = False
        return is_complete


puzzle_game = Game()
puzzle_game.initialize_board(int(input('Enter the difficulty: 0 1 2\n2 '
                                        '=> highest 0=> lowest\n')))
puzzle_game.display_board()
print('Enter 0 to exit')
while True:
    print('Hello user:\nTo change the position just enter the no. near it')
    valid_move_options = puzzle_game.get_valid_moves()
    move_nums = []
    for move in valid_move_options:
        move_nums.append(int(move.strip()))
        print(move.strip(), '\t', end='')
    print()
    user_input = int(input())
    if user_input == 0:
        break
    elif user_input not in move_nums:
        print('Wrong move')
    else:
        puzzle_game.swap(user_input)
    puzzle_game.display_board()
    if puzzle_game.is_solved():
        print('You WON')
        break"
clr9q_2_2,clr9q,15 puzzle game,Game Development,Puzzles,python,T2,Different Data Types,"from random import randint

class Puzzle:
    def __init__(self):
        self.items = list()
        self.position = None

    def main_frame(self):
        d = self.items
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|'% (d[1], d[2], d[3], d[4]))
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|'% (d[5], d[6], d[7], d[8]))
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|'% (d[9], d[10], d[11], d[12]))
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|'% (d[13], d[14], d[15], d[16]))
        print('+-----+-----+-----+-----+')

    def format(self, ch):
        ch = ch.strip()
        if len(ch) == 1:
            return '  ' + ch + '  '
        elif len(ch) == 2:
            return '  ' + ch + ' '
        elif len(ch) == 0:
            return '     '

    def change(self, to):
        fro = self.position
        for a, b in enumerate(self.items):
            if b == self.format(str(to)):
                to = a
                break
        self.items[fro], self.items[to] = self.items[to], self.items[fro]
        self.position = to

    def build_board(self, difficulty):
        for i in range(1, 17):
            self.items.append(self.format(str(i)))
        tmp = 0
        for a, b in enumerate(self.items):
            if b == '  16 ':
                self.items[a] = '     '
                tmp = a
                break
        self.position = tmp
        if difficulty == 0:
            diff = 10
        elif difficulty == 1:
            diff = 50
        else:
            diff = 100
        for _ in range(diff):
            lst = self.valid_moves()
            lst1 = []
            for j in lst:
                lst1.append(int(j.strip()))
            self.change(lst1[randint(0, len(lst1)-1)])

    def valid_moves(self):
        pos = self.position
        if pos in [6, 7, 10, 11]:
            return self.items[pos - 4], self.items[pos - 1],\
                   self.items[pos + 1], self.items[pos + 4]
        elif pos in [5, 9]:
            return self.items[pos - 4], self.items[pos + 4],\
                   self.items[pos + 1]
        elif pos in [8, 12]:
            return self.items[pos - 4], self.items[pos + 4],\
                   self.items[pos - 1]
        elif pos in [2, 3]:
            return self.items[pos - 1], self.items[pos + 1], self.items[pos + 4]
        elif pos in [14, 15]:
            return self.items[pos - 1], self.items[pos + 1],\
                  self.items[pos - 4]
        elif pos == 1:
            return self.items[pos + 1], self.items[pos + 4]
        elif pos == 4:
            return self.items[pos - 1], self.items[pos + 4]
        elif pos == 13:
            return self.items[pos + 1], self.items[pos - 4]
        elif pos == 16:
            return self.items[pos - 1], self.items[pos - 4]

    def game_over(self):
        flag = True
        for a, b in enumerate(self.items):
            if b == '     ':
                pass
            else:
                if a == int(b.strip()):
                    flag = flag and True
                else:
                    flag = False
        return flag

g = Puzzle()
g.build_board(int(input('Enter the difficulty: 0 1 2\n2 '
                        '=> highest 0=> lowest\n')))
g.main_frame()
print('Enter 0 to exit')
while True:
    print('Hello user:\nTo change the position just enter the no. near it')
    lst = g.valid_moves()
    lst1 = []
    for i in lst:
        lst1.append(int(i.strip()))
        print(i.strip(), '\t', end='')
    print()
    x = int(input())
    if x == 0:
        break
    elif x not in lst1:
        print('Wrong move')
    else:
        g.change(x)
    g.main_frame()
    if g.game_over():
        print('You WON')
        break"
clr9q_2_3,clr9q,15 puzzle game,Game Development,Puzzles,python,T2,Different Function Names,"from random import randint


class Game:
    def __init__(self):
        self.items = {}
        self.position = None

    def display_frame(self):
        d = self.items
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|' % (d[1], d[2], d[3], d[4]))
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|' % (d[5], d[6], d[7], d[8]))
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|' % (d[9], d[10], d[11], d[12]))
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|' % (d[13], d[14], d[15], d[16]))
        print('+-----+-----+-----+-----+')

    def format_item(self, ch):
        ch = ch.strip()
        if len(ch) == 1:
            return '  ' + ch + '  '
        elif len(ch) == 2:
            return '  ' + ch + ' '
        elif len(ch) == 0:
            return '     '

    def swap(self, to):
        fro = self.position
        for a, b in self.items.items():
            if b == self.format_item(str(to)):
                to = a
                break
        self.items[fro], self.items[to] = self.items[to], self.items[fro]
        self.position = to

    def setup_board(self, difficulty):
        for i in range(1, 17):
            self.items[i] = self.format_item(str(i))
        tmp = 0
        for a, b in self.items.items():
            if b == '  16 ':
                self.items[a] = '     '
                tmp = a
                break
        self.position = tmp
        if difficulty == 0:
            diff = 10
        elif difficulty == 1:
            diff = 50
        else:
            diff = 100
        for _ in range(diff):
            lst = self.available_moves()
            lst1 = []
            for j in lst:
                lst1.append(int(j.strip()))
            self.swap(lst1[randint(0, len(lst1)-1)])

    def available_moves(self):
        pos = self.position
        if pos in [6, 7, 10, 11]:
            return self.items[pos - 4], self.items[pos - 1],\
                   self.items[pos + 1], self.items[pos + 4]
        elif pos in [5, 9]:
            return self.items[pos - 4], self.items[pos + 4],\
                   self.items[pos + 1]
        elif pos in [8, 12]:
            return self.items[pos - 4], self.items[pos + 4],\
                   self.items[pos - 1]
        elif pos in [2, 3]:
            return self.items[pos - 1], self.items[pos + 1], self.items[pos + 4]
        elif pos in [14, 15]:
            return self.items[pos - 1], self.items[pos + 1],\
                  self.items[pos - 4]
        elif pos == 1:
            return self.items[pos + 1], self.items[pos + 4]
        elif pos == 4:
            return self.items[pos - 1], self.items[pos + 4]
        elif pos == 13:
            return self.items[pos + 1], self.items[pos - 4]
        elif pos == 16:
            return self.items[pos - 1], self.items[pos - 4]

    def is_complete(self):
        flag = False
        for a, b in self.items.items():
            if b == '     ':
                pass
            else:
                if a == int(b.strip()):
                    flag = True
                else:
                    flag = False
        return flag


game_instance = Game()
game_instance.setup_board(int(input('Enter the difficulty: 0 1 2\n2 '
                                     '=> highest 0=> lowest\n')))
game_instance.display_frame()
print('Enter 0 to exit')
while True:
    print('Hello user:\nTo change the position just enter the no. near it')
    lst = game_instance.available_moves()
    lst1 = []
    for i in lst:
        lst1.append(int(i.strip()))
        print(i.strip(), '\t', end='')
    print()
    x = int(input())
    if x == 0:
        break
    elif x not in lst1:
        print('Wrong move')
    else:
        game_instance.swap(x)
    game_instance.display_frame()
    if game_instance.is_complete():
        print('You WON')
        break"
clr9q_3_1,clr9q,15 puzzle game,Game Development,Puzzles,python,T3,Added Statements,"from random import randint


class Puzzle:
    def __init__(self):
        self.items = {}
        self.position = None

    def main_frame(self):
        d = self.items
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|'% (d[1], d[2], d[3], d[4]))
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|'% (d[5], d[6], d[7], d[8]))
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|'% (d[9], d[10], d[11], d[12]))
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|'% (d[13], d[14], d[15], d[16]))
        print('+-----+-----+-----+-----+')

    def format(self, ch):
        ch = ch.strip()
        if len(ch) == 1:
            return '  ' + ch + '  '
        elif len(ch) == 2:
            return '  ' + ch + ' '
        elif len(ch) == 0:
            return '     '

    def change(self, to):
        fro = self.position
        for a, b in self.items.items():
            if b == self.format(str(to)):
                to = a
                break
        self.items[fro], self.items[to] = self.items[to], self.items[fro]
        self.position = to

    def build_board(self, difficulty):
        for i in range(1, 17):
            self.items[i] = self.format(str(i))
        tmp = next(a for a, b in self.items.items() if b == '  16 ')
        self.items[tmp] = '     '
        self.position = tmp
        diff = 10 if difficulty == 0 else 50 if difficulty == 1 else 100
        for _ in range(diff):
            lst = self.valid_moves()
            valid_moves_int = [int(j.strip()) for j in lst]
            self.change(valid_moves_int[randint(0, len(valid_moves_int)-1)])

    def valid_moves(self):
        pos = self.position
        if pos in [6, 7, 10, 11]:
            return self.items[pos - 4], self.items[pos - 1], self.items[pos + 1], self.items[pos + 4]
        elif pos in [5, 9]:
            return self.items[pos - 4], self.items[pos + 4], self.items[pos + 1]
        elif pos in [8, 12]:
            return self.items[pos - 4], self.items[pos + 4], self.items[pos - 1]
        elif pos in [2, 3]:
            return self.items[pos - 1], self.items[pos + 1], self.items[pos + 4]
        elif pos in [14, 15]:
            return self.items[pos - 1], self.items[pos + 1], self.items[pos - 4]
        elif pos == 1:
            return self.items[pos + 1], self.items[pos + 4]
        elif pos == 4:
            return self.items[pos - 1], self.items[pos + 4]
        elif pos == 13:
            return self.items[pos + 1], self.items[pos - 4]
        elif pos == 16:
            return self.items[pos - 1], self.items[pos - 4]

    def game_over(self):
        return all(a == int(b.strip()) if b != '     ' else True for a, b in self.items.items())

g = Puzzle()
g.build_board(int(input('Enter the difficulty: 0 1 2\n2 => highest 0=> lowest\n')))
g.main_frame()
print('Enter 0 to exit')
while True:
    print('Hello user:\nTo change the position just enter the no. near it')
    lst = g.valid_moves()
    valid_moves_int = [int(i.strip()) for i in lst]
    for i in lst:
        print(i.strip(), '\t', end='')
    print()
    x = int(input())
    if x == 0:
        break
    elif x not in valid_moves_int:
        print('Wrong move')
    else:
        g.change(x)
    g.main_frame()
    if g.game_over():
        print('You WON')
        break"
clr9q_3_2,clr9q,15 puzzle game,Game Development,Puzzles,python,T3,Removed Statements,"from random import randint

class Puzzle:
    def __init__(self):
        self.items = {}
        self.position = None

    def main_frame(self):
        d = self.items
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|'% (d[1], d[2], d[3], d[4]))
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|'% (d[5], d[6], d[7], d[8]))
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|'% (d[9], d[10], d[11], d[12]))
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|'% (d[13], d[14], d[15], d[16]))
        print('+-----+-----+-----+-----+')

    def format(self, ch):
        ch = ch.strip()
        return '  ' + ch + '  ' if len(ch) == 1 else '  ' + ch + ' ' if len(ch) == 2 else '     '

    def change(self, to):
        fro = self.position
        to = next(a for a, b in self.items.items() if b == self.format(str(to)))
        self.items[fro], self.items[to] = self.items[to], self.items[fro]
        self.position = to

    def build_board(self, difficulty):
        for i in range(1, 17):
            self.items[i] = self.format(str(i))
        tmp = next(a for a, b in self.items.items() if b == '  16 ')
        self.items[tmp] = '     '
        self.position = tmp
        diff = 10 if difficulty == 0 else 50 if difficulty == 1 else 100
        for _ in range(diff):
            lst = self.valid_moves()
            self.change(int(lst[randint(0, len(lst)-1)].strip()))

    def valid_moves(self):
        pos = self.position
        if pos in [6, 7, 10, 11]:
            return self.items[pos - 4], self.items[pos - 1], self.items[pos + 1], self.items[pos + 4]
        elif pos in [5, 9]:
            return self.items[pos - 4], self.items[pos + 4], self.items[pos + 1]
        elif pos in [8, 12]:
            return self.items[pos - 4], self.items[pos + 4], self.items[pos - 1]
        elif pos in [2, 3]:
            return self.items[pos - 1], self.items[pos + 1], self.items[pos + 4]
        elif pos in [14, 15]:
            return self.items[pos - 1], self.items[pos + 1], self.items[pos - 4]
        elif pos == 1:
            return self.items[pos + 1], self.items[pos + 4]
        elif pos == 4:
            return self.items[pos - 1], self.items[pos + 4]
        elif pos == 13:
            return self.items[pos + 1], self.items[pos - 4]
        elif pos == 16:
            return self.items[pos - 1], self.items[pos - 4]

    def game_over(self):
        return all(b == '     ' or a == int(b.strip()) for a, b in self.items.items())

g = Puzzle()
g.build_board(int(input('Enter the difficulty: 0 1 2\n2 => highest 0=> lowest\n')))
g.main_frame()
print('Enter 0 to exit')
while True:
    lst = g.valid_moves()
    for i in lst:
        print(i.strip(), '\t', end='')
    print()
    x = int(input())
    if x == 0:
        break
    if x not in map(int, map(str.strip, lst)):
        print('Wrong move')
    else:
        g.change(x)
    g.main_frame()
    if g.game_over():
        print('You WON')
        break"
clr9q_3_3,clr9q,15 puzzle game,Game Development,Puzzles,python,T3,Reordered Statements,"from random import randint

class Puzzle:
    def __init__(self):
        self.items = {}
        self.position = None

    def build_board(self, difficulty):
        for i in range(1, 17):
            self.items[i] = self.format(str(i))
        tmp = 0
        for a, b in self.items.items():
            if b == '  16 ':
                self.items[a] = '     '
                tmp = a
                break
        self.position = tmp
        if difficulty == 0:
            diff = 10
        elif difficulty == 1:
            diff = 50
        else:
            diff = 100
        for _ in range(diff):
            lst = self.valid_moves()
            lst1 = []
            for j in lst:
                lst1.append(int(j.strip()))
            self.change(lst1[randint(0, len(lst1)-1)])

    def main_frame(self):
        d = self.items
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|'% (d[1], d[2], d[3], d[4]))
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|'% (d[5], d[6], d[7], d[8]))
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|'% (d[9], d[10], d[11], d[12]))
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|'% (d[13], d[14], d[15], d[16]))
        print('+-----+-----+-----+-----+')

    def valid_moves(self):
        pos = self.position
        if pos in [6, 7, 10, 11]:
            return self.items[pos - 4], self.items[pos - 1],\
                   self.items[pos + 1], self.items[pos + 4]
        elif pos in [5, 9]:
            return self.items[pos - 4], self.items[pos + 4],\
                   self.items[pos + 1]
        elif pos in [8, 12]:
            return self.items[pos - 4], self.items[pos + 4],\
                   self.items[pos - 1]
        elif pos in [2, 3]:
            return self.items[pos - 1], self.items[pos + 1], self.items[pos + 4]
        elif pos in [14, 15]:
            return self.items[pos - 1], self.items[pos + 1],\
                  self.items[pos - 4]
        elif pos == 1:
            return self.items[pos + 1], self.items[pos + 4]
        elif pos == 4:
            return self.items[pos - 1], self.items[pos + 4]
        elif pos == 13:
            return self.items[pos + 1], self.items[pos - 4]
        elif pos == 16:
            return self.items[pos - 1], self.items[pos - 4]

    def change(self, to):
        fro = self.position
        for a, b in self.items.items():
            if b == self.format(str(to)):
                to = a
                break
        self.items[fro], self.items[to] = self.items[to], self.items[fro]
        self.position = to

    def format(self, ch):
        ch = ch.strip()
        if len(ch) == 1:
            return '  ' + ch + '  '
        elif len(ch) == 2:
            return '  ' + ch + ' '
        elif len(ch) == 0:
            return '     '

    def game_over(self):
        flag = False
        for a, b in self.items.items():
            if b == '     ':
                pass
            else:
                if a == int(b.strip()):
                    flag = True
                else:
                    flag = False
        return flag


g = Puzzle()
g.build_board(int(input('Enter the difficulty: 0 1 2\n2 '
                        '=> highest 0=> lowest\n')))
g.main_frame()
print('Enter 0 to exit')
while True:
    print('Hello user:\nTo change the position just enter the no. near it')
    lst = g.valid_moves()
    lst1 = []
    for i in lst:
        lst1.append(int(i.strip()))
        print(i.strip(), '\t', end='')
    print()
    x = int(input())
    if x == 0:
        break
    elif x not in lst1:
        print('Wrong move')
    else:
        g.change(x)
    g.main_frame()
    if g.game_over():
        print('You WON')
        break"
clr9q_3_4,clr9q,15 puzzle game,Game Development,Puzzles,python,T3,Control Flow Modifications,"from random import randint

class Puzzle:
    def __init__(self):
        self.items = {}
        self.position = None

    def main_frame(self):
        d = self.items
        for i in range(1, 17, 4):
            print('+-----+-----+-----+-----+')
            print('|%s|%s|%s|%s|' % (d[i], d[i+1], d[i+2], d[i+3]))
        print('+-----+-----+-----+-----+')

    def format(self, ch):
        ch = ch.strip()
        if len(ch) == 0:
            return '     '
        elif len(ch) == 1:
            return '  ' + ch + '  '
        else:
            return '  ' + ch + ' '

    def change(self, to):
        fro = self.position
        to = next(a for a, b in self.items.items() if b == self.format(str(to)))
        self.items[fro], self.items[to] = self.items[to], self.items[fro]
        self.position = to

    def build_board(self, difficulty):
        for i in range(1, 17):
            self.items[i] = self.format(str(i))
        self.position = next(a for a, b in self.items.items() if b == '  16 ' and (self.items[a] := '     '))
        diff = 10 if difficulty == 0 else 50 if difficulty == 1 else 100
        for _ in range(diff):
            lst = [int(j.strip()) for j in self.valid_moves()]
            self.change(lst[randint(0, len(lst)-1)])

    def valid_moves(self):
        pos = self.position
        moves = []
        if pos in [6, 7, 10, 11]:
            moves = [self.items[pos - 4], self.items[pos - 1], self.items[pos + 1], self.items[pos + 4]]
        elif pos in [5, 9]:
            moves = [self.items[pos - 4], self.items[pos + 4], self.items[pos + 1]]
        elif pos in [8, 12]:
            moves = [self.items[pos - 4], self.items[pos + 4], self.items[pos - 1]]
        elif pos in [2, 3]:
            moves = [self.items[pos - 1], self.items[pos + 1], self.items[pos + 4]]
        elif pos in [14, 15]:
            moves = [self.items[pos - 1], self.items[pos + 1], self.items[pos - 4]]
        elif pos == 1:
            moves = [self.items[pos + 1], self.items[pos + 4]]
        elif pos == 4:
            moves = [self.items[pos - 1], self.items[pos + 4]]
        elif pos == 13:
            moves = [self.items[pos + 1], self.items[pos - 4]]
        elif pos == 16:
            moves = [self.items[pos - 1], self.items[pos - 4]]
        return moves

    def game_over(self):
        return all(a == int(b.strip()) for a, b in self.items.items() if b != '     ')

g = Puzzle()
g.build_board(int(input('Enter the difficulty: 0 1 2\n2 => highest 0=> lowest\n')))
g.main_frame()
print('Enter 0 to exit')
while True:
    print('Hello user:\nTo change the position just enter the no. near it')
    lst = g.valid_moves()
    for i in lst:
        print(i.strip(), '\t', end='')
    print()
    x = int(input())
    if x == 0:
        break
    if x not in [int(i.strip()) for i in lst]:
        print('Wrong move')
    else:
        g.change(x)
    g.main_frame()
    if g.game_over():
        print('You WON')
        break"
clr9q_4_1,clr9q,15 puzzle game,Game Development,Puzzles,python,T4,Same Language,"from random import randint


class Puzzle:
    def __init__(self):
        self.items = {i: self.format(str(i)) for i in range(1, 17)}
        self.position = self.initialize_board()

    def initialize_board(self):
        for k, v in self.items.items():
            if v == '  16 ':
                self.items[k] = '     '
                return k

    def main_frame(self):
        for row in range(1, 5):
            print('+-----+-----+-----+-----+')
            print('|{}|{}|{}|{}|'.format(self.items[4 * (row - 1) + 1],
                                       self.items[4 * (row - 1) + 2],
                                       self.items[4 * (row - 1) + 3],
                                       self.items[4 * (row - 1) + 4]))
        print('+-----+-----+-----+-----+')

    def format(self, ch):
        ch = ch.strip()
        if len(ch) == 1:
            return '  ' + ch + '  '
        elif len(ch) == 2:
            return '  ' + ch + ' '
        return '     '

    def change(self, to):
        fro = self.position
        to = next((k for k, v in self.items.items() if v == self.format(str(to))), fro)
        self.items[fro], self.items[to] = self.items[to], self.items[fro]
        self.position = to

    def build_board(self, difficulty):
        moves = 10 if difficulty == 0 else 50 if difficulty == 1 else 100
        for _ in range(moves):
            valid_moves = [int(m.strip()) for m in self.valid_moves()]
            self.change(valid_moves[randint(0, len(valid_moves) - 1)])

    def valid_moves(self):
        pos = self.position
        neighbors = {
            1: [2, 5],
            2: [1, 3, 6],
            3: [2, 4, 7],
            4: [3, 8],
            5: [1, 6, 9],
            6: [2, 5, 7, 10],
            7: [3, 6, 8, 11],
            8: [4, 7, 12],
            9: [5, 10, 13],
            10: [6, 9, 11, 14],
            11: [7, 10, 12, 15],
            12: [8, 11, 16],
            13: [9, 14],
            14: [10, 13, 15],
            15: [11, 14, 16],
            16: [12, 15],
        }
        return [self.items[i] for i in neighbors[pos]]

    def game_over(self):
        return all(a == int(b.strip()) for a, b in self.items.items() if b != '     ')


g = Puzzle()
g.build_board(int(input('Enter the difficulty: 0 1 2\n2 => highest 0=> lowest\n')))
g.main_frame()
print('Enter 0 to exit')
while True:
    print('Hello user:\nTo change the position just enter the no. near it')
    valid_moves = g.valid_moves()
    for move in valid_moves:
        print(move.strip(), '\t', end='')
    print()
    x = int(input())
    if x == 0:
        break
    elif x not in [int(m.strip()) for m in valid_moves]:
        print('Wrong move')
    else:
        g.change(x)
    g.main_frame()
    if g.game_over():
        print('You WON')
        break"
clr9q_4_2,clr9q,15 puzzle game,Game Development,Puzzles,go,T4,Different Language,"package main

import (
	""fmt""
	""math/rand""
	""strings""
	""time""
)

func main() {
	rand.Seed(time.Now().UnixNano())
	p := newPuzzle()
	p.play()
}

type board [16]cell
type cell uint8
type move uint8

const (
	up move = iota
	down
	right
	left
)

func randMove() move { return move(rand.Intn(4)) }

var solvedBoard = board{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0}

func (b *board) String() string {
	var buf strings.Builder
	for i, c := range b {
		if c == 0 {
			buf.WriteString(""  ."")
		} else {
			_, _ = fmt.Fprintf(&buf, ""%3d"", c)
		}
		if i%4 == 3 {
			buf.WriteString(""\n"")
		}
	}
	return buf.String()
}

type puzzle struct {
	board board
	empty int"
clr9q_4_2,clr9q,15 puzzle game,Game Development,Puzzles,java,T4,Different Language,"package fifteenpuzzle;

import java.awt.*;
import java.awt.event.*;
import java.util.Random;
import javax.swing.*;

class FifteenPuzzle extends JPanel {

    private final int side = 4;
    private final int numTiles = side * side - 1;

    private final Random rand = new Random();
    private final int[] tiles = new int[numTiles + 1];
    private final int tileSize;
    private int blankPos;
    private final int margin;
    private final int gridSize;
    private boolean gameOver;

    private FifteenPuzzle() {
        final int dim = 640;

        margin = 80;
        tileSize = (dim - 2 * margin) / side;
        gridSize = tileSize * side;

        setPreferredSize(new Dimension(dim, dim + margin));
        setBackground(Color.WHITE);
        setForeground(new Color(0x6495ED));"
clr9q_4_2,clr9q,15 puzzle game,Game Development,Puzzles,javascript,T4,Different Language,"var board, zx, zy, clicks, possibles, clickCounter, oldzx = -1, oldzy = -1;
function getPossibles() {
    var ii, jj, cx = [-1, 0, 1, 0], cy = [0, -1, 0, 1];
    possibles = [];
    for( var i = 0; i < 4; i++ ) {
        ii = zx + cx[i]; jj = zy + cy[i];
        if( ii < 0 || ii > 3 || jj < 0 || jj > 3 ) continue;
        possibles.push( { x: ii, y: jj } );
    }
}
function updateBtns() {
    var b, v, id;
    for( var j = 0; j < 4; j++ ) {
        for( var i = 0; i < 4; i++ ) {
            id = ""btn"" + ( i + j * 4 );
            b = document.getElementById( id );
            v = board[i][j];
            if( v < 16 ) {
                b.innerHTML = ( """" + v );
                b.className = ""button""
            }
            else {
                b.innerHTML = ( """" );
                b.className = ""empty"";
            }
        }
    }
    clickCounter.innerHTML = ""Clicks: "" + clicks;
}
function shuffle() {
    var v = 0, t; 
    do {
        getPossibles();
        while( true ) {
            t = possibles[Math.floor( Math.random() * possibles.length )];
            console.log( t.x, oldzx, t.y, oldzy )
            if( t.x != oldzx || t.y != oldzy ) break;
        }
        oldzx = zx; oldzy = zy;
        board[zx][zy] = board[t.x][t.y];
        zx = t.x; zy = t.y;
        board[zx][zy] = 16; 
    } while( ++v < 200 );
}
function restart() {
    shuffle();
    clicks = 0;
    updateBtns();
}
function checkFinished() {
    var a = 0;
    for( var j = 0; j < 4; j++ ) {
        for( var i = 0; i < 4; i++ ) {
            if( board[i][j] < a ) return false;
            a = board[i][j];
        }
    }
    return true;
}
function btnHandle( e ) {
    getPossibles();
    var c = e.target.i, r = e.target.j, p = -1;
    for( var i = 0; i < possibles.length; i++ ) {
        if( possibles[i].x == c && possibles[i].y == r ) {
            p = i;
            break;
        }
    }
    if( p > -1 ) {
        clicks++;
        var t = possibles[p];
        board[zx][zy] = board[t.x][t.y];
        zx = t.x; zy = t.y;
        board[zx][zy] = 16;
        updateBtns();
        if( checkFinished() ) {
            setTimeout(function(){ 
                alert( ""WELL DONE!"" );
                restart();
            }, 1);
        }
    }
}
function createBoard() {
    board = new Array( 4 );
    for( var i = 0; i < 4; i++ ) {
        board[i] = new Array( 4 );
    }
    for( var j = 0; j < 4; j++ ) {
        for( var i = 0; i < 4; i++ ) {
            board[i][j] = ( i + j * 4 ) + 1;
        }
    }
    zx = zy = 3; board[zx][zy] = 16;
}
function createBtns() {
    var b, d = document.createElement( ""div"" );
    d.className += ""board"";
    document.body.appendChild( d );
    for( var j = 0; j < 4; j++ ) {
        for( var i = 0; i < 4; i++ ) {
            b = document.createElement( ""button"" );
            b.id = ""btn"" + ( i + j * 4 );
            b.i = i; b.j = j;
            b.addEventListener( ""click"", btnHandle, false );
            b.appendChild( document.createTextNode( """" ) );
            d.appendChild( b );
        }
    }
    clickCounter = document.createElement( ""p"" );
    clickCounter.className += ""txt"";
    document.body.appendChild( clickCounter );
}
function start() {
    createBtns();
    createBoard();
    restart();
}"
clr9q_4_2,clr9q,15 puzzle game,Game Development,Puzzles,php,T4,Different Language,"<?php




session_start([
   => 0,
   => 0,
   => 1,
]);

class Location
{
  protected $column, $row;

  function __construct($column, $row){
    $this->column = $column;
    $this->row = $row;
  }
  function create_neighbor($direction){
    $dx = 0; $dy = 0;
    switch ($direction){
      case 0: case 'left':  $dx = -1; break;
      case 1: case 'right': $dx = +1; break;
      case 2: case 'up':    $dy = -1; break;
      case 3: case 'down':  $dy = +1; break;
    }
    return new Location($this->column + $dx, $this->row + $dy);
  }
  function equals($that){
    return $this->column == $that->column && $this->row == $that->row;
  }
  function is_inside_rectangle($left, $top, $right, $bottom){
    return $left <= $this->column && $this->column <= $right
        && $top <= $this->row && $this->row <= $bottom;
  }
  function is_nearest_neighbor($that){
    $s = abs($this->column - $that->column) + abs($this->row - $that->row);
    return $s == 1;
  }
}

class Tile
{
  protected $index;
  protected $content;
  protected $target_location;
  protected $current_location;

  function __construct($index, $content, $row, $column){
    $this->index = $index;
    $this->content = $content;
    $this->target_location = new Location($row, $column);
    $this->current_location = $this->target_location;
  }
  function get_content(){
    return $this->content;
  }
  function get_index(){
    return $this->index;
  }
  function get_location(){
    return $this->current_location;
  }
  function is_completed(){
    return $this->current_location->equals($this->target_location);
  }
  function is_empty(){
    return $this->content == NULL;
  }
  function is_nearest_neighbor($that){
    $a = $this->current_location;
    $b = $that->current_location;
    return $a->is_nearest_neighbor($b);
  }
  function swap_locations($that){
    $a = $this->current_location;
    $b = $that->current_location;
    $this->current_location = $b;
    $that->current_location = $a;
  }
}

class Model
{
  protected $N;
  protected $M;
  protected $tiles;

  function __construct($N, $M){
    $this->N = $N;
    $this->M = $M;
    $this->tiles[0] = new Tile(0, NULL, $N, $M);
    for ($k = 1; $k < $N * $M; $k++ ){
      $i = 1 + intdiv($k - 1, $M);
      $j = 1 + ($k - 1) % $M;
      $this->tiles[$k] = new Tile($k, (string)$k, $i, $j);
    }
    $number_of_shuffles = 1000;
    $i = 0;
    while ($i < $number_of_shuffles)
      if ($this->move_in_direction(random_int(0, 3)))
        $i++;
  }
  function get_N(){
    return $this->N;
  }
  function get_M(){
    return $this->M;
  }
  function get_tile_by_index($index){
    return $this->tiles[$index];
  }
  function get_tile_at_location($location){
    foreach($this->tiles as $tile)
      if ($location->equals($tile->get_location()))
        return $tile;
    return NULL;
  }
  function is_completed(){
    foreach($this->tiles as $tile)
      if (!$tile->is_completed())
        return FALSE;
    return TRUE;
  }
  function move($tile){
    if ($tile != NULL)
      foreach($this->tiles as $target){
        if ($target->is_empty() && $target->is_nearest_neighbor($tile)){
          $tile->swap_locations($target);
          break;
        }
      }
  }
  function move_in_direction($direction){
    foreach($this->tiles as $tile)
      if ($tile->is_empty())
        break;   
    $location = $tile->get_location()->create_neighbor($direction);
    if ($location->is_inside_rectangle(0, 0, $this->M, $this->N)){
      $tile = $this->get_tile_at_location($location);
      $this->move($tile);
      return TRUE;
    }
    return FALSE;
  }
}

class View
{
  protected $model;

  function __construct($model){
      $this->model = $model;
  }
  function show(){
    $N = $this->model->get_N();
    $M = $this->model->get_M();
    echo ;
    for ($i = 1; $i <= $N; $i++){
      for ($j = 1; $j <= $M; $j++){
        $tile = $this->model->get_tile_at_location(new Location($i, $j));
        $content = $tile->get_content();
        if ($content != NULL)
          echo 
          .    
          .    
          .    ;
        else
          echo ;
      }
      echo ;
    }
    echo ;
    if ($this->model->is_completed()){
      echo ;
      echo ;
      echo ;
    }
  }
}

class Controller
{
  protected $model;
  protected $view;

  function __construct($model, $view){
    $this->model = $model;
    $this->view = $view;
  }
  function run(){
    if (isset($_GET['index'])){
      $index = $_GET['index'];
      $this->model->move($this->model->get_tile_by_index($index));
    }
    $this->view->show();
  }
}
?>

<!DOCTYPE html>
<html lang=><meta charset=>
<head>
  <title>15 puzzle game</title>
  <style>
    .puzzle{width: 4ch; display: inline-block; margin: 0; padding: 0.25ch;}
    span.puzzle{padding: 0.1ch;}
    .end-game{font-size: 400%; color: red;}
  </style>
</head>
<body>
  <p><?php
    if (!isset($_SESSION['model'])){
      $width = 4; $height = 4;
      $model = new Model($width, $height);
    }
    else
      $model = unserialize($_SESSION['model']);
    $view = new View($model);
    $controller = new Controller($model, $view);
    $controller->run();
    $_SESSION['model'] = serialize($model);
  ?></p>
</body>
</html>"
clr9q_4_2,clr9q,15 puzzle game,Game Development,Puzzles,ruby,T4,Different Language,"require 'io/console'

class Board
  SIZE = 4
  RANGE = 0...SIZE

  def initialize
    width = (SIZE*SIZE-1).to_s.size
    @frame = ( + *(width+2)) * SIZE + 
    @form =  * SIZE + 
    @step = 0
    @orign = [*0...SIZE*SIZE].rotate.each_slice(SIZE).to_a.freeze
    @board = @orign.map{|row | row.dup}
    randomize
    draw
    message
    play
  end

  private

  def randomize
    @board[0][0], @board[SIZE-1][SIZE-1] = 0, 1
    @board[SIZE-1][0], @board[0][SIZE-1] = @board[0][SIZE-1], @board[SIZE-1][0]
    x, y, dx, dy = 0, 0, 1, 0
    50.times do
      nx,ny = [[x+dx,y+dy], [x+dy,y-dx], [x-dy,y+dx]]
                .select{|nx,ny| RANGE.include?(nx) and RANGE.include?(ny)}
                .sample
      @board[nx][ny], @board[x][y] = 0, @board[nx][ny]
      x, y, dx, dy = nx, ny, nx-x, ny-y
    end
    @x, @y = x, y 
  end

  def draw
    puts 
    @board.each do |row|
      puts @frame
      puts (@form % row).sub(, )
    end
    puts @frame
    puts 
  end

  DIR = {up: [-1,0], down: [1,0], left: [0,-1], right: [0,1]}
  def move(direction)
    dx, dy = DIR[direction]
    nx, ny = @x + dx, @y + dy
    if RANGE.include?(nx) and RANGE.include?(ny)
      @board[nx][ny], @board[@x][@y] = 0, @board[nx][ny]
      @x, @y = nx, ny
      @step += 1
      draw
    end
  end

  def play
    until @board == @orign
      case  key_in
      when ,  then move(:up)
      when ,  then move(:down)
      when ,  then move(:right)
      when ,  then move(:left)

      when ,,  then exit
      when   then message
      end
    end

    puts 
  end

  def key_in
    input = STDIN.getch
    if input ==  
      2.times {input << STDIN.getch}
    end
    input
  end

  def message
    puts <<~EOM
      Use the arrow-keys or WASD on your keyboard to push board in the given direction.   
      PRESS q TO QUIT (or Ctrl-C or Ctrl-D)
    EOM
  end
end

Board.new"
inmof_1_1,inmof,2048,Game Development,Puzzles,python,T1,Identical Clone,"import curses
from random import randrange, choice 
from collections import defaultdict

letter_codes = [ord(ch) for ch in 'WASDRQwasdrq']
actions = ['Up', 'Left', 'Down', 'Right', 'Restart', 'Exit']
actions_dict = dict(zip(letter_codes, actions * 2))

def get_user_action(keyboard):    
	char = 
	while char not in actions_dict:    
		char = keyboard.getch()
	return actions_dict[char]

def transpose(field):
	return [list(row) for row in zip(*field)]

def invert(field):
	return [row[::-1] for row in field]

class GameField(object):
	def __init__(self, height=4, width=4, win=2048):
		self.height = height
		self.width = width
		self.win_value = win
		self.score = 0
		self.highscore = 0
		self.reset()

	def reset(self):
		if self.score > self.highscore:
			self.highscore = self.score
		self.score = 0
		self.field = [[0 for i in range(self.width)] for j in range(self.height)]
		self.spawn()
		self.spawn()

	def move(self, direction):
		def move_row_left(row):
			def tighten(row): 
				new_row = [i for i in row if i != 0]
				new_row += [0 for i in range(len(row) - len(new_row))]
				return new_row

			def merge(row):
				pair = False
				new_row = []
				for i in range(len(row)):
					if pair:
						new_row.append(2 * row[i])
						self.score += 2 * row[i]
						pair = False
					else:
						if i + 1 < len(row) and row[i] == row[i + 1]:
							pair = True
							new_row.append(0)
						else:
							new_row.append(row[i])
				assert len(new_row) == len(row)
				return new_row
			return tighten(merge(tighten(row)))

		moves = {}
		moves['Left']  = lambda field:								\
				[move_row_left(row) for row in field]
		moves['Right'] = lambda field:								\
				invert(moves['Left'](invert(field)))
		moves['Up']    = lambda field:								\
				transpose(moves['Left'](transpose(field)))
		moves['Down']  = lambda field:								\
				transpose(moves['Right'](transpose(field)))

		if direction in moves:
			if self.move_is_possible(direction):
				self.field = moves[direction](self.field)
				self.spawn()
				return True
			else:
				return False

	def is_win(self):
		return any(any(i >= self.win_value for i in row) for row in self.field)

	def is_gameover(self):
		return not any(self.move_is_possible(move) for move in actions)

	def draw(self, screen):
		help_string1 = '(W)Up (S)Down (A)Left (D)Right'
		help_string2 = '     (R)Restart (Q)Exit'
		gameover_string = '           GAME OVER'
		win_string = '          YOU WIN!'
		def cast(string):
			screen.addstr(string + '\n')

		def draw_hor_separator():
			top = '' + ('' * self.width + '')[1:]
			mid = '' + ('' * self.width + '')[1:]
			bot = '' + ('' * self.width + '')[1:]
			separator = defaultdict(lambda: mid)
			separator[0], separator[self.height] = top, bot
			if not hasattr(draw_hor_separator, ):
				draw_hor_separator.counter = 0
			cast(separator[draw_hor_separator.counter])
			draw_hor_separator.counter += 1

		def draw_row(row):
			cast(''.join('{: ^5} '.format(num) if num > 0 else '|      ' for num in row) + '')

		screen.clear()
		cast('SCORE: ' + str(self.score))
		if 0 != self.highscore:
			cast('HIGHSCORE: ' + str(self.highscore))
		for row in self.field:
			draw_hor_separator()
			draw_row(row)
		draw_hor_separator()
		if self.is_win():
			cast(win_string)
		else:
			if self.is_gameover():
				cast(gameover_string)
			else:
				cast(help_string1)
		cast(help_string2)

	def spawn(self):
		new_element = 4 if randrange(100) > 89 else 2
		(i,j) = choice([(i,j) for i in range(self.width) for j in range(self.height) if self.field[i][j] == 0])
		self.field[i][j] = new_element

	def move_is_possible(self, direction):
		def row_is_left_movable(row): 
			def change(i): 
				if row[i] == 0 and row[i + 1] != 0: 
					return True
				if row[i] != 0 and row[i + 1] == row[i]: 
					return True
				return False
			return any(change(i) for i in range(len(row) - 1))

		check = {}
		check['Left']  = lambda field:								\
				any(row_is_left_movable(row) for row in field)

		check['Right'] = lambda field:								\
				 check['Left'](invert(field))

		check['Up']    = lambda field:								\
				check['Left'](transpose(field))

		check['Down']  = lambda field:								\
				check['Right'](transpose(field))

		if direction in check:
			return check[direction](self.field)
		else:
			return False

def main(stdscr):
	curses.use_default_colors()
	game_field = GameField(win=32)
	state_actions = {} 
	def init():
		game_field.reset()
		return 'Game'

	state_actions['Init'] = init

	def not_game(state):
		game_field.draw(stdscr)
		action = get_user_action(stdscr)
		responses = defaultdict(lambda: state)
		responses['Restart'], responses['Exit'] = 'Init', 'Exit'
		return responses[action]

	state_actions['Win'] = lambda: not_game('Win')
	state_actions['Gameover'] = lambda: not_game('Gameover')

	def game():
		game_field.draw(stdscr)
		action = get_user_action(stdscr)
		if action == 'Restart':
			return 'Init'
		if action == 'Exit':
			return 'Exit'
		if game_field.move(action): 
			if game_field.is_win():
				return 'Win'
			if game_field.is_gameover():
				return 'Gameover'
		return 'Game'

	state_actions['Game'] = game

	state = 'Init'
	while state != 'Exit':
		state = state_actions[state]()

curses.wrapper(main)"
inmof_1_2,inmof,2048,Game Development,Puzzles,python,T1,Different Whitespaces,"import curses
from random import randrange, choice
from collections import defaultdict

letter_codes = [ord(ch) for ch in 'WASDRQwasdrq']
actions = ['Up', 'Left', 'Down', 'Right', 'Restart', 'Exit']
actions_dict = dict(zip(letter_codes, actions * 2))

def get_user_action(keyboard):
    char = 0
    while char not in actions_dict:
        char = keyboard.getch()
    return actions_dict[char]

def transpose(field):
    return [list(row) for row in zip(*field)]

def invert(field):
    return [row[::-1] for row in field]

class GameField(object):
    def __init__(self, height=4, width=4, win=2048):
        self.height = height
        self.width = width
        self.win_value = win
        self.score = 0
        self.highscore = 0
        self.reset()

    def reset(self):
        if self.score > self.highscore:
            self.highscore = self.score
        self.score = 0
        self.field = [[0 for i in range(self.width)] for j in range(self.height)]
        self.spawn()
        self.spawn()

    def move(self, direction):
        def move_row_left(row):
            def tighten(row):
                new_row = [i for i in row if i != 0]
                new_row += [0 for i in range(len(row) - len(new_row))]
                return new_row

            def merge(row):
                pair = False
                new_row = []
                for i in range(len(row)):
                    if pair:
                        new_row.append(2 * row[i])
                        self.score += 2 * row[i]
                        pair = False
                    else:
                        if i + 1 < len(row) and row[i] == row[i + 1]:
                            pair = True
                            new_row.append(0)
                        else:
                            new_row.append(row[i])
                assert len(new_row) == len(row)
                return new_row
            return tighten(merge(tighten(row)))

        moves = {}
        moves['Left']  = lambda field:                                       \
                [move_row_left(row) for row in field]
        moves['Right'] = lambda field:                                       \
                invert(moves['Left'](invert(field)))
        moves['Up']    = lambda field:                                       \
                transpose(moves['Left'](transpose(field)))
        moves['Down']  = lambda field:                                       \
                transpose(moves['Right'](transpose(field)))

        if direction in moves:
            if self.move_is_possible(direction):
                self.field = moves[direction](self.field)
                self.spawn()
                return True
            else:
                return False

    def is_win(self):
        return any(any(i >= self.win_value for i in row) for row in self.field)

    def is_gameover(self):
        return not any(self.move_is_possible(move) for move in actions)

    def draw(self, screen):
        help_string1 = '(W)Up (S)Down (A)Left (D)Right'
        help_string2 = '     (R)Restart (Q)Exit'
        gameover_string = '           GAME OVER'
        win_string = '          YOU WIN!'
        def cast(string):
            screen.addstr(string + '\n')

        def draw_hor_separator():
            top = '' + ('' * self.width + '')[1:]
            mid = '' + ('' * self.width + '')[1:]
            bot = '' + ('' * self.width + '')[1:]
            separator = defaultdict(lambda: mid)
            separator[0], separator[self.height] = top, bot
            if not hasattr(draw_hor_separator, ):
                draw_hor_separator.counter = 0
            cast(separator[draw_hor_separator.counter])
            draw_hor_separator.counter += 1

        def draw_row(row):
            cast(''.join('{: ^5} '.format(num) if num > 0 else '|      ' for num in row) + '')

        screen.clear()
        cast('SCORE: ' + str(self.score))
        if 0 != self.highscore:
            cast('HIGHSCORE: ' + str(self.highscore))
        for row in self.field:
            draw_hor_separator()
            draw_row(row)
        draw_hor_separator()
        if self.is_win():
            cast(win_string)
        else:
            if self.is_gameover():
                cast(gameover_string)
            else:
                cast(help_string1)
        cast(help_string2)

    def spawn(self):
        new_element = 4 if randrange(100) > 89 else 2
        (i,j) = choice([(i,j) for i in range(self.width) for j in range(self.height) if self.field[i][j] == 0])
        self.field[i][j] = new_element

    def move_is_possible(self, direction):
        def row_is_left_movable(row): 
            def change(i): 
                if row[i] == 0 and row[i + 1] != 0: 
                    return True
                if row[i] != 0 and row[i + 1] == row[i]: 
                    return True
                return False
            return any(change(i) for i in range(len(row) - 1))

        check = {}
        check['Left']  = lambda field:                                  \
                any(row_is_left_movable(row) for row in field)

        check['Right'] = lambda field:                                  \
                 check['Left'](invert(field))

        check['Up']    = lambda field:                                  \
                check['Left'](transpose(field))

        check['Down']  = lambda field:                                  \
                check['Right'](transpose(field))

        if direction in check:
            return check[direction](self.field)
        else:
            return False

def main(stdscr):
    curses.use_default_colors()
    game_field = GameField(win=32)
    state_actions = {} 
    def init():
        game_field.reset()
        return 'Game'

    state_actions['Init'] = init

    def not_game(state):
        game_field.draw(stdscr)
        action = get_user_action(stdscr)
        responses = defaultdict(lambda: state)
        responses['Restart'], responses['Exit'] = 'Init', 'Exit'
        return responses[action]

    state_actions['Win'] = lambda: not_game('Win')
    state_actions['Gameover'] = lambda: not_game('Gameover')

    def game():
        game_field.draw(stdscr)
        action = get_user_action(stdscr)
        if action == 'Restart':
            return 'Init'
        if action == 'Exit':
            return 'Exit'
        if game_field.move(action): 
            if game_field.is_win():
                return 'Win'
            if game_field.is_gameover():
                return 'Gameover'
        return 'Game'

    state_actions['Game'] = game

    state = 'Init'
    while state != 'Exit':
        state = state_actions[state]()

curses.wrapper(main)"
inmof_1_3,inmof,2048,Game Development,Puzzles,python,T1,Different Comments,"import curses
from random import randrange, choice 
from collections import defaultdict

letter_codes = [ord(ch) for ch in 'WASDRQwasdrq']
actions = ['Up', 'Left', 'Down', 'Right', 'Restart', 'Exit']
actions_dict = dict(zip(letter_codes, actions * 2))

def get_user_action(keyboard):
	char = 
	while char not in actions_dict:    
		char = keyboard.getch()
	return actions_dict[char]

def transpose(field):
	return [list(row) for row in zip(*field)]

def invert(field):
	return [row[::-1] for row in field]

class GameField(object):
	def __init__(self, height=4, width=4, win=2048):
		self.height = height
		self.width = width
		self.win_value = win
		self.score = 0
		self.highscore = 0
		self.reset()

	def reset(self):
		if self.score > self.highscore:
			self.highscore = self.score
		self.score = 0
		self.field = [[0 for i in range(self.width)] for j in range(self.height)]
		self.spawn()
		self.spawn()

	def move(self, direction):
		def move_row_left(row):
			def tighten(row): 
				new_row = [i for i in row if i != 0]
				new_row += [0 for i in range(len(row) - len(new_row))]
				return new_row

			def merge(row):
				pair = False
				new_row = []
				for i in range(len(row)):
					if pair:
						new_row.append(2 * row[i])
						self.score += 2 * row[i]
						pair = False
					else:
						if i + 1 < len(row) and row[i] == row[i + 1]:
							pair = True
							new_row.append(0)
						else:
							new_row.append(row[i])
				assert len(new_row) == len(row)
				return new_row
			return tighten(merge(tighten(row)))

		moves = {}
		moves['Left']  = lambda field:								\
				[move_row_left(row) for row in field]
		moves['Right'] = lambda field:								\
				invert(moves['Left'](invert(field)))
		moves['Up']    = lambda field:								\
				transpose(moves['Left'](transpose(field)))
		moves['Down']  = lambda field:								\
				transpose(moves['Right'](transpose(field)))

		if direction in moves:
			if self.move_is_possible(direction):
				self.field = moves[direction](self.field)
				self.spawn()
				return True
			else:
				return False

	def is_win(self):
		return any(any(i >= self.win_value for i in row) for row in self.field)

	def is_gameover(self):
		return not any(self.move_is_possible(move) for move in actions)

	def draw(self, screen):
		help_string1 = '(W)Up (S)Down (A)Left (D)Right'
		help_string2 = '     (R)Restart (Q)Exit'
		gameover_string = '           GAME OVER'
		win_string = '          YOU WIN!'
		def cast(string):
			screen.addstr(string + '\n')

		def draw_hor_separator():
			top = '' + ('' * self.width + '')[1:]
			mid = '' + ('' * self.width + '')[1:]
			bot = '' + ('' * self.width + '')[1:]
			separator = defaultdict(lambda: mid)
			separator[0], separator[self.height] = top, bot
			if not hasattr(draw_hor_separator, ):
				draw_hor_separator.counter = 0
			cast(separator[draw_hor_separator.counter])
			draw_hor_separator.counter += 1

		def draw_row(row):
			cast(''.join('{: ^5} '.format(num) if num > 0 else '|      ' for num in row) + '')

		screen.clear()
		cast('SCORE: ' + str(self.score))
		if 0 != self.highscore:
			cast('HIGHSCORE: ' + str(self.highscore))
		for row in self.field:
			draw_hor_separator()
			draw_row(row)
		draw_hor_separator()
		if self.is_win():
			cast(win_string)
		else:
			if self.is_gameover():
				cast(gameover_string)
			else:
				cast(help_string1)
		cast(help_string2)

	def spawn(self):
		new_element = 4 if randrange(100) > 89 else 2
		(i,j) = choice([(i,j) for i in range(self.width) for j in range(self.height) if self.field[i][j] == 0])
		self.field[i][j] = new_element

	def move_is_possible(self, direction):
		def row_is_left_movable(row): 
			def change(i): 
				if row[i] == 0 and row[i + 1] != 0: 
					return True
				if row[i] != 0 and row[i + 1] == row[i]: 
					return True
				return False
			return any(change(i) for i in range(len(row) - 1))

		check = {}
		check['Left']  = lambda field:								\
				any(row_is_left_movable(row) for row in field)

		check['Right'] = lambda field:								\
				 check['Left'](invert(field))

		check['Up']    = lambda field:								\
				check['Left'](transpose(field))

		check['Down']  = lambda field:								\
				check['Right'](transpose(field))

		if direction in check:
			return check[direction](self.field)
		else:
			return False

def main(stdscr):
	curses.use_default_colors()
	game_field = GameField(win=32)
	state_actions = {} 
	def init():
		game_field.reset()
		return 'Game'

	state_actions['Init'] = init

	def not_game(state):
		game_field.draw(stdscr)
		action = get_user_action(stdscr)
		responses = defaultdict(lambda: state)
		responses['Restart'], responses['Exit'] = 'Init', 'Exit'
		return responses[action]

	state_actions['Win'] = lambda: not_game('Win')
	state_actions['Gameover'] = lambda: not_game('Gameover')

	def game():
		game_field.draw(stdscr)
		action = get_user_action(stdscr)
		if action == 'Restart':
			return 'Init'
		if action == 'Exit':
			return 'Exit'
		if game_field.move(action): 
			if game_field.is_win():
				return 'Win'
			if game_field.is_gameover():
				return 'Gameover'
		return 'Game'

	state_actions['Game'] = game

	state = 'Init'
	while state != 'Exit':
		state = state_actions[state]()

curses.wrapper(main)"
inmof_1_4,inmof,2048,Game Development,Puzzles,python,T1,Different Formatting,"import curses
from random import randrange, choice
from collections import defaultdict

letter_codes = [ord(ch) for ch in 'WASDRQwasdrq']
actions = ['Up', 'Left', 'Down', 'Right', 'Restart', 'Exit']
actions_dict = dict(zip(letter_codes, actions * 2))

def get_user_action(keyboard):
    char = None
    while char not in actions_dict:
        char = keyboard.getch()
    return actions_dict[char]

def transpose(field):
    return [list(row) for row in zip(*field)]

def invert(field):
    return [row[::-1] for row in field]

class GameField(object):
    def __init__(self, height=4, width=4, win=2048):
        self.height = height
        self.width = width
        self.win_value = win
        self.score = 0
        self.highscore = 0
        self.reset()

    def reset(self):
        if self.score > self.highscore:
            self.highscore = self.score
        self.score = 0
        self.field = [[0 for i in range(self.width)] for j in range(self.height)]
        self.spawn()
        self.spawn()

    def move(self, direction):
        def move_row_left(row):
            def tighten(row):
                new_row = [i for i in row if i != 0]
                new_row += [0 for i in range(len(row) - len(new_row))]
                return new_row

            def merge(row):
                pair = False
                new_row = []
                for i in range(len(row)):
                    if pair:
                        new_row.append(2 * row[i])
                        self.score += 2 * row[i]
                        pair = False
                    else:
                        if i + 1 < len(row) and row[i] == row[i + 1]:
                            pair = True
                            new_row.append(0)
                        else:
                            new_row.append(row[i])
                assert len(new_row) == len(row)
                return new_row
            return tighten(merge(tighten(row)))

        moves = {}
        moves['Left'] = lambda field: [move_row_left(row) for row in field]
        moves['Right'] = lambda field: invert(moves['Left'](invert(field)))
        moves['Up'] = lambda field: transpose(moves['Left'](transpose(field)))
        moves['Down'] = lambda field: transpose(moves['Right'](transpose(field)))

        if direction in moves:
            if self.move_is_possible(direction):
                self.field = moves[direction](self.field)
                self.spawn()
                return True
            else:
                return False

    def is_win(self):
        return any(any(i >= self.win_value for i in row) for row in self.field)

    def is_gameover(self):
        return not any(self.move_is_possible(move) for move in actions)

    def draw(self, screen):
        help_string1 = '(W)Up (S)Down (A)Left (D)Right'
        help_string2 = '     (R)Restart (Q)Exit'
        gameover_string = '           GAME OVER'
        win_string = '          YOU WIN!'

        def cast(string):
            screen.addstr(string + '\n')

        def draw_hor_separator():
            top = '+' + ('-' * self.width + '+')[1:]
            mid = '|' + (' ' * self.width + '|')[1:]
            bot = '+' + ('-' * self.width + '+')[1:]
            separator = defaultdict(lambda: mid)
            separator[0], separator[self.height] = top, bot
            if not hasattr(draw_hor_separator, 'counter'):
                draw_hor_separator.counter = 0
            cast(separator[draw_hor_separator.counter])
            draw_hor_separator.counter += 1

        def draw_row(row):
            cast(''.join('{: ^5} '.format(num) if num > 0 else '|      ' for num in row) + '|')

        screen.clear()
        cast('SCORE: ' + str(self.score))
        if 0 != self.highscore:
            cast('HIGHSCORE: ' + str(self.highscore))
        for row in self.field:
            draw_hor_separator()
            draw_row(row)
        draw_hor_separator()
        if self.is_win():
            cast(win_string)
        else:
            if self.is_gameover():
                cast(gameover_string)
            else:
                cast(help_string1)
        cast(help_string2)

    def spawn(self):
        new_element = 4 if randrange(100) > 89 else 2
        (i, j) = choice([(i, j) for i in range(self.width) for j in range(self.height) if self.field[i][j] == 0])
        self.field[i][j] = new_element

    def move_is_possible(self, direction):
        def row_is_left_movable(row):
            def change(i):
                if row[i] == 0 and row[i + 1] != 0:
                    return True
                if row[i] != 0 and row[i + 1] == row[i]:
                    return True
                return False
            return any(change(i) for i in range(len(row) - 1))

        check = {}
        check['Left'] = lambda field: any(row_is_left_movable(row) for row in field)
        check['Right'] = lambda field: check['Left'](invert(field))
        check['Up'] = lambda field: check['Left'](transpose(field))
        check['Down'] = lambda field: check['Right'](transpose(field))

        if direction in check:
            return check[direction](self.field)
        else:
            return False

def main(stdscr):
    curses.use_default_colors()
    game_field = GameField(win=32)
    state_actions = {}

    def init():
        game_field.reset()
        return 'Game'

    state_actions['Init'] = init

    def not_game(state):
        game_field.draw(stdscr)
        action = get_user_action(stdscr)
        responses = defaultdict(lambda: state)
        responses['Restart'], responses['Exit'] = 'Init', 'Exit'
        return responses[action]

    state_actions['Win'] = lambda: not_game('Win')
    state_actions['Gameover'] = lambda: not_game('Gameover')

    def game():
        game_field.draw(stdscr)
        action = get_user_action(stdscr)
        if action == 'Restart':
            return 'Init'
        if action == 'Exit':
            return 'Exit'
        if game_field.move(action):
            if game_field.is_win():
                return 'Win'
            if game_field.is_gameover():
                return 'Gameover'
        return 'Game'

    state_actions['Game'] = game

    state = 'Init'
    while state != 'Exit':
        state = state_actions[state]()

curses.wrapper(main)"
inmof_2_1,inmof,2048,Game Development,Puzzles,python,T2,Different Variable Names,"import curses
from random import randrange, choice 
from collections import defaultdict

key_codes = [ord(ch) for ch in 'WASDRQwasdrq']
cmds = ['Up', 'Left', 'Down', 'Right', 'Restart', 'Exit']
cmds_dict = dict(zip(key_codes, cmds * 2))

def get_action(input):    
	key = 
	while key not in cmds_dict:    
		key = input.getch()
	return cmds_dict[key]

def rotate(grid):
	return [list(row) for row in zip(*grid)]

def reverse(grid):
	return [row[::-1] for row in grid]

class Board(object):
	def __init__(self, rows=4, cols=4, target=2048):
		self.rows = rows
		self.cols = cols
		self.target_value = target
		self.current_score = 0
		self.best_score = 0
		self.initialize()

	def initialize(self):
		if self.current_score > self.best_score:
			self.best_score = self.current_score
		self.current_score = 0
		self.grid = [[0 for i in range(self.cols)] for j in range(self.rows)]
		self.place_new()
		self.place_new()

	def slide(self, move):
		def slide_row_left(row):
			def compress(row): 
				new_row = [i for i in row if i != 0]
				new_row += [0 for i in range(len(row) - len(new_row))]
				return new_row

			def combine(row):
				pair = False
				new_row = []
				for i in range(len(row)):
					if pair:
						new_row.append(2 * row[i])
						self.current_score += 2 * row[i]
						pair = False
					else:
						if i + 1 < len(row) and row[i] == row[i + 1]:
							pair = True
							new_row.append(0)
						else:
							new_row.append(row[i])
				assert len(new_row) == len(row)
				return new_row
			return compress(combine(compress(row)))

		slide_moves = {}
		slide_moves['Left']  = lambda grid:								\
				[slide_row_left(row) for row in grid]
		slide_moves['Right'] = lambda grid:								\
				reverse(slide_moves['Left'](reverse(grid)))
		slide_moves['Up']    = lambda grid:								\
				rotate(slide_moves['Left'](rotate(grid)))
		slide_moves['Down']  = lambda grid:								\
				rotate(slide_moves['Right'](rotate(grid)))

		if move in slide_moves:
			if self.is_move_valid(move):
				self.grid = slide_moves[move](self.grid)
				self.place_new()
				return True
			else:
				return False

	def check_win(self):
		return any(any(i >= self.target_value for i in row) for row in self.grid)

	def check_gameover(self):
		return not any(self.is_move_valid(cmd) for cmd in cmds)

	def render(self, display):
		instructions1 = '(W)Up (S)Down (A)Left (D)Right'
		instructions2 = '     (R)Restart (Q)Exit'
		end_game_msg = '           GAME OVER'
		win_msg = '          YOU WIN!'
		def output(text):
			display.addstr(text + '\n')

		def draw_separator():
			top = '' + ('' * self.cols + '')[1:]
			middle = '' + ('' * self.cols + '')[1:]
			bottom = '' + ('' * self.cols + '')[1:]
			separator = defaultdict(lambda: middle)
			separator[0], separator[self.rows] = top, bottom
			if not hasattr(draw_separator, ):
				draw_separator.counter = 0
			output(separator[draw_separator.counter])
			draw_separator.counter += 1

		def draw_cells(row):
			output(''.join('{: ^5} '.format(num) if num > 0 else '|      ' for num in row) + '')

		display.clear()
		output('SCORE: ' + str(self.current_score))
		if 0 != self.best_score:
			output('HIGHSCORE: ' + str(self.best_score))
		for row in self.grid:
			draw_separator()
			draw_cells(row)
		draw_separator()
		if self.check_win():
			output(win_msg)
		else:
			if self.check_gameover():
				output(end_game_msg)
			else:
				output(instructions1)
		output(instructions2)

	def place_new(self):
		new_tile = 4 if randrange(100) > 89 else 2
		(i,j) = choice([(i,j) for i in range(self.cols) for j in range(self.rows) if self.grid[i][j] == 0])
		self.grid[i][j] = new_tile

	def is_move_valid(self, move):
		def is_row_movable(row): 
			def check(i): 
				if row[i] == 0 and row[i + 1] != 0: 
					return True
				if row[i] != 0 and row[i + 1] == row[i]: 
					return True
				return False
			return any(check(i) for i in range(len(row) - 1))

		validate = {}
		validate['Left']  = lambda grid:								\
				any(is_row_movable(row) for row in grid)

		validate['Right'] = lambda grid:								\
				 validate['Left'](reverse(grid))

		validate['Up']    = lambda grid:								\
				validate['Left'](rotate(grid))

		validate['Down']  = lambda grid:								\
				validate['Right'](rotate(grid))

		if move in validate:
			return validate[move](self.grid)
		else:
			return False

def start(display):
	curses.use_default_colors()
	board = Board(target=32)
	game_states = {} 
	def init():
		board.initialize()
		return 'Game'

	game_states['Init'] = init

	def non_game(state):
		board.render(display)
		action = get_action(display)
		state_responses = defaultdict(lambda: state)
		state_responses['Restart'], state_responses['Exit'] = 'Init', 'Exit'
		return state_responses[action]

	game_states['Win'] = lambda: non_game('Win')
	game_states['Gameover'] = lambda: non_game('Gameover')

	def play():
		board.render(display)
		action = get_action(display)
		if action == 'Restart':
			return 'Init'
		if action == 'Exit':
			return 'Exit'
		if board.slide(action): 
			if board.check_win():
				return 'Win'
			if board.check_gameover():
				return 'Gameover'
		return 'Game'

	game_states['Game'] = play

	state = 'Init'
	while state != 'Exit':
		state = game_states[state]()

curses.wrapper(start)"
inmof_2_2,inmof,2048,Game Development,Puzzles,python,T2,Different Data Types,"import curses
from random import randrange, choice 
from collections import defaultdict

letter_codes = [ord(ch) for ch in 'WASDRQwasdrq']
actions = ['Up', 'Left', 'Down', 'Right', 'Restart', 'Exit']
actions_dict = dict(zip(letter_codes, actions * 2))

def get_user_action(keyboard):    
	char = 0
	while char not in actions_dict:    
		char = keyboard.getch()
	return actions_dict[char]

def transpose(field):
	return [list(row) for row in zip(*field)]

def invert(field):
	return [row[::-1] for row in field]

class GameField(object):
	def __init__(self, height=4, width=4, win=2048):
		self.height = height
		self.width = width
		self.win_value = win
		self.score = 0
		self.highscore = 0
		self.reset()

	def reset(self):
		if self.score > self.highscore:
			self.highscore = self.score
		self.score = 0
		self.field = [[0 for i in range(self.width)] for j in range(self.height)]
		self.spawn()
		self.spawn()

	def move(self, direction):
		def move_row_left(row):
			def tighten(row): 
				new_row = [i for i in row if i != 0]
				new_row += [0 for i in range(len(row) - len(new_row))]
				return new_row

			def merge(row):
				pair = False
				new_row = []
				for i in range(len(row)):
					if pair:
						new_row.append(2 * row[i])
						self.score += 2 * row[i]
						pair = False
					else:
						if i + 1 < len(row) and row[i] == row[i + 1]:
							pair = True
							new_row.append(0)
						else:
							new_row.append(row[i])
				assert len(new_row) == len(row)
				return new_row
			return tighten(merge(tighten(row)))

		moves = {}
		moves['Left']  = lambda field:								\
				[move_row_left(row) for row in field]
		moves['Right'] = lambda field:								\
				invert(moves['Left'](invert(field)))
		moves['Up']    = lambda field:								\
				transpose(moves['Left'](transpose(field)))
		moves['Down']  = lambda field:								\
				transpose(moves['Right'](transpose(field)))

		if direction in moves:
			if self.move_is_possible(direction):
				self.field = moves[direction](self.field)
				self.spawn()
				return True
			else:
				return False

	def is_win(self):
		return any(any(i >= self.win_value for i in row) for row in self.field)

	def is_gameover(self):
		return not any(self.move_is_possible(move) for move in actions)

	def draw(self, screen):
		help_string1 = '(W)Up (S)Down (A)Left (D)Right'
		help_string2 = '     (R)Restart (Q)Exit'
		gameover_string = '           GAME OVER'
		win_string = '          YOU WIN!'
		def cast(string):
			screen.addstr(string + '\n')

		def draw_hor_separator():
			top = '' + ('' * self.width + '')[1:]
			mid = '' + ('' * self.width + '')[1:]
			bot = '' + ('' * self.width + '')[1:]
			separator = defaultdict(lambda: mid)
			separator[0], separator[self.height] = top, bot
			if not hasattr(draw_hor_separator, ):
				draw_hor_separator.counter = 0
			cast(separator[draw_hor_separator.counter])
			draw_hor_separator.counter += 1

		def draw_row(row):
			cast(''.join('{: ^5} '.format(num) if num > 0 else '|      ' for num in row) + '')

		screen.clear()
		cast('SCORE: ' + str(self.score))
		if 0 != self.highscore:
			cast('HIGHSCORE: ' + str(self.highscore))
		for row in self.field:
			draw_hor_separator()
			draw_row(row)
		draw_hor_separator()
		if self.is_win():
			cast(win_string)
		else:
			if self.is_gameover():
				cast(gameover_string)
			else:
				cast(help_string1)
		cast(help_string2)

	def spawn(self):
		new_element = 4 if randrange(100) > 89 else 2
		(i,j) = choice([(i,j) for i in range(self.height) for j in range(self.width) if self.field[i][j] == 0])
		self.field[i][j] = new_element

	def move_is_possible(self, direction):
		def row_is_left_movable(row): 
			def change(i): 
				if row[i] == 0 and row[i + 1] != 0: 
					return True
				if row[i] != 0 and row[i + 1] == row[i]: 
					return True
				return False
			return any(change(i) for i in range(len(row) - 1))

		check = {}
		check['Left']  = lambda field:								\
				any(row_is_left_movable(row) for row in field)

		check['Right'] = lambda field:								\
				 check['Left'](invert(field))

		check['Up']    = lambda field:								\
				check['Left'](transpose(field))

		check['Down']  = lambda field:								\
				check['Right'](transpose(field))

		if direction in check:
			return check[direction](self.field)
		else:
			return False

def main(stdscr):
	curses.use_default_colors()
	game_field = GameField(win=32)
	state_actions = {} 
	def init():
		game_field.reset()
		return 'Game'

	state_actions['Init'] = init

	def not_game(state):
		game_field.draw(stdscr)
		action = get_user_action(stdscr)
		responses = defaultdict(lambda: state)
		responses['Restart'], responses['Exit'] = 'Init', 'Exit'
		return responses[action]

	state_actions['Win'] = lambda: not_game('Win')
	state_actions['Gameover'] = lambda: not_game('Gameover')

	def game():
		game_field.draw(stdscr)
		action = get_user_action(stdscr)
		if action == 'Restart':
			return 'Init'
		if action == 'Exit':
			return 'Exit'
		if game_field.move(action): 
			if game_field.is_win():
				return 'Win'
			if game_field.is_gameover():
				return 'Gameover'
		return 'Game'

	state_actions['Game'] = game

	state = 'Init'
	while state != 'Exit':
		state = state_actions[state]()

curses.wrapper(main)"
inmof_2_3,inmof,2048,Game Development,Puzzles,python,T2,Different Function Names,"import curses
from random import randrange, choice 
from collections import defaultdict

letter_codes = [ord(ch) for ch in 'WASDRQwasdrq']
actions = ['Up', 'Left', 'Down', 'Right', 'Restart', 'Exit']
actions_dict = dict(zip(letter_codes, actions * 2))

def get_user_input(keyboard):    
	char = 
	while char not in actions_dict:    
		char = keyboard.getch()
	return actions_dict[char]

def rotate(field):
	return [list(row) for row in zip(*field)]

def reverse(field):
	return [row[::-1] for row in field]

class GridGame(object):
	def __init__(self, height=4, width=4, win=2048):
		self.height = height
		self.width = width
		self.win_value = win
		self.score = 0
		self.highscore = 0
		self.reset()

	def reset(self):
		if self.score > self.highscore:
			self.highscore = self.score
		self.score = 0
		self.field = [[0 for i in range(self.width)] for j in range(self.height)]
		self.spawn()
		self.spawn()

	def shift(self, direction):
		def move_line_left(line):
			def compact(line): 
				new_line = [i for i in line if i != 0]
				new_line += [0 for i in range(len(line) - len(new_line))]
				return new_line

			def combine(line):
				pair = False
				new_line = []
				for i in range(len(line)):
					if pair:
						new_line.append(2 * line[i])
						self.score += 2 * line[i]
						pair = False
					else:
						if i + 1 < len(line) and line[i] == line[i + 1]:
							pair = True
							new_line.append(0)
						else:
							new_line.append(line[i])
				assert len(new_line) == len(line)
				return new_line
			return compact(combine(compact(line)))

		movements = {}
		movements['Left']  = lambda field:								\
				[move_line_left(row) for row in field]
		movements['Right'] = lambda field:								\
				reverse(movements['Left'](reverse(field)))
		movements['Up']    = lambda field:								\
				rotate(movements['Left'](rotate(field)))
		movements['Down']  = lambda field:								\
				rotate(movements['Right'](rotate(field)))

		if direction in movements:
			if self.move_is_possible(direction):
				self.field = movements[direction](self.field)
				self.spawn()
				return True
			else:
				return False

	def check_win(self):
		return any(any(i >= self.win_value for i in row) for row in self.field)

	def check_gameover(self):
		return not any(self.move_is_possible(move) for move in actions)

	def render(self, screen):
		help_string1 = '(W)Up (S)Down (A)Left (D)Right'
		help_string2 = '     (R)Restart (Q)Exit'
		gameover_string = '           GAME OVER'
		win_string = '          YOU WIN!'
		def output(string):
			screen.addstr(string + '\n')

		def draw_horizontal_separator():
			top = '' + ('' * self.width + '')[1:]
			mid = '' + ('' * self.width + '')[1:]
			bot = '' + ('' * self.width + '')[1:]
			separator = defaultdict(lambda: mid)
			separator[0], separator[self.height] = top, bot
			if not hasattr(draw_horizontal_separator, ):
				draw_horizontal_separator.counter = 0
			output(separator[draw_horizontal_separator.counter])
			draw_horizontal_separator.counter += 1

		def draw_line(line):
			output(''.join('{: ^5} '.format(num) if num > 0 else '|      ' for num in line) + '')

		screen.clear()
		output('SCORE: ' + str(self.score))
		if 0 != self.highscore:
			output('HIGHSCORE: ' + str(self.highscore))
		for row in self.field:
			draw_horizontal_separator()
			draw_line(row)
		draw_horizontal_separator()
		if self.check_win():
			output(win_string)
		else:
			if self.check_gameover():
				output(gameover_string)
			else:
				output(help_string1)
		output(help_string2)

	def spawn(self):
		new_element = 4 if randrange(100) > 89 else 2
		(i,j) = choice([(i,j) for i in range(self.width) for j in range(self.height) if self.field[i][j] == 0])
		self.field[i][j] = new_element

	def move_is_possible(self, direction):
		def line_is_left_movable(line): 
			def alteration(i): 
				if line[i] == 0 and line[i + 1] != 0: 
					return True
				if line[i] != 0 and line[i + 1] == line[i]: 
					return True
				return False
			return any(alteration(i) for i in range(len(line) - 1))

		check = {}
		check['Left']  = lambda field:								\
				any(line_is_left_movable(row) for row in field)

		check['Right'] = lambda field:								\
				 check['Left'](reverse(field))

		check['Up']    = lambda field:								\
				check['Left'](rotate(field))

		check['Down']  = lambda field:								\
				check['Right'](rotate(field))

		if direction in check:
			return check[direction](self.field)
		else:
			return False

def start_game(stdscr):
	curses.use_default_colors()
	game_instance = GridGame(win=32)
	state_actions = {} 
	def initialize():
		game_instance.reset()
		return 'Game'

	state_actions['Init'] = initialize

	def not_in_game(state):
		game_instance.render(stdscr)
		action = get_user_input(stdscr)
		responses = defaultdict(lambda: state)
		responses['Restart'], responses['Exit'] = 'Init', 'Exit'
		return responses[action]

	state_actions['Win'] = lambda: not_in_game('Win')
	state_actions['Gameover'] = lambda: not_in_game('Gameover')

	def play_game():
		game_instance.render(stdscr)
		action = get_user_input(stdscr)
		if action == 'Restart':
			return 'Init'
		if action == 'Exit':
			return 'Exit'
		if game_instance.shift(action): 
			if game_instance.check_win():
				return 'Win'
			if game_instance.check_gameover():
				return 'Gameover'
		return 'Game'

	state_actions['Game'] = play_game

	state = 'Init'
	while state != 'Exit':
		state = state_actions[state]()

curses.wrapper(start_game)"
inmof_3_1,inmof,2048,Game Development,Puzzles,python,T3,Added Statements,"import curses
from random import randrange, choice 
from collections import defaultdict

letter_codes = [ord(ch) for ch in 'WASDRQwasdrq']
actions = ['Up', 'Left', 'Down', 'Right', 'Restart', 'Exit']
actions_dict = dict(zip(letter_codes, actions * 2))

def get_user_action(keyboard):    
	char = keyboard.getch()
	while char not in actions_dict:    
		char = keyboard.getch()
	return actions_dict[char]

def transpose(field):
	return [list(row) for row in zip(*field)]

def invert(field):
	return [row[::-1] for row in field]

class GameField(object):
	def __init__(self, height=4, width=4, win=2048):
		self.height = height
		self.width = width
		self.win_value = win
		self.score = 0
		self.highscore = 0
		self.reset()

	def reset(self):
		if self.score > self.highscore:
			self.highscore = self.score
		self.score = 0
		self.field = [[0 for _ in range(self.width)] for _ in range(self.height)]
		self.spawn()
		self.spawn()

	def move(self, direction):
		def move_row_left(row):
			def tighten(row): 
				new_row = [i for i in row if i != 0]
				new_row += [0] * (len(row) - len(new_row))
				return new_row

			def merge(row):
				pair = False
				new_row = []
				for idx in range(len(row)):
					if pair:
						new_row.append(2 * row[idx])
						self.score += 2 * row[idx]
						pair = False
					else:
						if idx + 1 < len(row) and row[idx] == row[idx + 1]:
							pair = True
							new_row.append(0)
						else:
							new_row.append(row[idx])
				assert len(new_row) == len(row)
				return new_row
			return tighten(merge(tighten(row)))

		moves = {
			'Left': lambda field: [move_row_left(row) for row in field],
			'Right': lambda field: invert(moves['Left'](invert(field))),
			'Up': lambda field: transpose(moves['Left'](transpose(field))),
			'Down': lambda field: transpose(moves['Right'](transpose(field)))
		}

		if direction in moves:
			if self.move_is_possible(direction):
				self.field = moves[direction](self.field)
				self.spawn()
				return True
			return False

	def is_win(self):
		return any(i >= self.win_value for row in self.field for i in row)

	def is_gameover(self):
		return not any(self.move_is_possible(move) for move in actions)

	def draw(self, screen):
		help_str1 = '(W)Up (S)Down (A)Left (D)Right'
		help_str2 = '     (R)Restart (Q)Exit'
		gameover_str = '           GAME OVER'
		win_str = '          YOU WIN!'
		
		def cast(string):
			screen.addstr(string + '\n')

		def draw_hor_separator():
			top = '+' + (('-' * 5) * self.width)[1:]
			mid = top
			bot = top
			separator = defaultdict(lambda: mid)
			separator[0], separator[self.height] = top, bot
			if not hasattr(draw_hor_separator, 'counter'):
				draw_hor_separator.counter = 0
			cast(separator[draw_hor_separator.counter])
			draw_hor_separator.counter += 1

		def draw_row(row):
			cast(''.join('{: ^5} '.format(num) if num > 0 else '|      ' for num in row) + '|')

		screen.clear()
		cast('SCORE: ' + str(self.score))
		if self.highscore != 0:
			cast('HIGHSCORE: ' + str(self.highscore))
		for row in self.field:
			draw_hor_separator()
			draw_row(row)
		draw_hor_separator()
		if self.is_win():
			cast(win_str)
		else:
			if self.is_gameover():
				cast(gameover_str)
			else:
				cast(help_str1)
		cast(help_str2)

	def spawn(self):
		new_element = 4 if randrange(100) > 89 else 2
		(i,j) = choice([(i,j) for i in range(self.width) for j in range(self.height) if self.field[j][i] == 0])
		self.field[j][i] = new_element

	def move_is_possible(self, direction):
		def row_is_left_movable(row): 
			def change(i): 
				if row[i] == 0 and row[i + 1] != 0: 
					return True
				if row[i] != 0 and row[i + 1] == row[i]: 
					return True
				return False
			return any(change(i) for i in range(len(row) - 1))

		check = {
			'Left': lambda field: any(row_is_left_movable(row) for row in field),
			'Right': lambda field: check['Left'](invert(field)),
			'Up': lambda field: check['Left'](transpose(field)),
			'Down': lambda field: check['Right'](transpose(field))
		}

		return check[direction](self.field) if direction in check else False

def main(stdscr):
	curses.use_default_colors()
	game_field = GameField(win=32)
	state_actions = {} 
	
	def init():
		game_field.reset()
		return 'Game'

	state_actions['Init'] = init

	def not_game(state):
		game_field.draw(stdscr)
		action = get_user_action(stdscr)
		responses = defaultdict(lambda: state)
		responses['Restart'], responses['Exit'] = 'Init', 'Exit'
		return responses[action]

	state_actions['Win'] = lambda: not_game('Win')
	state_actions['Gameover'] = lambda: not_game('Gameover')

	def game():
		game_field.draw(stdscr)
		action = get_user_action(stdscr)
		if action == 'Restart':
			return 'Init'
		if action == 'Exit':
			return 'Exit'
		if game_field.move(action): 
			if game_field.is_win():
				return 'Win'
			if game_field.is_gameover():
				return 'Gameover'
		return 'Game'

	state_actions['Game'] = game

	state = 'Init'
	while state != 'Exit':
		state = state_actions[state]()

curses.wrapper(main)"
inmof_3_2,inmof,2048,Game Development,Puzzles,python,T3,Removed Statements,"import curses
from random import randrange, choice 
from collections import defaultdict

letter_codes = [ord(ch) for ch in 'WASDRQwasdrq']
actions = ['Up', 'Left', 'Down', 'Right', 'Restart', 'Exit']
actions_dict = dict(zip(letter_codes, actions * 2))

def get_user_action(keyboard):    
	char = keyboard.getch()
	while char not in actions_dict:    
		char = keyboard.getch()
	return actions_dict[char]

def transpose(field):
	return [list(row) for row in zip(*field)]

def invert(field):
	return [row[::-1] for row in field]

class GameField(object):
	def __init__(self, height=4, width=4, win=2048):
		self.height = height
		self.width = width
		self.win_value = win
		self.score = self.highscore = 0
		self.reset()

	def reset(self):
		if self.score > self.highscore:
			self.highscore = self.score
		self.score = 0
		self.field = [[0] * self.width for _ in range(self.height)]
		self.spawn()
		self.spawn()

	def move(self, direction):
		def move_row_left(row):
			def tighten(row): 
				new_row = [i for i in row if i != 0] + [0] * (len(row) - len(new_row))
				return new_row

			def merge(row):
				pair = False
				new_row = []
				for i in range(len(row)):
					if pair:
						new_row.append(2 * row[i])
						self.score += 2 * row[i]
						pair = False
					else:
						if i + 1 < len(row) and row[i] == row[i + 1]:
							pair = True
							new_row.append(0)
						else:
							new_row.append(row[i])
				return new_row
			return tighten(merge(tighten(row)))

		moves = {
			'Left': lambda field: [move_row_left(row) for row in field],
			'Right': lambda field: invert(moves['Left'](invert(field))),
			'Up': lambda field: transpose(moves['Left'](transpose(field))),
			'Down': lambda field: transpose(moves['Right'](transpose(field)))
		}

		if direction in moves and self.move_is_possible(direction):
			self.field = moves[direction](self.field)
			self.spawn()
			return True

	def is_win(self):
		return any(i >= self.win_value for row in self.field for i in row)

	def is_gameover(self):
		return not any(self.move_is_possible(move) for move in actions)

	def draw(self, screen):
		help_string1 = '(W)Up (S)Down (A)Left (D)Right'
		help_string2 = '     (R)Restart (Q)Exit'
		gameover_string = '           GAME OVER'
		win_string = '          YOU WIN!'
		def cast(string):
			screen.addstr(string + '\n')

		def draw_row(row):
			cast(''.join('{: ^5} '.format(num) if num > 0 else '|      ' for num in row))

		screen.clear()
		cast('SCORE: ' + str(self.score))
		if self.highscore != 0:
			cast('HIGHSCORE: ' + str(self.highscore))
		for row in self.field:
			draw_row(row)
		if self.is_win():
			cast(win_string)
		elif self.is_gameover():
			cast(gameover_string)
		else:
			cast(help_string1)
		cast(help_string2)

	def spawn(self):
		new_element = 4 if randrange(100) > 89 else 2
		(i,j) = choice([(i,j) for i in range(self.width) for j in range(self.height) if self.field[i][j] == 0])
		self.field[i][j] = new_element

	def move_is_possible(self, direction):
		def row_is_left_movable(row): 
			return any((row[i] == 0 and row[i + 1] != 0) or (row[i] != 0 and row[i + 1] == row[i]) for i in range(len(row) - 1))

		check = {
			'Left': lambda field: any(row_is_left_movable(row) for row in field),
			'Right': lambda field: check['Left'](invert(field)),
			'Up': lambda field: check['Left'](transpose(field)),
			'Down': lambda field: check['Right'](transpose(field))
		}

		return check.get(direction, lambda field: False)(self.field)

def main(stdscr):
	curses.use_default_colors()
	game_field = GameField(win=32)
	state_actions = {} 
	def init():
		game_field.reset()
		return 'Game'

	state_actions['Init'] = init

	def not_game(state):
		game_field.draw(stdscr)
		action = get_user_action(stdscr)
		responses = {'Restart': 'Init', 'Exit': 'Exit'}
		return responses.get(action, state)

	state_actions['Win'] = lambda: not_game('Win')
	state_actions['Gameover'] = lambda: not_game('Gameover')

	def game():
		game_field.draw(stdscr)
		action = get_user_action(stdscr)
		if action in ['Restart', 'Exit']:
			return {'Restart': 'Init', 'Exit': 'Exit'}[action]
		if game_field.move(action): 
			if game_field.is_win():
				return 'Win'
			if game_field.is_gameover():
				return 'Gameover'
		return 'Game'

	state_actions['Game'] = game

	state = 'Init'
	while state != 'Exit':
		state = state_actions[state]()

curses.wrapper(main)"
inmof_3_3,inmof,2048,Game Development,Puzzles,python,T3,Reordered Statements,"import curses
from random import randrange, choice 
from collections import defaultdict

letter_codes = [ord(ch) for ch in 'WASDRQwasdrq']
actions = ['Up', 'Left', 'Down', 'Right', 'Restart', 'Exit']
actions_dict = dict(zip(letter_codes, actions * 2))

def transpose(field):
	return [list(row) for row in zip(*field)]

def invert(field):
	return [row[::-1] for row in field]

def get_user_action(keyboard):    
	char = keyboard.getch()
	while char not in actions_dict:    
		char = keyboard.getch()
	return actions_dict[char]

class GameField(object):
	def __init__(self, height=4, width=4, win=2048):
		self.height = height
		self.width = width
		self.win_value = win
		self.score = 0
		self.highscore = 0
		self.reset()

	def reset(self):
		if self.score > self.highscore:
			self.highscore = self.score
		self.score = 0
		self.field = [[0 for i in range(self.width)] for j in range(self.height)]
		self.spawn()
		self.spawn()

	def move(self, direction):
		def move_row_left(row):
			def tighten(row): 
				new_row = [i for i in row if i != 0]
				new_row += [0 for i in range(len(row) - len(new_row))]
				return new_row

			def merge(row):
				pair = False
				new_row = []
				for i in range(len(row)):
					if pair:
						new_row.append(2 * row[i])
						self.score += 2 * row[i]
						pair = False
					else:
						if i + 1 < len(row) and row[i] == row[i + 1]:
							pair = True
							new_row.append(0)
						else:
							new_row.append(row[i])
				assert len(new_row) == len(row)
				return new_row
			return tighten(merge(tighten(row)))

		moves = {}
		moves['Left']  = lambda field: [move_row_left(row) for row in field]
		moves['Right'] = lambda field: invert(moves['Left'](invert(field)))
		moves['Up']    = lambda field: transpose(moves['Left'](transpose(field)))
		moves['Down']  = lambda field: transpose(moves['Right'](transpose(field)))

		if direction in moves:
			if self.move_is_possible(direction):
				self.field = moves[direction](self.field)
				self.spawn()
				return True
			else:
				return False

	def is_win(self):
		return any(any(i >= self.win_value for i in row) for row in self.field)

	def is_gameover(self):
		return not any(self.move_is_possible(move) for move in actions)

	def draw(self, screen):
		help_string1 = '(W)Up (S)Down (A)Left (D)Right'
		help_string2 = '     (R)Restart (Q)Exit'
		gameover_string = '           GAME OVER'
		win_string = '          YOU WIN!'
		def cast(string):
			screen.addstr(string + '\n')

		def draw_hor_separator():
			top = '' + ('' * self.width + '')[1:]
			mid = '' + ('' * self.width + '')[1:]
			bot = '' + ('' * self.width + '')[1:]
			separator = defaultdict(lambda: mid)
			separator[0], separator[self.height] = top, bot
			if not hasattr(draw_hor_separator, 'counter'):
				draw_hor_separator.counter = 0
			cast(separator[draw_hor_separator.counter])
			draw_hor_separator.counter += 1

		def draw_row(row):
			cast(''.join('{: ^5} '.format(num) if num > 0 else '|      ' for num in row) + '')

		screen.clear()
		cast('SCORE: ' + str(self.score))
		if 0 != self.highscore:
			cast('HIGHSCORE: ' + str(self.highscore))
		for row in self.field:
			draw_hor_separator()
			draw_row(row)
		draw_hor_separator()
		if self.is_win():
			cast(win_string)
		else:
			if self.is_gameover():
				cast(gameover_string)
			else:
				cast(help_string1)
		cast(help_string2)

	def spawn(self):
		new_element = 4 if randrange(100) > 89 else 2
		(i,j) = choice([(i,j) for i in range(self.width) for j in range(self.height) if self.field[j][i] == 0])
		self.field[j][i] = new_element

	def move_is_possible(self, direction):
		def row_is_left_movable(row): 
			def change(i): 
				if row[i] == 0 and row[i + 1] != 0: 
					return True
				if row[i] != 0 and row[i + 1] == row[i]: 
					return True
				return False
			return any(change(i) for i in range(len(row) - 1))

		check = {}
		check['Left']  = lambda field: any(row_is_left_movable(row) for row in field)
		check['Right'] = lambda field: check['Left'](invert(field))
		check['Up']    = lambda field: check['Left'](transpose(field))
		check['Down']  = lambda field: check['Right'](transpose(field))

		if direction in check:
			return check[direction](self.field)
		else:
			return False

def main(stdscr):
	curses.use_default_colors()
	game_field = GameField(win=32)
	state_actions = {} 
	def init():
		game_field.reset()
		return 'Game'

	state_actions['Init'] = init

	def not_game(state):
		game_field.draw(stdscr)
		action = get_user_action(stdscr)
		responses = defaultdict(lambda: state)
		responses['Restart'], responses['Exit'] = 'Init', 'Exit'
		return responses[action]

	state_actions['Gameover'] = lambda: not_game('Gameover')
	state_actions['Win'] = lambda: not_game('Win')

	def game():
		game_field.draw(stdscr)
		action = get_user_action(stdscr)
		if action == 'Restart':
			return 'Init'
		if action == 'Exit':
			return 'Exit'
		if game_field.move(action): 
			if game_field.is_win():
				return 'Win'
			if game_field.is_gameover():
				return 'Gameover'
		return 'Game'

	state_actions['Game'] = game

	state = 'Init'
	while state != 'Exit':
		state = state_actions[state]()

curses.wrapper(main)"
inmof_3_4,inmof,2048,Game Development,Puzzles,python,T3,Control Flow Modifications,"import curses
from random import randrange, choice 
from collections import defaultdict

letter_codes = [ord(ch) for ch in 'WASDRQwasdrq']
actions = ['Up', 'Left', 'Down', 'Right', 'Restart', 'Exit']
actions_dict = dict(zip(letter_codes, actions * 2))

def get_user_action(keyboard):    
    char = keyboard.getch()
    while char not in actions_dict:    
        char = keyboard.getch()
    return actions_dict[char]

def transpose(field):
    return [list(row) for row in zip(*field)]

def invert(field):
    return [row[::-1] for row in field]

class GameField(object):
    def __init__(self, height=4, width=4, win=2048):
        self.height = height
        self.width = width
        self.win_value = win
        self.score = 0
        self.highscore = 0
        self.reset()

    def reset(self):
        self.highscore = max(self.highscore, self.score)
        self.score = 0
        self.field = [[0] * self.width for _ in range(self.height)]
        self.spawn()
        self.spawn()

    def move(self, direction):
        def move_row_left(row):
            def tighten(row): 
                new_row = [i for i in row if i != 0]
                return new_row + [0] * (len(row) - len(new_row))

            def merge(row):
                new_row = []
                pair = False
                for i in range(len(row)):
                    if pair:
                        new_row.append(2 * row[i])
                        self.score += 2 * row[i]
                        pair = False
                    elif i + 1 < len(row) and row[i] == row[i + 1]:
                        pair = True
                        new_row.append(0)
                    else:
                        new_row.append(row[i])
                return new_row
            return tighten(merge(tighten(row)))

        moves = {
            'Left': lambda field: [move_row_left(row) for row in field],
            'Right': lambda field: invert(moves['Left'](invert(field))),
            'Up': lambda field: transpose(moves['Left'](transpose(field))),
            'Down': lambda field: transpose(moves['Right'](transpose(field)))
        }

        if direction in moves and self.move_is_possible(direction):
            self.field = moves[direction](self.field)
            self.spawn()
            return True
        return False

    def is_win(self):
        return any(i >= self.win_value for row in self.field for i in row)

    def is_gameover(self):
        return not any(self.move_is_possible(move) for move in actions)

    def draw(self, screen):
        help_string1 = '(W)Up (S)Down (A)Left (D)Right'
        help_string2 = '     (R)Restart (Q)Exit'
        gameover_string = '           GAME OVER'
        win_string = '          YOU WIN!'

        def cast(string):
            screen.addstr(string + '\n')

        def draw_hor_separator():
            top = ' ' + ('-' * (self.width * 5 - 1))
            mid = ' ' + ('-' * (self.width * 5 - 1))
            bot = ' ' + ('-' * (self.width * 5 - 1))
            separator = defaultdict(lambda: mid)
            separator[0], separator[self.height] = top, bot
            cast(separator[draw_hor_separator.counter % (self.height + 1)])
            draw_hor_separator.counter += 1

        def draw_row(row):
            cast(''.join('{: ^5} '.format(num) if num > 0 else '|      ' for num in row) + '')

        screen.clear()
        cast('SCORE: ' + str(self.score))
        if self.highscore != 0:
            cast('HIGHSCORE: ' + str(self.highscore))
        for row in self.field:
            draw_hor_separator()
            draw_row(row)
        draw_hor_separator()
        cast(win_string if self.is_win() else (gameover_string if self.is_gameover() else help_string1))
        cast(help_string2)

    def spawn(self):
        new_element = 4 if randrange(100) > 89 else 2
        (i, j) = choice([(i, j) for i in range(self.width) for j in range(self.height) if self.field[i][j] == 0])
        self.field[i][j] = new_element

    def move_is_possible(self, direction):
        def row_is_left_movable(row): 
            return any(row[i] == 0 or (row[i] != 0 and row[i + 1] == row[i]) for i in range(len(row) - 1))

        checks = {
            'Left': lambda field: any(row_is_left_movable(row) for row in field),
            'Right': lambda field: checks['Left'](invert(field)),
            'Up': lambda field: checks['Left'](transpose(field)),
            'Down': lambda field: checks['Right'](transpose(field))
        }

        return checks[direction](self.field) if direction in checks else False

def main(stdscr):
    curses.use_default_colors()
    game_field = GameField(win=32)
    state_actions = {} 

    def init():
        game_field.reset()
        return 'Game'

    state_actions['Init'] = init

    def not_game(state):
        game_field.draw(stdscr)
        action = get_user_action(stdscr)
        responses = defaultdict(lambda: state, {'Restart': 'Init', 'Exit': 'Exit'})
        return responses[action]

    state_actions['Win'] = lambda: not_game('Win')
    state_actions['Gameover'] = lambda: not_game('Gameover')

    def game():
        game_field.draw(stdscr)
        action = get_user_action(stdscr)
        if action == 'Restart':
            return 'Init'
        if action == 'Exit':
            return 'Exit'
        if game_field.move(action): 
            if game_field.is_win():
                return 'Win'
            if game_field.is_gameover():
                return 'Gameover'
        return 'Game'

    state_actions['Game'] = game

    state = 'Init'
    while state != 'Exit':
        state = state_actions[state]()

curses.wrapper(main)"
inmof_4_1,inmof,2048,Game Development,Puzzles,python,T4,Same Language,"import curses
from random import randrange, choice 
from collections import defaultdict

letter_codes = [ord(ch) for ch in 'WASDRQwasdrq']
actions = ['Up', 'Left', 'Down', 'Right', 'Restart', 'Exit']
actions_dict = dict(zip(letter_codes, actions * 2))

def get_user_action(keyboard):    
    char = keyboard.getch()
    while char not in actions_dict:    
        char = keyboard.getch()
    return actions_dict[char]

def transpose(field):
    return [list(row) for row in zip(*field)]

def invert(field):
    return [row[::-1] for row in field]

class GameField:
    def __init__(self, height=4, width=4, win=2048):
        self.height = height
        self.width = width
        self.win_value = win
        self.score = 0
        self.highscore = 0
        self.reset()

    def reset(self):
        if self.score > self.highscore:
            self.highscore = self.score
        self.score = 0
        self.field = [[0] * self.width for _ in range(self.height)]
        self.spawn()
        self.spawn()

    def move(self, direction):
        moves = {
            'Left': lambda field: [self.move_row_left(row) for row in field],
            'Right': lambda field: invert(moves['Left'](invert(field))),
            'Up': lambda field: transpose(moves['Left'](transpose(field))),
            'Down': lambda field: transpose(moves['Right'](transpose(field)))
        }
        if direction in moves and self.move_is_possible(direction):
            self.field = moves[direction](self.field)
            self.spawn()
            return True
        return False

    def move_row_left(self, row):
        row = self.tighten(row)
        row = self.merge(row)
        return self.tighten(row)

    def tighten(self, row):
        new_row = [i for i in row if i != 0]
        new_row += [0] * (len(row) - len(new_row))
        return new_row

    def merge(self, row):
        new_row, pair = [], False
        for i in range(len(row)):
            if pair:
                new_row.append(2 * row[i])
                self.score += 2 * row[i]
                pair = False
            else:
                if i + 1 < len(row) and row[i] == row[i + 1]:
                    pair = True
                    new_row.append(0)
                else:
                    new_row.append(row[i])
        return new_row

    def is_win(self):
        return any(i >= self.win_value for row in self.field for i in row)

    def is_gameover(self):
        return not any(self.move_is_possible(move) for move in actions)

    def draw(self, screen):
        help_string1 = '(W)Up (S)Down (A)Left (D)Right'
        help_string2 = '     (R)Restart (Q)Exit'
        gameover_string = '           GAME OVER'
        win_string = '          YOU WIN!'
        def cast(string):
            screen.addstr(string + '\n')

        def draw_hor_separator():
            separator = [""+"" + ""-"" * 5 + ""+""] * (self.height + 1)
            cast(separator[0])
            for _ in range(self.height):
                cast(separator[1])
        
        def draw_row(row):
            cast(''.join('{: ^5} '.format(num) if num > 0 else '|      ' for num in row))

        screen.clear()
        cast('SCORE: ' + str(self.score))
        if self.highscore:
            cast('HIGHSCORE: ' + str(self.highscore))
        for row in self.field:
            draw_hor_separator()
            draw_row(row)
        draw_hor_separator()
        if self.is_win():
            cast(win_string)
        elif self.is_gameover():
            cast(gameover_string)
        else:
            cast(help_string1)
        cast(help_string2)

    def spawn(self):
        new_element = 4 if randrange(100) > 89 else 2
        empty_positions = [(i, j) for i in range(self.height) for j in range(self.width) if self.field[i][j] == 0]
        i, j = choice(empty_positions)
        self.field[i][j] = new_element

    def move_is_possible(self, direction):
        checks = {
            'Left': lambda: any(self.row_is_left_movable(row) for row in self.field),
            'Right': lambda: checks['Left'](invert(self.field)),
            'Up': lambda: checks['Left'](transpose(self.field)),
            'Down': lambda: checks['Right'](transpose(self.field))
        }
        return checks[direction]() if direction in checks else False

    def row_is_left_movable(self, row):
        return any(row[i] == 0 and row[i + 1] != 0 or row[i] != 0 and row[i] == row[i + 1] for i in range(len(row)-1))

def main(stdscr):
    curses.use_default_colors()
    game_field = GameField(win=32)
    state_actions = {
        'Init': lambda: (game_field.reset(), 'Game')[1],
        'Win': lambda: not_game('Win'),
        'Gameover': lambda: not_game('Gameover'),
        'Game': game
    }
    
    def not_game(state):
        game_field.draw(stdscr)
        action = get_user_action(stdscr)
        responses = defaultdict(lambda: state, {'Restart': 'Init', 'Exit': 'Exit'})
        return responses[action]

    def game():
        game_field.draw(stdscr)
        action = get_user_action(stdscr)
        if action == 'Restart':
            return 'Init'
        if action == 'Exit':
            return 'Exit'
        if game_field.move(action):
            if game_field.is_win():
                return 'Win'
            if game_field.is_gameover():
                return 'Gameover'
        return 'Game'

    state = 'Init'
    while state != 'Exit':
        state = state_actions[state]()

curses.wrapper(main)"
inmof_4_2,inmof,2048,Game Development,Puzzles,go,T4,Different Language,"package main

import (
	""bufio""
	""fmt""
	""log""
	""math/rand""
	""os""
	""os/exec""
	""strconv""
	""strings""
	""text/template""
	""time""
	""unicode""

	""golang.org/x/crypto/ssh/terminal""
)

const maxPoints = 2048
const (
	fieldSizeX = 4
	fieldSizeY = 4
)
const tilesAtStart = 2
const probFor2 = 0.9

type button int

const (
	_ button = iota
	up
	down
	right
	left
	quit
)

var labels = func() map[button]rune {
	m := make(map[button]rune, 4)
	m[up] = 'W'
	m[down] = 'S'
	m[right] = 'D'
	m[left] = 'A'
	return m
}()
var keybinding = func() map[rune]button {
	m := make(map[rune]button, 8)
	for b, r := range labels {
		m[r] = b
		if unicode.IsUpper(r) {
			r = unicode.ToLower(r)
		} else {
			r = unicode.ToUpper(r)
		}
		m[r] = b
	}
	m[0x03] = quit
	return m
}()

var model = struct {
	Score int
	Field [fieldSizeY][fieldSizeX]int
}{}

var view = func() *template.Template {
	maxWidth := 1
	for i := maxPoints; i >= 10; i /= 10 {
		maxWidth++
	}

	w := maxWidth + 3
	r := make([]byte, fieldSizeX*w+1)
	for i := range r {
		if i%w == 0 {
			r[i] = '+'
		} else {
			r[i] = '-'
		}
	}
	rawBorder := string(r)

	v, err := template.New("""").Parse(`SCORE: {{.Score}}
{{range .Field}}
` + rawBorder + `
|{{range .}} {{if .}}{{printf ""%` + strconv.Itoa(maxWidth) + `d"" .}}{{else}}` +
		strings.Repeat("" "", maxWidth) + `{{end}} |{{end}}{{end}}
` + rawBorder + `

(` + string(labels[up]) + `)Up (` +
		string(labels[down]) + `)Down (` +
		string(labels[left]) + `)Left (` +
		string(labels[right]) + `)Right
`)
	check(err)
	return v
}()

func check(err error) {
	if err != nil {
		log.Panicln(err)
	}
}

func clear() {
	c := exec.Command(""clear"")
	c.Stdout = os.Stdout
	check(c.Run())
}

func draw() {
	clear()
	check(view.Execute(os.Stdout, model))
}

func addRandTile() (full bool) {
	free := make([]*int, 0, fieldSizeX*fieldSizeY)

	for x := 0; x < fieldSizeX; x++ {
		for y := 0; y < fieldSizeY; y++ {
			if model.Field[y][x] == 0 {
				free = append(free, &model.Field[y][x])
			}
		}
	}

	val := 4
	if rand.Float64() < probFor2 {
		val = 2
	}
	*free[rand.Intn(len(free))] = val

	return len(free) == 1
}

type point struct{ x, y int }

func (p point) get() int      { return model.Field[p.y][p.x] }
func (p point) set(n int)     { model.Field[p.y][p.x] = n }
func (p point) inField() bool { return p.x >= 0 && p.y >= 0 && p.x < fieldSizeX && p.y < fieldSizeY }
func (p *point) next(n point) { p.x += n.x; p.y += n.y }

func controller(key rune) (gameOver bool) {
	b := keybinding[key]

	if b == 0 {
		return false
	}
	if b == quit {
		return true
	}

	var starts []point
	var next point

	switch b {
	case up:
		next = point{0, 1}
		starts = make([]point, fieldSizeX)
		for x := 0; x < fieldSizeX; x++ {
			starts[x] = point{x, 0}
		}
	case down:
		next = point{0, -1}
		starts = make([]point, fieldSizeX)
		for x := 0; x < fieldSizeX; x++ {
			starts[x] = point{x, fieldSizeY - 1}
		}
	case right:
		next = point{-1, 0}
		starts = make([]point, fieldSizeY)
		for y := 0; y < fieldSizeY; y++ {
			starts[y] = point{fieldSizeX - 1, y}
		}
	case left:
		next = point{1, 0}
		starts = make([]point, fieldSizeY)
		for y := 0; y < fieldSizeY; y++ {
			starts[y] = point{0, y}
		}
	}

	moved := false
	winning := false

	for _, s := range starts {
		n := s
		move := func(set int) {
			moved = true
			s.set(set)
			n.set(0)
		}
		for n.next(next); n.inField(); n.next(next) {
			if s.get() != 0 {
				if n.get() == s.get() {
					score := s.get() * 2
					model.Score += score
					winning = score >= maxPoints

					move(score)
					s.next(next)
				} else if n.get() != 0 {
					s.next(next)
					if s.get() == 0 {
						move(n.get())
					}
				}
			} else if n.get() != 0 {
				move(n.get())
			}
		}
	}

	if !moved {
		return false
	}

	lost := false
	if addRandTile() {
		lost = true
	Out:
		for x := 0; x < fieldSizeX; x++ {
			for y := 0; y < fieldSizeY; y++ {
				if (y > 0 && model.Field[y][x] == model.Field[y-1][x]) ||
					(x > 0 && model.Field[y][x] == model.Field[y][x-1]) {
					lost = false
					break Out
				}
			}
		}
	}

	draw()

	if winning {
		fmt.Println(""You win!"")
		return true
	}
	if lost {
		fmt.Println(""Game Over"")
		return true
	}

	return false
}

func main() {
	oldState, err := terminal.MakeRaw(0)
	check(err)
	defer terminal.Restore(0, oldState)

	rand.Seed(time.Now().Unix())

	for i := tilesAtStart; i > 0; i-- {
		addRandTile()
	}
	draw()

	stdin := bufio.NewReader(os.Stdin)

	readKey := func() rune {
		r, _, err := stdin.ReadRune()
		check(err)
		return r
	}

	for !controller(readKey()) {
	}
}"
inmof_4_2,inmof,2048,Game Development,Puzzles,java,T4,Different Language,"import java.awt.*;
import java.awt.event.*;
import java.util.Random;
import javax.swing.*;

public class Game2048 extends JPanel {

    enum State {
        start, won, running, over
    }

    final Color[] colorTable = {
        new Color(0x701710), new Color(0xFFE4C3), new Color(0xfff4d3),
        new Color(0xffdac3), new Color(0xe7b08e), new Color(0xe7bf8e),
        new Color(0xffc4c3), new Color(0xE7948e), new Color(0xbe7e56),
        new Color(0xbe5e56), new Color(0x9c3931), new Color(0x701710)};

    final static int target = 2048;

    static int highest;
    static int score;

    private Color gridColor = new Color(0xBBADA0);
    private Color emptyColor = new Color(0xCDC1B4);
    private Color startColor = new Color(0xFFEBCD);

    private Random rand = new Random();

    private Tile[][] tiles;
    private int side = 4;
    private State gamestate = State.start;
    private boolean checkingAvailableMoves;

    public Game2048() {
        setPreferredSize(new Dimension(900, 700));
        setBackground(new Color(0xFAF8EF));
        setFont(new Font(""SansSerif"", Font.BOLD, 48));
        setFocusable(true);

        addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                startGame();
                repaint();
            }
        });

        addKeyListener(new KeyAdapter() {
            @Override
            public void keyPressed(KeyEvent e) {
                switch (e.getKeyCode()) {
                    case KeyEvent.VK_UP:
                        moveUp();
                        break;
                    case KeyEvent.VK_DOWN:
                        moveDown();
                        break;
                    case KeyEvent.VK_LEFT:
                        moveLeft();
                        break;
                    case KeyEvent.VK_RIGHT:
                        moveRight();
                        break;
                }
                repaint();
            }
        });
    }

    @Override
    public void paintComponent(Graphics gg) {
        super.paintComponent(gg);
        Graphics2D g = (Graphics2D) gg;
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
                RenderingHints.VALUE_ANTIALIAS_ON);

        drawGrid(g);
    }

    void startGame() {
        if (gamestate != State.running) {
            score = 0;
            highest = 0;
            gamestate = State.running;
            tiles = new Tile[side][side];
            addRandomTile();
            addRandomTile();
        }
    }

    void drawGrid(Graphics2D g) {
        g.setColor(gridColor);
        g.fillRoundRect(200, 100, 499, 499, 15, 15);

        if (gamestate == State.running) {

            for (int r = 0; r < side; r++) {
                for (int c = 0; c < side; c++) {
                    if (tiles[r][c] == null) {
                        g.setColor(emptyColor);
                        g.fillRoundRect(215 + c * 121, 115 + r * 121, 106, 106, 7, 7);
                    } else {
                        drawTile(g, r, c);
                    }
                }
            }
        } else {
            g.setColor(startColor);
            g.fillRoundRect(215, 115, 469, 469, 7, 7);

            g.setColor(gridColor.darker());
            g.setFont(new Font(""SansSerif"", Font.BOLD, 128));
            g.drawString(""2048"", 310, 270);

            g.setFont(new Font(""SansSerif"", Font.BOLD, 20));

            if (gamestate == State.won) {
                g.drawString(""you made it!"", 390, 350);

            } else if (gamestate == State.over)
                g.drawString(""game over"", 400, 350);

            g.setColor(gridColor);
            g.drawString(""click to start a new game"", 330, 470);
            g.drawString(""(use arrow keys to move tiles)"", 310, 530);
        }
    }

    void drawTile(Graphics2D g, int r, int c) {
        int value = tiles[r][c].getValue();

        g.setColor(colorTable[(int) (Math.log(value) / Math.log(2)) + 1]);
        g.fillRoundRect(215 + c * 121, 115 + r * 121, 106, 106, 7, 7);
        String s = String.valueOf(value);

        g.setColor(value < 128 ? colorTable[0] : colorTable[1]);

        FontMetrics fm = g.getFontMetrics();
        int asc = fm.getAscent();
        int dec = fm.getDescent();

        int x = 215 + c * 121 + (106 - fm.stringWidth(s)) / 2;
        int y = 115 + r * 121 + (asc + (106 - (asc + dec)) / 2);

        g.drawString(s, x, y);
    }


    private void addRandomTile() {
        int pos = rand.nextInt(side * side);
        int row, col;
        do {
            pos = (pos + 1) % (side * side);
            row = pos / side;
            col = pos % side;
        } while (tiles[row][col] != null);

        int val = rand.nextInt(10) == 0 ? 4 : 2;
        tiles[row][col] = new Tile(val);
    }

    private boolean move(int countDownFrom, int yIncr, int xIncr) {
        boolean moved = false;

        for (int i = 0; i < side * side; i++) {
            int j = Math.abs(countDownFrom - i);

            int r = j / side;
            int c = j % side;

            if (tiles[r][c] == null)
                continue;

            int nextR = r + yIncr;
            int nextC = c + xIncr;

            while (nextR >= 0 && nextR < side && nextC >= 0 && nextC < side) {

                Tile next = tiles[nextR][nextC];
                Tile curr = tiles[r][c];

                if (next == null) {

                    if (checkingAvailableMoves)
                        return true;

                    tiles[nextR][nextC] = curr;
                    tiles[r][c] = null;
                    r = nextR;
                    c = nextC;
                    nextR += yIncr;
                    nextC += xIncr;
                    moved = true;

                } else if (next.canMergeWith(curr)) {

                    if (checkingAvailableMoves)
                        return true;

                    int value = next.mergeWith(curr);
                    if (value > highest)
                        highest = value;
                    score += value;
                    tiles[r][c] = null;
                    moved = true;
                    break;
                } else
                    break;
            }
        }

        if (moved) {
            if (highest < target) {
                clearMerged();
                addRandomTile();
                if (!movesAvailable()) {
                    gamestate = State.over;
                }
            } else if (highest == target)
                gamestate = State.won;
        }

        return moved;
    }

    boolean moveUp() {
        return move(0, -1, 0);
    }

    boolean moveDown() {
        return move(side * side - 1, 1, 0);
    }

    boolean moveLeft() {
        return move(0, 0, -1);
    }

    boolean moveRight() {
        return move(side * side - 1, 0, 1);
    }

    void clearMerged() {
        for (Tile[] row : tiles)
            for (Tile tile : row)
                if (tile != null)
                    tile.setMerged(false);
    }

    boolean movesAvailable() {
        checkingAvailableMoves = true;
        boolean hasMoves = moveUp() || moveDown() || moveLeft() || moveRight();
        checkingAvailableMoves = false;
        return hasMoves;
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            JFrame f = new JFrame();
            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            f.setTitle(""2048"");
            f.setResizable(true);
            f.add(new Game2048(), BorderLayout.CENTER);
            f.pack();
            f.setLocationRelativeTo(null);
            f.setVisible(true);
        });
    }
}

class Tile {
    private boolean merged;
    private int value;

    Tile(int val) {
        value = val;
    }

    int getValue() {
        return value;
    }

    void setMerged(boolean m) {
        merged = m;
    }

    boolean canMergeWith(Tile other) {
        return !merged && other != null && !other.merged && value == other.getValue();
    }

    int mergeWith(Tile other) {
        if (canMergeWith(other)) {
            value *= 2;
            merged = true;
            return value;
        }
        return -1;
    }
}"
inmof_4_2,inmof,2048,Game Development,Puzzles,javascript,T4,Different Language,"function Tile(pos, val, puzzle){
	this.pos     = pos;
	this.val     = val;
	this.puzzle  = puzzle;
	this.merging = false;

	this.getCol = () => Math.round(this.pos % 4);
	this.getRow = () => Math.floor(this.pos / 4);

	

	this.show = function(){
		let padding = this.merging ? 0 : 5;
		let size = 0.25*width;
		noStroke();
		colorMode(HSB, 255);
		fill(10*(11 - Math.log2(this.val)), 50 + 15*Math.log2(this.val), 200);
		rect(this.getCol()*size + padding, this.getRow()*size + padding, size - 2*padding, size - 2*padding);
		fill(255);
		textSize(0.1*width);
		textAlign(CENTER, CENTER);
		text(this.val, (this.getCol() + 0.5)*size, (this.getRow() + 0.5)*size);
	}

	

	this.move = function(dir){
		let col = this.getCol() + (1 - 2*(dir < 0))*Math.abs(dir)%4;
		let row = this.getRow() + (1 - 2*(dir < 0))*Math.floor(Math.abs(dir)/4);
		let target = this.puzzle.getTile(this.pos + dir);

		if (col < 0 || col > 3 || row < 0 || row > 3) {
			
			return false;
		} else if (target){
			
			if(this.merging || target.merging || target.val !== this.val)
				return false;

			 
			target.val += this.val;
			target.merging = true;
			this.puzzle.score += target.val;
			this.puzzle.removeTile(this);
			return true;
		}

		
		this.pos += dir;
		return true;
	}
}



function Puzzle(){
	this.tiles    = [];
	this.dir      = 0;
	this.score    = 0;
	this.hasMoved = false;
	this.validPositions = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];

	this.getOpenPositions = () => this.validPositions.filter(i => this.tiles.map(x => x.pos).indexOf(i) === -1);
	this.getTile          = pos => this.tiles.filter(x => x.pos === pos)[0];
	this.removeTile       = tile => this.tiles.splice(this.tiles.indexOf(tile), 1);
	this.winCondition     = () => this.tiles.some(x => x.val === 2048);

	

	this.validMoves = function(){
		
		if(this.tiles.length < 16)
			return true;

		
		let res = false;
		this.tiles.sort((x,y) => x.pos - y.pos);
		for(let i = 0; i < 16; i++)
			res = res || ( (i%4 < 3) ? this.tiles[i].val === this.tiles[i+1].val : false )
					  || ( (i  < 12) ? this.tiles[i].val === this.tiles[i+4].val : false );
		return res;
	}

	

	this.checkGameState = function(){
		if(this.winCondition()){
			alert('You win!');
		} else if (!this.validMoves()){
			alert('You Lose!');
			this.restart();
		}
	}

	this.restart = function(){
		this.tiles    = [];
		this.dir      = 0;
		this.score    = 0;
		this.hasMoved = false;
		this.generateTile();
		this.generateTile();
	}

	

	this.show = function(){
		background(200);
		fill(255);
		textSize(0.05*width);
		textAlign(CENTER, TOP);
		text(""SCORE: "" + this.score, 0.5*width, width);

		for(let tile of this.tiles)
			tile.show();
	}

	

	this.animate = function(){
		if(this.dir === 0)
			return;

		
		let moving = false;
		this.tiles.sort((x,y) => this.dir*(y.pos - x.pos));
		for(let tile of this.tiles)
			moving = moving || tile.move(this.dir);

		
		if(this.hasMoved && !moving){
			this.dir = 0;
			this.generateTile();

			for(let tile of this.tiles)
				tile.merging = false;
		} 
		this.hasMoved = moving;
	}

	this.generateTile = function(){
		let positions = this.getOpenPositions();
		let pos       = positions[Math.floor(Math.random()*positions.length)];
		let val       = 2 + 2*Math.floor(Math.random()*1.11);
		this.tiles.push(new Tile(pos, val, this));
	}
	this.generateTile();
	this.generateTile();

	

	this.keyHandler = function(key){
		if      (key === UP_ARROW)    this.dir = -4
		else if (key === DOWN_ARROW)  this.dir = 4
		else if (key === RIGHT_ARROW) this.dir = 1
		else if (key === LEFT_ARROW)  this.dir = -1;
	}
}


let game;

function setup() {
	createCanvas(400, 420);	
	game = new Puzzle();
}



function draw() {
	game.checkGameState();
	game.animate();
	game.show();
}

function keyPressed(){
	game.keyHandler(keyCode);
}"
inmof_4_2,inmof,2048,Game Development,Puzzles,php,T4,Different Language,"<?php

$game = new Game();

while(true) {
    $game->cycle();
}

class Game {
	private $field;
	private $fieldSize;
	private $command;
	private $error;
	private $lastIndexX, $lastIndexY;
	private $score;
	private $finishScore;

	function __construct() {
		$this->field = array();
		$this->fieldSize = 4;
		$this->finishScore = 2048;
		$this->score = 0;
		$this->addNumber();
		$this->render();
	}

	public function cycle() {
		$this->command = strtolower($this->readchar('Use WASD, q exits'));
		$this->cls();

		if($this->processCommand()) {
			$this->addNumber();
		} else {
			if(count($this->getFreeList()) == 0 ) {
				$this->error = 'No options left!, You Lose!!';
			} else {
				$this->error = 'Invalid move, try again!';
			}
		}
		$this->render();
	}

	private function readchar($prompt) {
		readline_callback_handler_install($prompt, function() {});
		$char = stream_get_contents(STDIN, 1);
		readline_callback_handler_remove();
		return $char;
	}

	
	private function addNumber() {
		$freeList = $this->getFreeList();
		if(count($freeList) == 0) {
			return;
		}
		$index = mt_rand(0, count($freeList)-1);
		$nr = (mt_rand(0,9) == 0)? 4 : 2;
		$this->field[$freeList[$index]['x']][$freeList[$index]['y']] = $nr;
		return;
	}

	
	private function getFreeList() {
		$freeList = array();
		for($y =0; $y< $this->fieldSize;$y++) {
			for($x=0; $x < $this->fieldSize; $x++) {
				if(!isset($this->field[$x][$y])) {
					$freeList[] = array('x' => $x, 'y' => $y);
				} elseif($this->field[$x][$y] == $this->finishScore) {
					$this->error = 'You Win!!';
				}
			}
		}
		return $freeList;
	}

	
	private function processCommand() {
		if(!in_array($this->command, array('w','a','s','d','q'))) {
			$this->error = 'Invalid Command';
			return false;
		}
		if($this->command == 'q') {
			echo PHP_EOL. 'Bye!'. PHP_EOL;
			exit;
		}

		
		$axis = 'x';
		$sDir = 1;

		switch($this->command) {
			case 'w':
				$axis = 'y';
				$sDir = -1;
				break;
			case 'a':
				$sDir = -1;
				break;
			case 's':
				$axis = 'y';
				break;
			case 'd':
			break;
		}

		$done = 0;
		
		$done += $this->shift($axis, $sDir);
		
		$done += $this->merge($axis, $sDir * -1);
		
		$done += $this->shift($axis, $sDir);
		return $done >0;
	}

	private function shift($axis, $dir) {
		$totalDone = 0;
		for($i = 0; $i <$this->fieldSize; $i++) {
			$done = 0;
			foreach($this->iterate($axis,$dir) as $xy) {
				if($xy['vDest'] === NULL && $xy['vSrc'] !== NULL) {
					$this->field[$xy['dX']][$xy['dY']] = $xy['vSrc'];
					$this->field[$xy['sX']][$xy['sY']] = NULL;
					$done++;
				}
			}
			$totalDone += $done;
			if($done == 0) {
				
				break;
			}
		}
		return $totalDone;
	}

	private function merge($axis, $dir) {
		$done = 0;
		foreach($this->iterate($axis,$dir) as $xy) {
			if($xy['vDest'] !== NULL && $xy['vDest'] === $xy['vSrc']) {
				$this->field[$xy['sX']][$xy['sY']] += $xy['vDest'];
				$this->field[$xy['dX']][$xy['dY']] = NULL;
				$this->score += $this->field[$xy['sX']][$xy['sY']];
				$done ++;
			}
		}
		return $done;
	}

	
	private function iterate($axis, $dir) {
		$res = array();
		for($y = 0; $y < $this->fieldSize; $y++) {
			for($x=0; $x < $this->fieldSize; $x++) {
				$item = array('sX'=> $x,'sY' => $y, 'dX' => $x, 'dY' => $y, 'vDest' => NULL,'vSrc' => NULL);

				if($axis == 'x') {
					$item['dX'] += $dir;
				} else {
					$item['dY'] += $dir;
				}

				if($item['dX'] >= $this->fieldSize || $item['dY'] >=$this->fieldSize || $item['dX'] < 0 || $item['dY'] < 0) {
					continue;
				}

				$item['vDest'] = (isset($this->field[$item['dX']][$item['dY']]))? $this->field[$item['dX']][$item['dY']] : NULL;
				$item['vSrc'] = (isset($this->field[$item['sX']][$item['sY']]))? $this->field[$item['sX']][$item['sY']] : NULL;
				$res[] = $item;
			}
		}
		if($dir < 0) {
			$res = array_reverse($res);
		}
		return $res;
	}

	

	
	private function cls() {
		echo chr(27).chr(91).'H'.chr(27).chr(91).'J';
	}

	private function render() {
		echo $this->finishScore . '! Current score: '. $this->score .PHP_EOL;

		if(!empty($this->error)) {
			echo $this->error . PHP_EOL;
			$this->error = NULL;
		}
		$this->renderField();
	}

	private function renderField() {
		$width = 5;
		$this->renderVSeperator($width);
		for($y =0; $y < $this->fieldSize; $y ++) {
			for($x = 0;$x < $this->fieldSize; $x++) {
				echo '|';
				if(!isset($this->field[$x][$y])) {
					echo str_repeat(' ', $width);
					continue;
				}
				printf('%'.$width.'s', $this->field[$x][$y]);
			}
			echo '|'. PHP_EOL;
			$this->renderVSeperator($width);
		}
	}

	private function renderVSeperator($width) {
		echo str_repeat('+'. str_repeat('-', $width), $this->fieldSize) .'+' .PHP_EOL;
	}

}"
inmof_4_2,inmof,2048,Game Development,Puzzles,ruby,T4,Different Language,"require 'io/console'

class Board
  def initialize size=4, win_limit=2048, cell_width = 6
    @size = size; @cw = cell_width; @win_limit = win_limit
    @board = Array.new(size) {Array.new(size, 0)}
    @moved = true; @score = 0; @no_more_moves = false
    spawn
  end

  def draw
    print  if @r_vert
    print '    ' if @r_hori
    print '' + (['' * @cw] * @size).join('')  + ''
    @board.each do |row|
      print 
      formated = row.map {|num| num == 0? ' ' * @cw: format(num)}
      print '    ' if @r_hori
      puts '' + formated.join('') + ''
      print '    ' if @r_hori
      print '' + ([' '  * @cw] * @size).join('') + ''
    end
    print 
    print '    ' if @r_hori
    puts '' + (['' * @cw] * @size).join('')  + ''
  end

  def move direction
    case direction
    when :up
      @board = column_map {|c| logic(c)}
      @r_vert = false if $rumble
    when :down
      @board = column_map {|c| logic(c.reverse).reverse} 
      @r_vert = true if $rumble
    when :left 
      @board = row_map {|r| logic(r)}
      @r_hori = false if $rumble
    when :right
      @board = row_map {|r| logic(r.reverse).reverse} 
      @r_hori = true if $rumble
    end
    spawn
    @moved = false
  end

  def print_score
    puts 
    puts  if to_enum.any? {|e| e >= @win_limit}
  end

  def no_more_moves?; @no_more_moves; end
  def won?;  to_enum.any? {|e| e >= @win_limit}; end
  def reset!; initialize @size, @win_limit, @cw; end

  private

  def set x, y, val
    @board[y][x] = val
  end

  def spawn 
    free_pos = to_enum.select{|elem,x,y| elem == 0}.map{|_,x,y| [x,y]}
    unless free_pos.empty?
      set *free_pos.sample, rand > 0.1? 2: 4 if @moved
    else
      snap = @board
      unless @stop
        @stop = true
        %i{up down left right}.each{|s| move(s)}
        @no_more_moves = true if snap.flatten == @board.flatten
        @board = snap
        @stop = false
      end
    end
  end

  def logic list
    jump = false
    result =
    list.reduce([]) do |res, val|
      if res.last == val &&!jump
	res[-1] += val
	@score += val
        jump = true
      elsif val!= 0
	res.push val
        jump = false
      end
      res
    end
    result += [0] * (@size - result.length)
    @moved ||= list!= result
    result
  end

  def column_map
    xboard = @board.transpose
    xboard.map!{|c| yield c }
    xboard.transpose
  end

  def row_map
    @board.map {|r| yield r }
  end

  def to_enum
    @enum ||= Enumerator.new(@size * @size) do |yielder|
      (@size*@size).times do |i|
	yielder.yield (@board[i / @size][i % @size]), (i % @size), (i / @size )
      end
    end
    @enum.rewind
  end

  def format(num)
    if $color
      cstart =  + $colors[Math.log(num, 2)] + 
      cend = 
    else
      cstart = cend = 
    end
    cstart + num.to_s.center(@cw) + cend
  end
end

$color = true
$colors = %W{0 1;97 1;93 1;92 1;96 1;91 1;95 1;94 1;30;47 1;43 1;42
1;46 1;41 1;45 1;44 1;33;43 1;33;42 1;33;41 1;33;44}
$rumble = false

$check_score = true
unless ARGV.empty?
  puts ; exit if %W[-h --help].include?(ARGV[0])
  args = ARGV.map(&:to_i).reject{|n| n == 0}
  b = Board.new(*args) unless args.empty?
  $rumble = true if ARGV.any?{|a| a =~ /rumble/i }
  $color = false if ARGV.any?{|a| a =~ /no.?color/i}
end

b ||= Board.new
puts 
b.draw
puts 
loop do
  input = STDIN.getch
  if input ==  
    2.times {input << STDIN.getch}
  end

  case input
  when ,  then b.move(:up)
  when ,  then b.move(:down)
  when ,  then b.move(:right)
  when ,  then b.move(:left)

  when ,,  then b.print_score; exit

  when  
    puts <<-EOM.gsub(/^\s*/, '')
                                                                                        
      Use the arrow-keys or WASD on your keyboard to push board in the given direction.   
      Tiles with the same number merge into one.                                          
      Get a tile with a value of 
      In case you cannot move or merge any tiles anymore, you loose.                      
      You can start this game with different settings by providing commandline argument:  
      For instance:                                                                       
        %> 
                                                                                        
      PRESS q TO QUIT (or Ctrl-C or Ctrl-D)
    EOM
    input = STDIN.getch
  end

  puts 
  b.draw

  if b.no_more_moves? or $check_score && b.won?
    b.print_score
    if b.no_more_moves?
      puts 
      puts 
      exit if STDIN.gets.chomp.downcase == 
      $check_score = true
      b.reset!
      puts 
      b.draw
    else
      puts 
      exit if STDIN.gets.chomp.downcase == 
      $check_score = false
      puts 
      b.draw
    end
  end
end"
