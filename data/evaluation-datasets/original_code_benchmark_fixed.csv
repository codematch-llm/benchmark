base_code_id,language,task,domain,subdomain,code
p3fd,python,100 doors,Puzzles and Games,Logic and Mathematical Puzzles," 
doors = [False] * 100
for i in range(100):
   for j in range(i, 100, i+1):
       doors[j] = not doors[j]
   print(""Door %d:"" % (i+1), 'open' if doors[i] else 'close')
 "
tcob,python,100 prisoners,Puzzles and Games,Logic and Mathematical Puzzles,"import random
 
def play_random(n):
    # using 0-99 instead of ranges 1-100
    pardoned = 0
    in_drawer = list(range(100))
    sampler = list(range(100))
    for _round in range(n):
        random.shuffle(in_drawer)
        found = False
        for prisoner in range(100):
            found = False
            for reveal in random.sample(sampler, 50):
                card = in_drawer[reveal]
                if card == prisoner:
                    found = True
                    break
            if not found:
                break
        if found:
            pardoned += 1
    return pardoned / n * 100   # %
 
def play_optimal(n):
    # using 0-99 instead of ranges 1-100
    pardoned = 0
    in_drawer = list(range(100))
    for _round in range(n):
        random.shuffle(in_drawer)
        for prisoner in range(100):
            reveal = prisoner
            found = False
            for go in range(50):
                card = in_drawer[reveal]
                if card == prisoner:
                    found = True
                    break
                reveal = card
            if not found:
                break
        if found:
            pardoned += 1
    return pardoned / n * 100   # %
 
if __name__ == '__main__':
    n = 100_000
    print("" Simulation count:"", n)
    print(f"" Random play wins: {play_random(n):4.1f}% of simulations"")
    print(f""Optimal play wins: {play_optimal(n):4.1f}% of simulations"")"
hjrd,python,15 puzzle game,Puzzles and Games,Game Development," 
''' Structural Game for 15 - Puzzle with different difficulty levels'''
from random import randint
 
 
class Puzzle:
    def __init__(self):
        self.items = {}
        self.position = None
 
    def main_frame(self):
        d = self.items
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|' % (d[1], d[2], d[3], d[4]))
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|' % (d[5], d[6], d[7], d[8]))
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|' % (d[9], d[10], d[11], d[12]))
        print('+-----+-----+-----+-----+')
        print('|%s|%s|%s|%s|' % (d[13], d[14], d[15], d[16]))
        print('+-----+-----+-----+-----+')
 
    def format(self, ch):
        ch = ch.strip()
        if len(ch) == 1:
            return '  ' + ch + '  '
        elif len(ch) == 2:
            return '  ' + ch + ' '
        elif len(ch) == 0:
            return '     '
 
    def change(self, to):
        fro = self.position
        for a, b in self.items.items():
            if b == self.format(str(to)):
                to = a
                break
        self.items[fro], self.items[to] = self.items[to], self.items[fro]
        self.position = to
 
    def build_board(self, difficulty):
        for i in range(1, 17):
            self.items[i] = self.format(str(i))
        tmp = 0
        for a, b in self.items.items():
            if b == '  16 ':
                self.items[a] = '     '
                tmp = a
                break
        self.position = tmp
        if difficulty == 0:
            diff = 10
        elif difficulty == 1:
            diff = 50
        else:
            diff = 100
        for _ in range(diff):
            lst = self.valid_moves()
            lst1 = []
            for j in lst:
                lst1.append(int(j.strip()))
            self.change(lst1[randint(0, len(lst1)-1)])
 
    def valid_moves(self):
        pos = self.position
        if pos in [6, 7, 10, 11]:
            return self.items[pos - 4], self.items[pos - 1],\
                   self.items[pos + 1], self.items[pos + 4]
        elif pos in [5, 9]:
            return self.items[pos - 4], self.items[pos + 4],\
                   self.items[pos + 1]
        elif pos in [8, 12]:
            return self.items[pos - 4], self.items[pos + 4],\
                   self.items[pos - 1]
        elif pos in [2, 3]:
            return self.items[pos - 1], self.items[pos + 1], self.items[pos + 4]
        elif pos in [14, 15]:
            return self.items[pos - 1], self.items[pos + 1],\
                  self.items[pos - 4]
        elif pos == 1:
            return self.items[pos + 1], self.items[pos + 4]
        elif pos == 4:
            return self.items[pos - 1], self.items[pos + 4]
        elif pos == 13:
            return self.items[pos + 1], self.items[pos - 4]
        elif pos == 16:
            return self.items[pos - 1], self.items[pos - 4]
 
    def game_over(self):
        flag = False
        for a, b in self.items.items():
            if b == '     ':
                pass
            else:
                if a == int(b.strip()):
                    flag = True
                else:
                    flag = False
        return flag
 
 
g = Puzzle()
g.build_board(int(input('Enter the difficulty : 0 1 2\n2 '
                        '=> highest 0=> lowest\n')))
g.main_frame()
print('Enter 0 to exit')
while True:
    print('Hello user:\nTo change the position just enter the no. near it')
    lst = g.valid_moves()
    lst1 = []
    for i in lst:
        lst1.append(int(i.strip()))
        print(i.strip(), '\t', end='')
    print()
    x = int(input())
    if x == 0:
        break
    elif x not in lst1:
        print('Wrong move')
    else:
        g.change(x)
    g.main_frame()
    if g.game_over():
        print('You WON')
        break
 "
r7fi,python,2048,Puzzles and Games,Game Development,"#!/usr/bin/env python3
 
import curses
from random import randrange, choice # generate and place new tile
from collections import defaultdict
 
letter_codes = [ord(ch) for ch in 'WASDRQwasdrq']
actions = ['Up', 'Left', 'Down', 'Right', 'Restart', 'Exit']
actions_dict = dict(zip(letter_codes, actions * 2))
 
def get_user_action(keyboard):    
	char = ""N""
	while char not in actions_dict:    
		char = keyboard.getch()
	return actions_dict[char]
 
def transpose(field):
	return [list(row) for row in zip(*field)]
 
def invert(field):
	return [row[::-1] for row in field]
 
class GameField(object):
	def __init__(self, height=4, width=4, win=2048):
		self.height = height
		self.width = width
		self.win_value = win
		self.score = 0
		self.highscore = 0
		self.reset()
 
	def reset(self):
		if self.score > self.highscore:
			self.highscore = self.score
		self.score = 0
		self.field = [[0 for i in range(self.width)] for j in range(self.height)]
		self.spawn()
		self.spawn()
 
	def move(self, direction):
		def move_row_left(row):
			def tighten(row): # squeese non-zero elements together
				new_row = [i for i in row if i != 0]
				new_row += [0 for i in range(len(row) - len(new_row))]
				return new_row
 
			def merge(row):
				pair = False
				new_row = []
				for i in range(len(row)):
					if pair:
						new_row.append(2 * row[i])
						self.score += 2 * row[i]
						pair = False
					else:
						if i + 1 < len(row) and row[i] == row[i + 1]:
							pair = True
							new_row.append(0)
						else:
							new_row.append(row[i])
				assert len(new_row) == len(row)
				return new_row
			return tighten(merge(tighten(row)))
 
		moves = {}
		moves['Left']  = lambda field:								\
				[move_row_left(row) for row in field]
		moves['Right'] = lambda field:								\
				invert(moves['Left'](invert(field)))
		moves['Up']    = lambda field:								\
				transpose(moves['Left'](transpose(field)))
		moves['Down']  = lambda field:								\
				transpose(moves['Right'](transpose(field)))
 
		if direction in moves:
			if self.move_is_possible(direction):
				self.field = moves[direction](self.field)
				self.spawn()
				return True
			else:
				return False
 
	def is_win(self):
		return any(any(i >= self.win_value for i in row) for row in self.field)
 
	def is_gameover(self):
		return not any(self.move_is_possible(move) for move in actions)
 
	def draw(self, screen):
		help_string1 = '(W)Up (S)Down (A)Left (D)Right'
		help_string2 = '     (R)Restart (Q)Exit'
		gameover_string = '           GAME OVER'
		win_string = '          YOU WIN!'
		def cast(string):
			screen.addstr(string + '\n')
 
		def draw_hor_separator():
			top = '┌' + ('┬──────' * self.width + '┐')[1:]
			mid = '├' + ('┼──────' * self.width + '┤')[1:]
			bot = '└' + ('┴──────' * self.width + '┘')[1:]
			separator = defaultdict(lambda: mid)
			separator[0], separator[self.height] = top, bot
			if not hasattr(draw_hor_separator, ""counter""):
				draw_hor_separator.counter = 0
			cast(separator[draw_hor_separator.counter])
			draw_hor_separator.counter += 1
 
		def draw_row(row):
			cast(''.join('│{: ^5} '.format(num) if num > 0 else '|      ' for num in row) + '│')
 
		screen.clear()
		cast('SCORE: ' + str(self.score))
		if 0 != self.highscore:
			cast('HIGHSCORE: ' + str(self.highscore))
		for row in self.field:
			draw_hor_separator()
			draw_row(row)
		draw_hor_separator()
		if self.is_win():
			cast(win_string)
		else:
			if self.is_gameover():
				cast(gameover_string)
			else:
				cast(help_string1)
		cast(help_string2)
 
	def spawn(self):
		new_element = 4 if randrange(100) > 89 else 2
		(i,j) = choice([(i,j) for i in range(self.width) for j in range(self.height) if self.field[i][j] == 0])
		self.field[i][j] = new_element
 
	def move_is_possible(self, direction):
		def row_is_left_movable(row): 
			def change(i): # true if there'll be change in i-th tile
				if row[i] == 0 and row[i + 1] != 0: # Move
					return True
				if row[i] != 0 and row[i + 1] == row[i]: # Merge
					return True
				return False
			return any(change(i) for i in range(len(row) - 1))
 
		check = {}
		check['Left']  = lambda field:								\
				any(row_is_left_movable(row) for row in field)
 
		check['Right'] = lambda field:								\
				 check['Left'](invert(field))
 
		check['Up']    = lambda field:								\
				check['Left'](transpose(field))
 
		check['Down']  = lambda field:								\
				check['Right'](transpose(field))
 
		if direction in check:
			return check[direction](self.field)
		else:
			return False
 
def main(stdscr):
	curses.use_default_colors()
	game_field = GameField(win=32)
	state_actions = {} # Init, Game, Win, Gameover, Exit
	def init():
		game_field.reset()
		return 'Game'
 
	state_actions['Init'] = init
 
	def not_game(state):
		game_field.draw(stdscr)
		action = get_user_action(stdscr)
		responses = defaultdict(lambda: state)
		responses['Restart'], responses['Exit'] = 'Init', 'Exit'
		return responses[action]
 
	state_actions['Win'] = lambda: not_game('Win')
	state_actions['Gameover'] = lambda: not_game('Gameover')
 
	def game():
		game_field.draw(stdscr)
		action = get_user_action(stdscr)
		if action == 'Restart':
			return 'Init'
		if action == 'Exit':
			return 'Exit'
		if game_field.move(action): # move successful
			if game_field.is_win():
				return 'Win'
			if game_field.is_gameover():
				return 'Gameover'
		return 'Game'
 
	state_actions['Game'] = game
 
	state = 'Init'
	while state != 'Exit':
		state = state_actions[state]()
 
curses.wrapper(main)
 "
969e,python,21 game,Puzzles and Games,Game Development," 
from random import randint
def start():
	game_count=0
	print(""Enter q to quit at any time.\nThe computer will choose first.\nRunning total is now {}"".format(game_count))
	roundno=1
	while game_count<21:
		print(""\nROUND {}: \n"".format(roundno))
		t = select_count(game_count)
		game_count = game_count+t
		print(""Running total is now {}\n"".format(game_count))
		if game_count>=21:
			print(""So, commiserations, the computer has won!"")
			return 0
		t = request_count()
		if not t:
			print('OK,quitting the game')
			return -1
		game_count = game_count+t
		print(""Running total is now {}\n"".format(game_count))
		if game_count>=21:
			print(""So, congratulations, you've won!"")
			return 1
		roundno+=1
 
def select_count(game_count):
	'''selects a random number if the game_count is less than 18. otherwise chooses the winning number'''
	if game_count<18:
		t= randint(1,3)
	else:
		t = 21-game_count
	print(""The computer chooses {}"".format(t))
	return t
 
def request_count():
	'''request user input between 1,2 and 3. It will continue till either quit(q) or one of those numbers is requested.'''
	t=""""
	while True:
		try:
			t = raw_input('Your choice 1 to 3 :')
			if int(t) in [1,2,3]:
				return int(t)
			else:
				print(""Out of range, try again"")
		except:
			if t==""q"":
				return None
			else:
				print(""Invalid Entry, try again"")
 
c=0
m=0
r=True
while r:
	o = start()
	if o==-1:
		break
	else:
		c+=1 if o==0 else 0
		m+=1 if o==1 else 0
	print(""Computer wins {0} game, human wins {1} games"".format(c,m))
	t = raw_input(""Another game?(press y to continue):"")
	r = (t==""y"")"
eyn3,python,24 game,Puzzles and Games,Logic and Mathematical Puzzles,"'''
 The 24 Game
 
 Given any four digits in the range 1 to 9, which may have repetitions,
 Using just the +, -, *, and / operators; and the possible use of
 brackets, (), show how to make an answer of 24.
 
 An answer of ""q"" will quit the game.
 An answer of ""!"" will generate a new set of four digits.
 Otherwise you are repeatedly asked for an expression until it evaluates to 24
 
 Note: you cannot form multiple digit numbers from the supplied digits,
 so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.
 
'''
 
from __future__ import division, print_function
import random, ast, re
import sys
 
if sys.version_info[0] < 3: input = raw_input
 
def choose4():
    'four random digits >0 as characters'
    return [str(random.randint(1,9)) for i in range(4)]
 
def welcome(digits):
    print (__doc__)
    print (""Your four digits: "" + ' '.join(digits))
 
def check(answer, digits):
    allowed = set('() +-*/\t'+''.join(digits))
    ok = all(ch in allowed for ch in answer) and \
         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \
         and not re.search('\d\d', answer)
    if ok:
        try:
            ast.parse(answer)
        except:
            ok = False
    return ok
 
def main():    
    digits = choose4()
    welcome(digits)
    trial = 0
    answer = ''
    chk = ans = False
    while not (chk and ans == 24):
        trial +=1
        answer = input(""Expression %i: "" % trial)
        chk = check(answer, digits)
        if answer.lower() == 'q':
            break
        if answer == '!':
            digits = choose4()
            print (""New digits:"", ' '.join(digits))
            continue
        if not chk:
            print (""The input '%s' was wonky!"" % answer)
        else:
            ans = eval(answer)
            print ("" = "", ans)
            if ans == 24:
                print (""Thats right!"")
    print (""Thank you and goodbye"")   
 
if __name__ == '__main__': main() "
3pht,python,24 game/Solve,Puzzles and Games,Puzzle Solving Algorithms,"'''
 The 24 Game Player
 
 Given any four digits in the range 1 to 9, which may have repetitions,
 Using just the +, -, *, and / operators; and the possible use of
 brackets, (), show how to make an answer of 24.
 
 An answer of ""q""  will quit the game.
 An answer of ""!""  will generate a new set of four digits.
 An answer of ""!!"" will ask you for a new set of four digits.
 An answer of ""?""  will compute an expression for the current digits.
 
 Otherwise you are repeatedly asked for an expression until it evaluates to 24
 
 Note: you cannot form multiple digit numbers from the supplied digits,
 so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.
 
'''
 
from   __future__ import division, print_function
from   itertools  import permutations, combinations, product, \
                         chain
from   pprint     import pprint as pp
from   fractions  import Fraction as F
import random, ast, re
import sys
 
if sys.version_info[0] < 3:
    input = raw_input
    from itertools import izip_longest as zip_longest
else:
    from itertools import zip_longest
 
 
def choose4():
    'four random digits >0 as characters'
    return [str(random.randint(1,9)) for i in range(4)]
 
def ask4():
    'get four random digits >0 from the player'
    digits = ''
    while len(digits) != 4 or not all(d in '123456789' for d in digits):
        digits = input('Enter the digits to solve for: ')
        digits = ''.join(digits.strip().split())
    return list(digits)
 
def welcome(digits):
    print (__doc__)
    print (""Your four digits: "" + ' '.join(digits))
 
def check(answer, digits):
    allowed = set('() +-*/\t'+''.join(digits))
    ok = all(ch in allowed for ch in answer) and \
         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \
         and not re.search('\d\d', answer)
    if ok:
        try:
            ast.parse(answer)
        except:
            ok = False
    return ok
 
def solve(digits):
    """"""\
    >>> for digits in '3246 4788 1111 123456 1127 3838'.split():
            solve(list(digits))
 
 
    Solution found: 2 + 3 * 6 + 4
    '2 + 3 * 6 + 4'
    Solution found: ( 4 + 7 - 8 ) * 8
    '( 4 + 7 - 8 ) * 8'
    No solution found for: 1 1 1 1
    '!'
    Solution found: 1 + 2 + 3 * ( 4 + 5 ) - 6
    '1 + 2 + 3 * ( 4 + 5 ) - 6'
    Solution found: ( 1 + 2 ) * ( 1 + 7 )
    '( 1 + 2 ) * ( 1 + 7 )'
    Solution found: 8 / ( 3 - 8 / 3 )
    '8 / ( 3 - 8 / 3 )'
    >>> """"""
    digilen = len(digits)
    # length of an exp without brackets 
    exprlen = 2 * digilen - 1
    # permute all the digits
    digiperm = sorted(set(permutations(digits)))
    # All the possible operator combinations
    opcomb   = list(product('+-*/', repeat=digilen-1))
    # All the bracket insertion points:
    brackets = ( [()] + [(x,y)
                         for x in range(0, exprlen, 2)
                         for y in range(x+4, exprlen+2, 2)
                         if (x,y) != (0,exprlen+1)]
                 + [(0, 3+1, 4+2, 7+3)] ) # double brackets case
    for d in digiperm:
        for ops in opcomb:
            if '/' in ops:
                d2 = [('F(%s)' % i) for i in d] # Use Fractions for accuracy
            else:
                d2 = d
            ex = list(chain.from_iterable(zip_longest(d2, ops, fillvalue='')))
            for b in brackets:
                exp = ex[::]
                for insertpoint, bracket in zip(b, '()'*(len(b)//2)):
                    exp.insert(insertpoint, bracket)
                txt = ''.join(exp)
                try:
                    num = eval(txt)
                except ZeroDivisionError:
                    continue
                if num == 24:
                    if '/' in ops:
                        exp = [ (term if not term.startswith('F(') else term[2])
                               for term in exp ]
                    ans = ' '.join(exp).rstrip()
                    print (""Solution found:"",ans)
                    return ans
    print (""No solution found for:"", ' '.join(digits))            
    return '!'
 
def main():    
    digits = choose4()
    welcome(digits)
    trial = 0
    answer = ''
    chk = ans = False
    while not (chk and ans == 24):
        trial +=1
        answer = input(""Expression %i: "" % trial)
        chk = check(answer, digits)
        if answer == '?':
            solve(digits)
            answer = '!'
        if answer.lower() == 'q':
            break
        if answer == '!':
            digits = choose4()
            trial = 0
            print (""\nNew digits:"", ' '.join(digits))
            continue
        if answer == '!!':
            digits = ask4()
            trial = 0
            print (""\nNew digits:"", ' '.join(digits))
            continue
        if not chk:
            print (""The input '%s' was wonky!"" % answer)
        else:
            if '/' in answer:
                # Use Fractions for accuracy in divisions
                answer = ''.join( (('F(%s)' % char) if char in '123456789' else char)
                                  for char in answer )
            ans = eval(answer)
            print ("" = "", ans)
            if ans == 24:
                print (""Thats right!"")
    print (""Thank you and goodbye"")   
 
main()"
3iey,python,4-rings or 4-squares puzzle,Puzzles and Games,Logic and Mathematical Puzzles,"import itertools
 
def all_equal(a,b,c,d,e,f,g):
    return a+b == b+c+d == d+e+f == f+g
 
def foursquares(lo,hi,unique,show):
    solutions = 0
    if unique:
        uorn = ""unique""
        citer = itertools.combinations(range(lo,hi+1),7)
    else:
        uorn = ""non-unique""
        citer =  itertools.combinations_with_replacement(range(lo,hi+1),7)
 
    for c in citer:
            for p in set(itertools.permutations(c)):
                if all_equal(*p):
                    solutions += 1
                    if show:
                        print str(p)[1:-1]
 
    print str(solutions)+"" ""+uorn+"" solutions in ""+str(lo)+"" to ""+str(hi)
    print"
6m44,python,9 billion names of God the integer,Puzzles and Games,Logic and Mathematical Puzzles,"cache = [[1]]
def cumu(n):
    for l in range(len(cache), n+1):
        r = [0]
        for x in range(1, l+1):
            r.append(r[-1] + cache[l-x][min(x, l-x)])
        cache.append(r)
    return cache[n]
 
def row(n):
    r = cumu(n)
    return [r[i+1] - r[i] for i in range(n)]
 
print ""rows:""
for x in range(1, 11): print ""%2d:""%x, row(x)
 
 
print ""\nsums:""
for x in [23, 123, 1234, 12345]: print x, cumu(x)[-1]"
xzti,python,A+B,Puzzles and Games,Logic and Mathematical Puzzles,"try: raw_input
except: raw_input = input
 
print(sum(map(int, raw_input().split())))"
5asq,python,ABC problem,Puzzles and Games,Logic and Mathematical Puzzles," 
'''
Note that this code is broken, e.g., it won't work when 
blocks = [(""A"", ""B""), (""A"",""C"")] and the word is ""AB"", where the answer
should be True, but the code returns False.
'''
blocks = [(""B"", ""O""),
          (""X"", ""K""),
          (""D"", ""Q""),
          (""C"", ""P""),
          (""N"", ""A""),
          (""G"", ""T""),
          (""R"", ""E""),
          (""T"", ""G""),
          (""Q"", ""D""),
          (""F"", ""S""),
          (""J"", ""W""),
          (""H"", ""U""),
          (""V"", ""I""),
          (""A"", ""N""),
          (""O"", ""B""),
          (""E"", ""R""),
          (""F"", ""S""),
          (""L"", ""Y""),
          (""P"", ""C""),
          (""Z"", ""M"")]
 
 
def can_make_word(word, block_collection=blocks):
    """"""
    Return True if `word` can be made from the blocks in `block_collection`.
 
    >>> can_make_word("""")
    False
    >>> can_make_word(""a"")
    True
    >>> can_make_word(""bark"")
    True
    >>> can_make_word(""book"")
    False
    >>> can_make_word(""treat"")
    True
    >>> can_make_word(""common"")
    False
    >>> can_make_word(""squad"")
    True
    >>> can_make_word(""coNFused"")
    True
    """"""
    if not word:
        return False
 
    blocks_remaining = block_collection[:]
    for char in word.upper():
        for block in blocks_remaining:
            if char in block:
                blocks_remaining.remove(block)
                break
        else:
            return False
    return True
 
 
if __name__ == ""__main__"":
    import doctest
    doctest.testmod()
    print("", "".join(""'%s': %s"" % (w, can_make_word(w)) for w in
                    ["""", ""a"", ""baRk"", ""booK"", ""treat"", 
                     ""COMMON"", ""squad"", ""Confused""]))
 "
gweq,python,AKS test for primes,Mathematics,Number Theory,"def expand_x_1(n): 
# This version uses a generator and thus less computations
    c =1
    for i in range(n//2+1):
        c = c*(n-i)//(i+1)
        yield c
 
def aks(p):
    if p==2:
        return True
 
    for i in expand_x_1(p):
        if i % p:
# we stop without computing all possible solutions
            return False
    return True"
41u1,python,ASCII art diagram converter,Puzzles and Games,Puzzle Solving Algorithms," 
""""""
http://rosettacode.org/wiki/ASCII_art_diagram_converter
 
Python example based off Go example:
 
http://rosettacode.org/wiki/ASCII_art_diagram_converter#Go
 
""""""
 
def validate(diagram):
 
    # trim empty lines
 
    rawlines = diagram.splitlines()
    lines = []
    for line in rawlines:
        if line != '':
            lines.append(line)
 
    # validate non-empty lines
 
    if len(lines) == 0:
        print('diagram has no non-empty lines!')
        return None
 
    width = len(lines[0])
    cols = (width - 1) // 3
 
    if cols not in [8, 16, 32, 64]: 
        print('number of columns should be 8, 16, 32 or 64')
        return None
 
    if len(lines)%2 == 0:
        print('number of non-empty lines should be odd')
        return None
 
    if lines[0] != (('+--' * cols)+'+'):
            print('incorrect header line')
            return None
 
    for i in range(len(lines)):
        line=lines[i]
        if i == 0:
            continue
        elif i%2 == 0:
            if line != lines[0]:
                print('incorrect separator line')
                return None
        elif len(line) != width:
            print('inconsistent line widths')
            return None
        elif line[0] != '|' or line[width-1] != '|':
            print(""non-separator lines must begin and end with '|'"")    
            return None
 
    return lines
 
""""""
 
results is list of lists like:
 
[[name, bits, start, end],...
 
""""""
 
def decode(lines):
    print(""Name     Bits  Start  End"")
    print(""=======  ====  =====  ==="")
 
    startbit = 0
 
    results = []
 
    for line in lines:
        infield=False
        for c in line:
            if not infield and c == '|':
                infield = True
                spaces = 0
                name = ''
            elif infield:
                if c == ' ':
                    spaces += 1
                elif c != '|':
                    name += c
                else:
                    bits = (spaces + len(name) + 1) // 3
                    endbit = startbit + bits - 1
                    print('{0:7}    {1:2d}     {2:2d}   {3:2d}'.format(name, bits, startbit, endbit))
                    reslist = [name, bits, startbit, endbit]
                    results.append(reslist)
                    spaces = 0
                    name = ''
                    startbit += bits
 
    return results
 
def unpack(results, hex):
    print(""\nTest string in hex:"")
    print(hex)
    print(""\nTest string in binary:"")
    bin = f'{int(hex, 16):0>{4*len(hex)}b}'
    print(bin)
    print(""\nUnpacked:\n"")
    print(""Name     Size  Bit pattern"")
    print(""=======  ====  ================"")
    for r in results:
        name = r[0]
        size = r[1]
        startbit = r[2]
        endbit = r[3]
        bitpattern = bin[startbit:endbit+1]
        print('{0:7}    {1:2d}  {2:16}'.format(name, size, bitpattern))
 
 
diagram = """"""
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                      ID                       |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    QDCOUNT                    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    ANCOUNT                    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    NSCOUNT                    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|                    ARCOUNT                    |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
 
""""""
 
lines = validate(diagram)
 
if lines == None:
    print(""No lines returned"")
else:
    print("" "")
    print(""Diagram after trimming whitespace and removal of blank lines:"")
    print("" "")
    for line in lines:
        print(line)
 
    print("" "")
    print(""Decoded:"")
    print("" "")
 
    results = decode(lines)    
 
    # test string
 
    hex = ""78477bbf5496e12e1bf169a4"" 
 
    unpack(results, hex)
 "
nuaj,python,"Abbreviations, automatic",Text Processing,String Manipulation,"def shortest_abbreviation_length(line, list_size):
    words = line.split()
    word_count = len(words)
    # Can't give true answer with unexpected number of entries
    if word_count != list_size:
        raise ValueError(f'Not enough entries, expected {list_size} found {word_count}')
 
    # Find the small slice length that gives list_size unique values
    abbreviation_length = 1
    abbreviations = set()
    while(True):
        abbreviations = {word[:abbreviation_length] for word in words}
        if len(abbreviations) == list_size:
            return abbreviation_length
        abbreviation_length += 1
        abbreviations.clear()
 
def automatic_abbreviations(filename, words_per_line):
    with open(filename) as file:
        for line in file:
            line = line.rstrip()
            if len(line) > 0:
                length = shortest_abbreviation_length(line, words_per_line)
                print(f'{length:2} {line}')
            else:
                print()
 
automatic_abbreviations('daysOfWeek.txt', 7)"
6mvc,python,"Abbreviations, easy",Text Processing,String Manipulation,"command_table_text = \
""""""Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy
COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find
NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput
Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO
MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT
READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT
RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer Type Up""""""
 
user_words = ""riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin""
 
def find_abbreviations_length(command_table_text):
    """""" find the minimal abbreviation length for each word by counting capital letters.
        a word that does not have capital letters gets it's full length as the minimum.
    """"""
    command_table = dict()
    for word in command_table_text.split():
        abbr_len = sum(1 for c in word if c.isupper())
        if abbr_len == 0:
            abbr_len = len(word)
        command_table[word] = abbr_len
    return command_table
 
def find_abbreviations(command_table):
    """""" for each command insert all possible abbreviations""""""
    abbreviations = dict()
    for command, min_abbr_len in command_table.items():
        for l in range(min_abbr_len, len(command)+1):
            abbr = command[:l].lower()
            abbreviations[abbr] = command.upper()
    return abbreviations
 
def parse_user_string(user_string, abbreviations):
    user_words = [word.lower() for word in user_string.split()]
    commands = [abbreviations.get(user_word, ""*error*"") for user_word in user_words]
    return "" "".join(commands)
 
command_table = find_abbreviations_length(command_table_text)
abbreviations_table = find_abbreviations(command_table)
 
full_words = parse_user_string(user_words, abbreviations_table)
 
print(""user words:"", user_words)
print(""full words:"", full_words)"
bpet,python,"Abbreviations, simple",Text Processing,String Manipulation," 
 
command_table_text = """"""add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3
   compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate
   3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2
   forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load
   locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2
   msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3
   refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left
   2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1""""""
 
user_words = ""riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin""
 
 
def find_abbreviations_length(command_table_text):
    """""" find the minimal abbreviation length for each word.
        a word that does not have minimum abbreviation length specified
        gets it's full lengths as the minimum.
    """"""
    command_table = dict()
    input_iter = iter(command_table_text.split())
 
    word = None
    try:
        while True:
            if word is None:
                word = next(input_iter)
            abbr_len = next(input_iter, len(word))
            try:
                command_table[word] = int(abbr_len)
                word = None
            except ValueError:
                command_table[word] = len(word)
                word = abbr_len
    except StopIteration:
        pass
    return command_table
 
 
def find_abbreviations(command_table):
    """""" for each command insert all possible abbreviations""""""
    abbreviations = dict()
    for command, min_abbr_len in command_table.items():
        for l in range(min_abbr_len, len(command)+1):
            abbr = command[:l].lower()
            abbreviations[abbr] = command.upper()
    return abbreviations
 
 
def parse_user_string(user_string, abbreviations):
    user_words = [word.lower() for word in user_string.split()]
    commands = [abbreviations.get(user_word, ""*error*"") for user_word in user_words]
    return "" "".join(commands)
 
 
command_table = find_abbreviations_length(command_table_text)
abbreviations_table = find_abbreviations(command_table)
 
full_words = parse_user_string(user_words, abbreviations_table)
 
print(""user words:"", user_words)
print(""full words:"", full_words)
 "
p29c,python,Abelian sandpile model,Puzzles and Games,Simulation and Modeling,"import numpy as np
import matplotlib.pyplot as plt
 
 
def iterate(grid):
    changed = False
    for ii, arr in enumerate(grid):
        for jj, val in enumerate(arr):
            if val > 3:
                grid[ii, jj] -= 4
                if ii > 0:
                    grid[ii - 1, jj] += 1
                if ii < len(grid)-1:
                    grid[ii + 1, jj] += 1
                if jj > 0:
                    grid[ii, jj - 1] += 1
                if jj < len(grid)-1:
                    grid[ii, jj + 1] += 1
                changed = True
    return grid, changed
 
 
def simulate(grid):
    while True:
        grid, changed = iterate(grid)
        if not changed:
            return grid
 
 
if __name__ == '__main__':
    start_grid = np.zeros((10, 10))
    start_grid[4:5, 4:5] = 64
    final_grid = simulate(start_grid.copy())
    plt.figure()
    plt.gray()
    plt.imshow(start_grid)
    plt.figure()
    plt.gray()
    plt.imshow(final_grid)"
auz6,python,Abelian sandpile model/Identity,Puzzles and Games,Logic and Mathematical Puzzles,"from itertools import product
from collections import defaultdict
 
 
class Sandpile():
    def __init__(self, gridtext):
        array = [int(x) for x in gridtext.strip().split()]
        self.grid = defaultdict(int,
                                {(i //3, i % 3): x 
                                 for i, x in enumerate(array)})
 
    _border = set((r, c) 
                  for r, c in product(range(-1, 4), repeat=2) 
                  if not 0 <= r <= 2 or not 0 <= c <= 2
                  )
    _cell_coords = list(product(range(3), repeat=2))
 
    def topple(self):
        g = self.grid
        for r, c in self._cell_coords:
            if g[(r, c)] >= 4:
                g[(r - 1, c)] += 1
                g[(r + 1, c)] += 1
                g[(r, c - 1)] += 1
                g[(r, c + 1)] += 1
                g[(r, c)] -= 4
                return True
        return False
 
    def stabilise(self):
        while self.topple():
            pass
        # Remove extraneous grid border
        g = self.grid
        for row_col in self._border.intersection(g.keys()):
            del g[row_col]
        return self
 
    __pos__ = stabilise     # +s == s.stabilise()
 
    def __eq__(self, other):
        g = self.grid
        return all(g[row_col] == other.grid[row_col]
                   for row_col in self._cell_coords)
 
    def __add__(self, other):
        g = self.grid
        ans = Sandpile("""")
        for row_col in self._cell_coords:
            ans.grid[row_col] = g[row_col] + other.grid[row_col]
        return ans.stabilise()
 
    def __str__(self):
        g, txt = self.grid, []
        for row in range(3):
            txt.append(' '.join(str(g[(row, col)]) 
                                for col in range(3)))
        return '\n'.join(txt)
 
    def __repr__(self):
        return f'{self.__class__.__name__}(""""""""\n{self.__str__()}"""""")'
 
 
unstable = Sandpile(""""""
4 3 3
3 1 2
0 2 3"""""")
s1 = Sandpile(""""""
    1 2 0
    2 1 1
    0 1 3
"""""")
s2 = Sandpile(""""""
    2 1 3
    1 0 1
    0 1 0 
"""""")
s3 = Sandpile(""3 3 3  3 3 3  3 3 3"")
s3_id = Sandpile(""2 1 2  1 0 1  2 1 2"")
 "
heh4,python,Abstract type,Programming Concepts,Advanced Concepts,"class BaseQueue(object):
    """"""Abstract/Virtual Class 
    """"""
    def __init__(self):
        self.contents = list()
        raise NotImplementedError
    def Enqueue(self, item):
        raise NotImplementedError
    def Dequeue(self):
        raise NotImplementedError
    def Print_Contents(self):
        for i in self.contents:
            print i,"
dprd,python,Abundant odd numbers,Mathematics,Number Theory,"#!/usr/bin/python
# Abundant odd numbers - Python
 
oddNumber  = 1
aCount  = 0
dSum  = 0
 
from math import sqrt
 
def divisorSum(n):
    sum = 1
    i = int(sqrt(n)+1)
 
    for d in range (2, i):
        if n % d == 0:
            sum += d
            otherD = n // d
            if otherD != d:
                sum += otherD
    return sum
 
print (""The first 25 abundant odd numbers:"")
while aCount  < 25:
    dSum  = divisorSum(oddNumber )
    if dSum  > oddNumber :
        aCount  += 1
        print(""{0:5} proper divisor sum: {1}"". format(oddNumber ,dSum ))
    oddNumber  += 2
 
while aCount  < 1000:
    dSum  = divisorSum(oddNumber )
    if dSum  > oddNumber :
        aCount  += 1
    oddNumber  += 2
print (""\n1000th abundant odd number:"")
print (""    "",(oddNumber - 2),"" proper divisor sum: "",dSum)
 
oddNumber  = 1000000001
found  = False
while not found :
    dSum  = divisorSum(oddNumber )
    if dSum  > oddNumber :
        found  = True
        print (""\nFirst abundant odd number > 1 000 000 000:"")
        print (""    "",oddNumber,"" proper divisor sum: "",dSum)
    oddNumber  += 2"
48ib,python,"Abundant, deficient and perfect number classifications",Mathematics,Number Theory,">>> from proper_divisors import proper_divs
>>> from collections import Counter
>>> 
>>> rangemax = 20000
>>> 
>>> def pdsum(n):
...     return sum(proper_divs(n))
... 
>>> def classify(n, p):
...     return 'perfect' if n == p else 'abundant' if p > n else 'deficient'
... 
>>> classes = Counter(classify(n, pdsum(n)) for n in range(1, 1 + rangemax))
>>> classes.most_common()
[('deficient', 15043), ('abundant', 4953), ('perfect', 4)]
>>> "
5oc8,python,Accumulator factory,Programming Concepts,Advanced Concepts,">>> def accumulator(sum):
  def f(n):
    f.sum += n
    return f.sum
  f.sum = sum
  return f
 
>>> x = accumulator(1)
>>> x(5)
6
>>> x(2.3)
8.3000000000000007
>>> x = accumulator(1)
>>> x(5)
6
>>> x(2.3)
8.3000000000000007
>>> x2 = accumulator(3)
>>> x2(5)
8
>>> x2(3.3)
11.300000000000001
>>> x(0)
8.3000000000000007
>>> x2(0)
11.300000000000001"
mze9,python,Ackermann function,Algorithms and Data Structures,Algorithms,"def ack1(M, N):
   return (N + 1) if M == 0 else (
      ack1(M-1, 1) if N == 0 else ack1(M-1, ack1(M, N-1)))"
z5ze,python,Active Directory/Connect,Networking and Web Development,Networking,"import ldap
 
l = ldap.initialize(""ldap://ldap.example.com"")
try:
    l.protocol_version = ldap.VERSION3
    l.set_option(ldap.OPT_REFERRALS, 0)
 
    bind = l.simple_bind_s(""me@example.com"", ""password"")
finally:
    l.unbind()
 "
bvp0,python,Active Directory/Search for a user,Networking and Web Development,Networking,"import ldap
 
l = ldap.initialize(""ldap://ldap.example.com"")
try:
    l.protocol_version = ldap.VERSION3
    l.set_option(ldap.OPT_REFERRALS, 0)
 
    bind = l.simple_bind_s(""me@example.com"", ""password"")
 
    base = ""dc=example, dc=com""
    criteria = ""(&(objectClass=user)(sAMAccountName=username))""
    attributes = ['displayName', 'company']
    result = l.search_s(base, ldap.SCOPE_SUBTREE, criteria, attributes)
 
    results = [entry for dn, entry in result if isinstance(entry, dict)]
    print results
finally:
    l.unbind()
 "
c5gw,python,Active object,Concurrency and Parallelism,Multithreading and Thread Management,"from time import time, sleep
from threading import Thread
 
class Integrator(Thread):
    'continuously integrate a function `K`, at each `interval` seconds'
    def __init__(self, K=lambda t:0, interval=1e-4):
        Thread.__init__(self)
        self.interval  = interval
        self.K   = K
        self.S   = 0.0
        self.__run = True
        self.start()
 
    def run(self):
        ""entry point for the thread""
        interval = self.interval
        start = time()
        t0, k0 = 0, self.K(0)
        while self.__run:
            sleep(interval)
            t1 = time() - start
            k1 = self.K(t1)
            self.S += (k1 + k0)*(t1 - t0)/2.0
            t0, k0 = t1, k1
 
    def join(self):
        self.__run = False
        Thread.join(self)
 
if __name__ == ""__main__"":
    from math import sin, pi
 
    ai = Integrator(lambda t: sin(pi*t))
    sleep(2)
    print(ai.S)
    ai.K = lambda t: 0
    sleep(0.5)
    print(ai.S)"
8xla,python,Add a variable to a class instance at runtime,Programming Concepts,Advanced Concepts,"class empty(object):
    pass
e = empty()"
worp,python,Additive primes,Mathematics,Number Theory,"def is_prime(n: int) -> bool:
    if n <= 3:
        return n > 1
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i ** 2 <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True
 
def digit_sum(n: int) -> int:
    sum = 0
    while n > 0:
        sum += n % 10
        n //= 10
    return sum
 
def main() -> None:
    additive_primes = 0
    for i in range(2, 500):
        if is_prime(i) and is_prime(digit_sum(i)):
            additive_primes += 1
            print(i, end="" "")
    print(f""\nFound {additive_primes} additive primes less than 500"")
 
if __name__ == ""__main__"":
    main()"
q2s4,python,Address of a variable,Programming Concepts,Fundamentals,"foo = object()  # Create (instantiate) an empty object
address = id(foo)"
2wy8,python,Algebraic data types,Algorithms and Data Structures,Algorithms,"from __future__ import annotations
from enum import Enum
from typing import NamedTuple
from typing import Optional
 
 
class Color(Enum):
    B = 0
    R = 1
 
 
class Tree(NamedTuple):
    color: Color
    left: Optional[Tree]
    value: int
    right: Optional[Tree]
 
    def insert(self, val: int) -> Tree:
        return self._insert(val).make_black()
 
    def _insert(self, val: int) -> Tree:
        match compare(val, self.value):
            case _ if self == EMPTY:
                return Tree(Color.R, EMPTY, val, EMPTY)
            case -1:
                assert self.left is not None
                return Tree(
                    self.color, self.left._insert(val), self.value, self.right
                ).balance()
            case 1:
                assert self.right is not None
                return Tree(
                    self.color, self.left, self.value, self.right._insert(val)
                ).balance()
            case _:
                return self
 
    def balance(self) -> Tree:
        match self:
            case (Color.B, (Color.R, (Color.R, a, x, b), y, c), z, d):
                return Tree(Color.R, Tree(Color.B, a, x, b), y, Tree(Color.B, c, z, d))
            case (Color.B, (Color.R, a, x, (Color.R, b, y, c)), z, d):
                return Tree(Color.R, Tree(Color.B, a, x, b), y, Tree(Color.B, c, z, d))
            case (Color.B, a, x, (Color.R, (Color.R, b, y, c), z, d)):
                return Tree(Color.R, Tree(Color.B, a, x, b), y, Tree(Color.B, c, z, d))
            case (Color.B, a, x, (Color.R, b, y, (Color.R, c, z, d))):
                return Tree(Color.R, Tree(Color.B, a, x, b), y, Tree(Color.B, c, z, d))
            case _:
                return self
 
    def make_black(self) -> Tree:
        return self._replace(color=Color.B)
 
    def __str__(self) -> str:
        if self == EMPTY:
            return ""[]""
        return f""[{'R' if self.color == Color.R else 'B'}{self.value}]""
 
    def print(self, indent: int = 0) -> None:
        if self != EMPTY:
            assert self.right is not None
            self.right.print(indent + 1)
 
        print(f""{' ' * indent * 4}{self}"")
 
        if self != EMPTY:
            assert self.left is not None
            self.left.print(indent + 1)
 
 
EMPTY = Tree(Color.B, None, 0, None)
 
 
def compare(x: int, y: int) -> int:
    if x > y:
        return 1
    if x < y:
        return -1
    return 0
 
 
def main():
    tree = EMPTY
    for i in range(1, 17):
        tree = tree.insert(i)
    tree.print()
 
 
if __name__ == ""__main__"":
    main()
 "
wb7a,python,Align columns,Text Processing,String Manipulation,"from itertools import zip_longest
 
txt = """"""Given$a$txt$file$of$many$lines,$where$fields$within$a$line$
are$delineated$by$a$single$'dollar'$character,$write$a$program
that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$
column$are$separated$by$at$least$one$space.
Further,$allow$for$each$word$in$a$column$to$be$either$left$
justified,$right$justified,$or$center$justified$within$its$column.""""""
 
parts = [line.rstrip(""$"").split(""$"") for line in txt.splitlines()]
widths = [max(len(word) for word in col) 
          for col in zip_longest(*parts, fillvalue='')]
 
for justify in ""<_Left ^_Center >_Right"".split():
    j, jtext = justify.split('_')
    print(f""{jtext} column-aligned output:\n"")
    for line in parts:
        print(' '.join(f""{wrd:{j}{wdth}}"" for wdth, wrd in zip(widths, line)))
    print(""- "" * 52)
 "
oklw,python,Aliquot sequence classifications,Mathematics,Number Theory,"from proper_divisors import proper_divs
from functools import lru_cache
 
 
@lru_cache()
def pdsum(n): 
    return sum(proper_divs(n))
 
 
def aliquot(n, maxlen=16, maxterm=2**47):
    if n == 0:
        return 'terminating', [0]
    s, slen, new = [n], 1, n
    while slen <= maxlen and new < maxterm:
        new = pdsum(s[-1])
        if new in s:
            if s[0] == new:
                if slen == 1:
                    return 'perfect', s
                elif slen == 2:
                    return 'amicable', s
                else:
                    return 'sociable of length %i' % slen, s
            elif s[-1] == new:
                return 'aspiring', s
            else:
                return 'cyclic back to %i' % new, s
        elif new == 0:
            return 'terminating', s + [0]
        else:
            s.append(new)
            slen += 1
    else:
        return 'non-terminating', s
 
if __name__ == '__main__':
    for n in range(1, 11): 
        print('%s: %r' % aliquot(n))
    print()
    for n in [11, 12, 28, 496, 220, 1184,  12496, 1264460, 790, 909, 562, 1064, 1488, 15355717786080]: 
        print('%s: %r' % aliquot(n))"
no8u,python,Almkvist-Giullera formula for pi,Mathematics,Numerical Methods,"import mpmath as mp
 
with mp.workdps(72):
 
    def integer_term(n):
        p = 532 * n * n + 126 * n + 9
        return (p * 2**5 * mp.factorial(6 * n)) / (3 * mp.factorial(n)**6)
 
    def exponent_term(n):
        return -(mp.mpf(""6.0"") * n + 3)
 
    def nthterm(n):
        return integer_term(n) * mp.mpf(""10.0"")**exponent_term(n)
 
 
    for n in range(10):
        print(""Term "", n, '  ', int(integer_term(n)))
 
 
    def almkvist_guillera(floatprecision):
        summed, nextadd = mp.mpf('0.0'), mp.mpf('0.0')
        for n in range(100000000):
            nextadd = summed + nthterm(n)
            if abs(nextadd - summed) < 10.0**(-floatprecision):
                break
 
            summed = nextadd
 
        return nextadd
 
 
    print('\nπ to 70 digits is ', end='')
    mp.nprint(mp.mpf(1.0 / mp.sqrt(almkvist_guillera(70))), 71)
    print('mpmath π is       ', end='')
    mp.nprint(mp.pi, 71)
 "
8aet,python,Almost prime,Mathematics,Number Theory,"from prime_decomposition import decompose
from itertools import islice, count
try: 
    from functools import reduce
except: 
    pass
 
 
def almostprime(n, k=2):
    d = decompose(n)
    try:
        terms = [next(d) for i in range(k)]
        return reduce(int.__mul__, terms, 1) == n
    except:
        return False
 
if __name__ == '__main__':
    for k in range(1,6):
        print('%i: %r' % (k, list(islice((n for n in count() if almostprime(n, k)), 10))))"
gd41,python,Amb,Puzzles and Games,Puzzle Solving Algorithms,"import itertools as _itertools
 
class Amb(object):
    def __init__(self):
        self._names2values   = {}       # set of values for each global name
        self._func           = None     # Boolean constraint function
        self._valueiterator  = None     # itertools.product of names values
        self._funcargnames   = None     # Constraint parameter names
 
    def __call__(self, arg=None):
        if hasattr(arg, '__code__'):                
            ##
            ## Called with a constraint function. 
            ##
            globls = arg.__globals__ if hasattr(arg, '__globals__') else arg.func_globals
            # Names used in constraint
            argv = arg.__code__.co_varnames[:arg.__code__.co_argcount]
            for name in argv:
                if name not in self._names2values:
                    assert name in globls, \
                           ""Global name %s not found in function globals"" % name
                    self._names2values[name] = globls[name]
            # Gather the range of values of all names used in the constraint
            valuesets = [self._names2values[name] for name in argv]
            self._valueiterator = _itertools.product(*valuesets)
            self._func = arg
            self._funcargnames = argv
            return self
        elif arg is not None:
            ##
            ## Assume called with an iterable set of values
            ##
            arg = frozenset(arg)
            return arg
        else:
            ##
            ## blank call tries to return next solution
            ##
            return self._nextinsearch()
 
    def _nextinsearch(self):
        arg = self._func
        globls = arg.__globals__
        argv = self._funcargnames
        found = False
        for values in self._valueiterator:
            if arg(*values):
                # Set globals.
                found = True
                for n, v in zip(argv, values):
                    globls[n] = v
                break
        if not found: raise StopIteration
        return values
 
    def __iter__(self):
        return self
 
    def __next__(self):
        return self()
    next = __next__ # Python 2
 
if __name__ == '__main__':
    if True:
        amb = Amb()
 
        print(""\nSmall Pythagorean triples problem:"")
        x = amb(range(1,11))
        y = amb(range(1,11))
        z = amb(range(1,11))
 
        for _dummy in amb( lambda x, y, z: x*x + y*y == z*z ):
            print ('%s %s %s' % (x, y, z))
 
 
    if True:
        amb = Amb()
 
        print(""\nRosetta Code Amb problem:"")
        w1 = amb([""the"", ""that"", ""a""])
        w2 = amb([""frog"", ""elephant"", ""thing""])
        w3 = amb([""walked"", ""treaded"", ""grows""])
        w4 = amb([""slowly"", ""quickly""])
 
        for _dummy in amb( lambda w1, w2, w3, w4: \
                             w1[-1] == w2[0] and \
                             w2[-1] == w3[0] and \
                             w3[-1] == w4[0] ):
            print ('%s %s %s %s' % (w1, w2, w3, w4))
 
    if True:
        amb = Amb()
 
        print(""\nAmb problem from ""
            ""http://www.randomhacks.net/articles/2005/10/11/amb-operator:"")
        x = amb([1, 2, 3])
        y = amb([4, 5, 6])
 
        for _dummy in amb( lambda x, y: x * y != 8 ):
            print ('%s %s' % (x, y))"
ntcf,python,Amicable pairs,Mathematics,Number Theory,"from proper_divisors import proper_divs
 
def amicable(rangemax=20000):
    n2divsum = {n: sum(proper_divs(n)) for n in range(1, rangemax + 1)}
    for num, divsum in n2divsum.items():
        if num < divsum and divsum <= rangemax and n2divsum[divsum] == num:
            yield num, divsum
 
if __name__ == '__main__':
    for num, divsum in amicable():
        print('Amicable pair: %i and %i With proper divisors:\n    %r\n    %r'
              % (num, divsum, sorted(proper_divs(num)), sorted(proper_divs(divsum))))"
rgo0,python,Anagrams,Puzzles and Games,Logic and Mathematical Puzzles,">>> import urllib.request
>>> from collections import defaultdict
>>> words = urllib.request.urlopen('http://wiki.puzzlers.org/pub/wordlists/unixdict.txt').read().split()
>>> anagram = defaultdict(list) # map sorted chars to anagrams
>>> for word in words:
	anagram[tuple(sorted(word))].append( word )
 
 
>>> count = max(len(ana) for ana in anagram.values())
>>> for ana in anagram.values():
	if len(ana) >= count:
		print ([x.decode() for x in ana])"
mlnc,python,Anagrams/Deranged anagrams,Puzzles and Games,Logic and Mathematical Puzzles,"import urllib.request
from collections import defaultdict
from itertools import combinations
 
def getwords(url='http://www.puzzlers.org/pub/wordlists/unixdict.txt'):
    return list(set(urllib.request.urlopen(url).read().decode().split()))
 
def find_anagrams(words):
    anagram = defaultdict(list) # map sorted chars to anagrams
    for word in words:
        anagram[tuple(sorted(word))].append( word )
    return dict((key, words) for key, words in anagram.items()
                if len(words) > 1)
 
def is_deranged(words):
    'returns pairs of words that have no character in the same position'
    return [ (word1, word2)
             for word1,word2 in combinations(words, 2)
             if all(ch1 != ch2 for ch1, ch2 in zip(word1, word2)) ]
 
def largest_deranged_ana(anagrams):
    ordered_anagrams = sorted(anagrams.items(),
                              key=lambda x:(-len(x[0]), x[0]))
    for _, words in ordered_anagrams:
        deranged_pairs = is_deranged(words)
        if deranged_pairs:
            return deranged_pairs
    return []
 
if __name__ == '__main__':
    words = getwords('http://www.puzzlers.org/pub/wordlists/unixdict.txt')
    print(""Word count:"", len(words))
 
    anagrams = find_anagrams(words)
    print(""Anagram count:"", len(anagrams),""\n"")
 
    print(""Longest anagrams with no characters in the same position:"")
    print('  ' + '\n  '.join(', '.join(pairs)
                             for pairs in largest_deranged_ana(anagrams)))"
xj0w,python,Angle difference between two bearings,Mathematics,Geometry and Trigonometry,"from __future__ import print_function
 
def getDifference(b1, b2):
	r = (b2 - b1) % 360.0
	# Python modulus has same sign as divisor, which is positive here,
	# so no need to consider negative case
	if r >= 180.0:
		r -= 360.0
	return r
 
if __name__ == ""__main__"":
	print (""Input in -180 to +180 range"")
	print (getDifference(20.0, 45.0))
	print (getDifference(-45.0, 45.0))
	print (getDifference(-85.0, 90.0))
	print (getDifference(-95.0, 90.0))
	print (getDifference(-45.0, 125.0))
	print (getDifference(-45.0, 145.0))
	print (getDifference(-45.0, 125.0))
	print (getDifference(-45.0, 145.0))
	print (getDifference(29.4803, -88.6381))
	print (getDifference(-78.3251, -159.036))
 
	print (""Input in wider range"")
	print (getDifference(-70099.74233810938, 29840.67437876723))
	print (getDifference(-165313.6666297357, 33693.9894517456))
	print (getDifference(1174.8380510598456, -154146.66490124757))
	print (getDifference(60175.77306795546, 42213.07192354373))"
0a3n,python,"Angles (geometric), normalization and conversion",Mathematics,Geometry and Trigonometry,"PI = 3.141592653589793
TWO_PI = 6.283185307179586
 
def normalize2deg(a):
  while a < 0: a += 360
  while a >= 360: a -= 360
  return a
def normalize2grad(a):
  while a < 0: a += 400
  while a >= 400: a -= 400
  return a
def normalize2mil(a):
  while a < 0: a += 6400
  while a >= 6400: a -= 6400
  return a
def normalize2rad(a):
  while a < 0: a += TWO_PI
  while a >= TWO_PI: a -= TWO_PI
  return a
 
def deg2grad(a): return a * 10.0 / 9.0
def deg2mil(a): return a * 160.0 / 9.0
def deg2rad(a): return a * PI / 180.0
 
def grad2deg(a): return a * 9.0 / 10.0
def grad2mil(a): return a * 16.0
def grad2rad(a): return a * PI / 200.0
 
def mil2deg(a): return a * 9.0 / 160.0
def mil2grad(a): return a / 16.0
def mil2rad(a): return a * PI / 3200.0
 
def rad2deg(a): return a * 180.0 / PI
def rad2grad(a): return a * 200.0 / PI
def rad2mil(a): return a * 3200.0 / PI"
ayl4,python,Animate a pendulum,Graphics and Visualization,Graphics Programming,"import pygame, sys
from pygame.locals import *
from math import sin, cos, radians
 
pygame.init()
 
WINDOWSIZE = 250
TIMETICK = 100
BOBSIZE = 15
 
window = pygame.display.set_mode((WINDOWSIZE, WINDOWSIZE))
pygame.display.set_caption(""Pendulum"")
 
screen = pygame.display.get_surface()
screen.fill((255,255,255))
 
PIVOT = (WINDOWSIZE/2, WINDOWSIZE/10)
SWINGLENGTH = PIVOT[1]*4
 
class BobMass(pygame.sprite.Sprite):
    def __init__(self):
        pygame.sprite.Sprite.__init__(self)
        self.theta = 45
        self.dtheta = 0
        self.rect = pygame.Rect(PIVOT[0]-SWINGLENGTH*cos(radians(self.theta)),
                                PIVOT[1]+SWINGLENGTH*sin(radians(self.theta)),
                                1,1)
        self.draw()
 
    def recomputeAngle(self):
        scaling = 3000.0/(SWINGLENGTH**2)
 
        firstDDtheta = -sin(radians(self.theta))*scaling
        midDtheta = self.dtheta + firstDDtheta
        midtheta = self.theta + (self.dtheta + midDtheta)/2.0
 
        midDDtheta = -sin(radians(midtheta))*scaling
        midDtheta = self.dtheta + (firstDDtheta + midDDtheta)/2
        midtheta = self.theta + (self.dtheta + midDtheta)/2
 
        midDDtheta = -sin(radians(midtheta)) * scaling
        lastDtheta = midDtheta + midDDtheta
        lasttheta = midtheta + (midDtheta + lastDtheta)/2.0
 
        lastDDtheta = -sin(radians(lasttheta)) * scaling
        lastDtheta = midDtheta + (midDDtheta + lastDDtheta)/2.0
        lasttheta = midtheta + (midDtheta + lastDtheta)/2.0
 
        self.dtheta = lastDtheta
        self.theta = lasttheta
        self.rect = pygame.Rect(PIVOT[0]-
                                SWINGLENGTH*sin(radians(self.theta)), 
                                PIVOT[1]+
                                SWINGLENGTH*cos(radians(self.theta)),1,1)
 
 
    def draw(self):
        pygame.draw.circle(screen, (0,0,0), PIVOT, 5, 0)
        pygame.draw.circle(screen, (0,0,0), self.rect.center, BOBSIZE, 0)
        pygame.draw.aaline(screen, (0,0,0), PIVOT, self.rect.center)
        pygame.draw.line(screen, (0,0,0), (0, PIVOT[1]), (WINDOWSIZE, PIVOT[1]))
 
    def update(self):
        self.recomputeAngle()
        screen.fill((255,255,255))
        self.draw()
 
bob = BobMass()
 
TICK = USEREVENT + 2
pygame.time.set_timer(TICK, TIMETICK)
 
def input(events):
    for event in events:
        if event.type == QUIT:
            sys.exit(0)
        elif event.type == TICK:
            bob.update()
 
while True:
    input(pygame.event.get())
    pygame.display.flip()"
uwp1,python,Animation,Graphics and Visualization,Graphics Programming,"#!/usr/bin/env python3
import sys
 
from PyQt5.QtCore import QBasicTimer, Qt
from PyQt5.QtGui import QFont
from PyQt5.QtWidgets import QApplication, QLabel
 
 
class Marquee(QLabel):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.right_to_left_direction = True
        self.initUI()
        self.timer = QBasicTimer()
        self.timer.start(80, self)
 
    def initUI(self):
        self.setWindowFlags(Qt.FramelessWindowHint)
        self.setAttribute(Qt.WA_TranslucentBackground)
        self.setText(""Hello World! "")
        self.setFont(QFont(None, 50, QFont.Bold))
        # make more irritating for the authenticity with <marquee> element
        self.setStyleSheet(""QLabel {color: cyan; }"")
 
    def timerEvent(self, event):
        i = 1 if self.right_to_left_direction else -1
        self.setText(self.text()[i:] + self.text()[:i])  # rotate
 
    def mouseReleaseEvent(self, event):  # change direction on mouse release
        self.right_to_left_direction = not self.right_to_left_direction
 
    def keyPressEvent(self, event):  # exit on Esc
        if event.key() == Qt.Key_Escape:
            self.close()
 
 
app = QApplication(sys.argv)
w = Marquee()
# center widget on the screen
w.adjustSize()  # update w.rect() now
w.move(QApplication.instance().desktop().screen().rect().center()
       - w.rect().center())
w.show()
sys.exit(app.exec())"
g8vw,python,Anonymous recursion,Programming Concepts,Advanced Concepts,">>> Y = lambda f: (lambda x: x(x))(lambda y: f(lambda *args: y(y)(*args)))
>>> fib = lambda f: lambda n: None if n < 0 else (0 if n == 0 else (1 if n == 1 else f(n-1) + f(n-2)))
>>> [ Y(fib)(i) for i in range(-2, 10) ]
[None, None, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34]"
fn2l,python,Anti-primes,Mathematics,Number Theory,"from itertools import chain, count, cycle, islice, accumulate
 
def factors(n):
    def prime_powers(n):
        for c in accumulate(chain([2, 1, 2], cycle([2,4]))):
            if c*c > n: break
            if n%c: continue
            d,p = (), c
            while not n%c:
                n,p,d = n//c, p*c, d+(p,)
            yield d
        if n > 1: yield n,
 
    r = [1]
    for e in prime_powers(n):
        r += [a*b for a in r for b in e]
    return r
 
def antiprimes():
    mx = 0
    yield 1
    for c in count(2,2):
        if c >= 58: break
        ln = len(factors(c))
        if ln > mx:
            yield c
            mx = ln
    for c in count(60,30):
        ln = len(factors(c))
        if ln > mx:
            yield c
            mx = ln  
 
if __name__ == '__main__':
    print(*islice(antiprimes(), 40)))"
b8qb,python,Append a record to the end of a text file,Systems Programming and File I/O,File Operations,"#############################
# Create a passwd text file
#############################
# note that UID & gid are of type ""text""
passwd_list=[
  dict(account='jsmith', password='x', UID=1001, GID=1000, # UID and GID are type int
       GECOS=dict(fullname='Joe Smith', office='Room 1007', extension='(234)555-8917',
                  homephone='(234)555-0077', email='jsmith@rosettacode.org'),
                  directory='/home/jsmith', shell='/bin/bash'),
  dict(account='jdoe', password='x', UID=1002, GID=1000,
       GECOS=dict(fullname='Jane Doe', office='Room 1004', extension='(234)555-8914',
                  homephone='(234)555-0044', email='jdoe@rosettacode.org'),
       directory='/home/jdoe', shell='/bin/bash')
]
 
passwd_fields=""account password UID GID GECOS directory shell"".split()
GECOS_fields=""fullname office extension homephone email"".split()
 
def passwd_text_repr(passwd_rec):
# convert individual fields to string type
  passwd_rec[""GECOS""]="","".join([ passwd_rec[""GECOS""][field] for field in GECOS_fields])
  for field in passwd_rec: # convert ""int"" fields
    if not isinstance(passwd_rec[field], str):
      passwd_rec[field]=`passwd_rec[field]`
  return "":"".join([ passwd_rec[field] for field in passwd_fields ])
 
passwd_text=open(""passwd.txt"",""w"")
for passwd_rec in passwd_list:
  print >> passwd_text,passwd_text_repr(passwd_rec)
passwd_text.close()
 
#################################
# Load text ready for appending
#################################
passwd_text=open(""passwd.txt"",""a+"")
new_rec=dict(account='xyz', password='x', UID=1003, GID=1000,
             GECOS=dict(fullname='X Yz', office='Room 1003', extension='(234)555-8913',
                        homephone='(234)555-0033', email='xyz@rosettacode.org'),
             directory='/home/xyz', shell='/bin/bash')
print >> passwd_text,  passwd_text_repr(new_rec)
passwd_text.close()
 
##############################################
# Finally reopen and check record was appended
##############################################
passwd_list=list(open(""passwd.txt"",""r""))
if ""xyz"" in passwd_list[-1]:
  print ""Appended record:"",passwd_list[-1][:-1]"
9dpt,python,Apply a callback to an array,Programming Concepts,Fundamentals,"def square(n):
    return n * n
 
numbers = [1, 3, 5, 7]
 
squares1 = [square(n) for n in numbers]     # list comprehension
 
squares2a = map(square, numbers)            # functional form
 
squares2b = map(lambda x: x*x, numbers)     # functional form with `lambda`
 
squares3 = [n * n for n in numbers]         # no need for a function,
                                            # anonymous or otherwise
 
isquares1 = (n * n for n in numbers)        # iterator, lazy
 
import itertools
isquares2 = itertools.imap(square, numbers) # iterator, lazy"
3gq4,python,Apply a digital filter (direct form II transposed),Algorithms and Data Structures,Algorithms,"#!/bin/python
from __future__ import print_function
from scipy import signal
import matplotlib.pyplot as plt
 
if __name__==""__main__"":
	sig = [-0.917843918645,0.141984778794,1.20536903482,0.190286794412,-0.662370894973,-1.00700480494,
		-0.404707073677,0.800482325044,0.743500089861,1.01090520172,0.741527555207,
		0.277841675195,0.400833448236,-0.2085993586,-0.172842103641,-0.134316096293,
		0.0259303398477,0.490105989562,0.549391221511,0.9047198589]
 
	#Create an order 3 lowpass butterworth filter
	#Generated using b, a = signal.butter(3, 0.5)
	a = [1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17]
	b = [0.16666667, 0.5, 0.5, 0.16666667]
 
	#Apply the filter to signal
	filt = signal.lfilter(b, a, sig)
	print (filt)
 
	plt.plot(sig, 'b')
	plt.plot(filt, 'r--')
	plt.show()"
0ee4,python,Approximate equality,Mathematics,Numerical Methods,"math.isclose -> bool
    a: double
    b: double
    *
    rel_tol: double = 1e-09
        maximum difference for being considered ""close"", relative to the
        magnitude of the input values
    abs_tol: double = 0.0
        maximum difference for being considered ""close"", regardless of the
        magnitude of the input values
Determine whether two floating point numbers are close in value.
Return True if a is close in value to b, and False otherwise.
For the values to be considered close, the difference between them
must be smaller than at least one of the tolerances.
-inf, inf and NaN behave similarly to the IEEE 754 Standard.  That
is, NaN is not close to anything, even itself.  inf and -inf are
only close to themselves.
"
i3v2,python,Arbitrary-precision integers (included),Mathematics,Numerical Methods,">>> y = str( 5**4**3**2 )
>>> print (""5**4**3**2 = %s...%s and has %i digits"" % (y[:20], y[-20:], len(y)))
5**4**3**2 = 62060698786608744707...92256259918212890625 and has 183231 digits"
nu78,python,Archimedean spiral,Mathematics,Geometry and Trigonometry,"from turtle import *
from math import *
color(""blue"")
down()
for i in range(200):
    t = i / 20 * pi
    x = (1 + 5 * t) * cos(t)
    y = (1 + 5 * t) * sin(t)
    goto(x, y)
up()
done()"
opnc,python,Arena storage pool,Systems Programming and File I/O,File Operations," 
(malloc 1000 'raw)             ; raw allocation, bypass the GC, requires free()-ing
(malloc 1000 'uncollectable)   ; no GC, for use with other GCs that Racket can be configured with
(malloc 1000 'atomic)          ; a block of memory without internal pointers
(malloc 1000 'nonatomic)       ; a block of pointers
(malloc 1000 'eternal)         ; uncollectable & atomic, similar to raw malloc but no freeing
(malloc 1000 'stubborn)        ; can be declared immutable when mutation is done
(malloc 1000 'interior)        ; allocate an immovable block with possible pointers into it
(malloc 1000 'atomic-interior) ; same for atomic chunks
(malloc-immobile-cell v)       ; allocates a single cell that the GC will not move
 "
irbm,python,Arithmetic evaluation,Mathematics,Algebra and Arithmetic,"import operator
 
class AstNode(object):
   def __init__( self, opr, left, right ):
      self.opr = opr
      self.l = left
      self.r = right
 
   def eval(self):
      return self.opr(self.l.eval(), self.r.eval())
 
class LeafNode(object):
   def __init__( self, valStrg ):
      self.v = int(valStrg)
 
   def eval(self):
      return self.v
 
class Yaccer(object):
   def __init__(self):
      self.operstak = []
      self.nodestak =[]
      self.__dict__.update(self.state1)
 
   def v1( self, valStrg ):
      # Value String
      self.nodestak.append( LeafNode(valStrg))
      self.__dict__.update(self.state2)
      #print 'push', valStrg
 
   def o2( self, operchar ):
      # Operator character or open paren in state1
      def openParen(a,b):
         return 0		# function should not be called
 
      opDict= { '+': ( operator.add, 2, 2 ),
         '-': (operator.sub, 2, 2 ),
         '*': (operator.mul, 3, 3 ),
         '/': (operator.div, 3, 3 ),
         '^': ( pow,         4, 5 ),  # right associative exponentiation for grins
         '(': ( openParen,   0, 8 )
         }
      operPrecidence = opDict[operchar][2]
      self.redeuce(operPrecidence)
 
      self.operstak.append(opDict[operchar])
      self.__dict__.update(self.state1)
      # print 'pushop', operchar
 
   def syntaxErr(self, char ):
      # Open Parenthesis 
      print 'parse error - near operator ""%s""' %char
 
   def pc2( self,operchar ):
      # Close Parenthesis
      # reduce node until matching open paren found 
      self.redeuce( 1 )
      if len(self.operstak)>0:
         self.operstak.pop()		# pop off open parenthesis
      else:
         print 'Error - no open parenthesis matches close parens.'
      self.__dict__.update(self.state2)
 
   def end(self):
      self.redeuce(0)
      return self.nodestak.pop()
 
   def redeuce(self, precidence):
      while len(self.operstak)>0:
         tailOper = self.operstak[-1]
         if tailOper[1] < precidence: break
 
         tailOper = self.operstak.pop()
         vrgt = self.nodestak.pop()
         vlft= self.nodestak.pop()
         self.nodestak.append( AstNode(tailOper[0], vlft, vrgt))
         # print 'reduce'
 
   state1 = { 'v': v1, 'o':syntaxErr, 'po':o2, 'pc':syntaxErr }
   state2 = { 'v': syntaxErr, 'o':o2, 'po':syntaxErr, 'pc':pc2 }
 
 
def Lex( exprssn, p ):
   bgn = None
   cp = -1
   for c in exprssn:
      cp += 1
      if c in '+-/*^()':         # throw in exponentiation (^)for grins
         if bgn is not None:
            p.v(p, exprssn[bgn:cp])
            bgn = None
         if c=='(': p.po(p, c)
         elif c==')':p.pc(p, c)
         else: p.o(p, c)
      elif c in ' \t':
         if bgn is not None:
            p.v(p, exprssn[bgn:cp])
            bgn = None
      elif c in '0123456789':
         if bgn is None:
            bgn = cp
      else:
         print 'Invalid character in expression'
         if bgn is not None:
            p.v(p, exprssn[bgn:cp])
            bgn = None
 
   if bgn is not None:
      p.v(p, exprssn[bgn:cp+1])
      bgn = None
   return p.end()
 
 
expr = raw_input(""Expression:"")
astTree = Lex( expr, Yaccer())
print expr, '=',astTree.eval()"
uqdg,python,Arithmetic numbers,Mathematics,Number Theory,"def factors(n: int):
    f = set([1, n])
    i = 2
    while True:
        j = n // i
        if j < i:
            break
        if i * j == n:
            f.add(i)
            f.add(j)
        i += 1
    return f
 
arithmetic_count = 0
composite_count = 0
n = 1
while arithmetic_count <= 1000000:
    f = factors(n)
    if (sum(f)/len(f)).is_integer():
        arithmetic_count += 1
        if len(f) > 2:
            composite_count += 1
        if arithmetic_count <= 100:
            print(f'{n:3d} ', end='')
            if arithmetic_count % 10 == 0:
                print()
        if arithmetic_count in (1000, 10000, 100000, 1000000):
            print(f'\n{arithmetic_count}th arithmetic number is {n}')
            print(f'Number of composite arithmetic numbers <= {n}: {composite_count}')
    n += 1"
h2gl,python,Arithmetic-geometric mean,Mathematics,Numerical Methods,"from math import sqrt
 
def agm(a0, g0, tolerance=1e-10):
    """"""
    Calculating the arithmetic-geometric mean of two numbers a0, g0.
 
    tolerance     the tolerance for the converged 
                  value of the arithmetic-geometric mean
                  (default value = 1e-10)
    """"""
    an, gn = (a0 + g0) / 2.0, sqrt(a0 * g0)
    while abs(an - gn) > tolerance:
        an, gn = (an + gn) / 2.0, sqrt(an * gn)
    return an
 
print agm(1, 1 / sqrt(2))"
eyen,python,Arithmetic-geometric mean/Calculate Pi,Mathematics,Numerical Methods,"from decimal import *
 
D = Decimal
getcontext().prec = 100
a = n = D(1)
g, z, half = 1 / D(2).sqrt(), D(0.25), D(0.5)
for i in range(18):
    x = [(a + g) * half, (a * g).sqrt()]
    var = x[0] - a
    z -= var * var * n
    n += n
    a, g = x    
print(a * a / z)"
dgdm,python,Arithmetic/Complex,Mathematics,Algebra and Arithmetic,">>> z1 = 1.5 + 3j
>>> z2 = 1.5 + 1.5j
>>> z1 + z2
(3+4.5j)
>>> z1 - z2
1.5j
>>> z1 * z2
(-2.25+6.75j)
>>> z1 / z2
(1.5+0.5j)
>>> - z1
(-1.5-3j)
>>> z1.conjugate()
(1.5-3j)
>>> abs(z1)
3.3541019662496847
>>> z1 ** z2
(-1.1024829553277784-0.38306415117199333j)
>>> z1.real
1.5
>>> z1.imag
3.0
>>> "
akfb,python,Arithmetic/Integer,Mathematics,Algebra and Arithmetic,"x = int(raw_input(""Number 1: ""))
y = int(raw_input(""Number 2: ""))
 
print ""Sum: %d"" % (x + y)
print ""Difference: %d"" % (x - y)
print ""Product: %d"" % (x * y)
print ""Quotient: %d"" % (x / y)     #  or x // y  for newer python versions.
                                   # truncates towards negative infinity
print ""Remainder: %d"" % (x % y)    # same sign as second operand
print ""Quotient: %d with Remainder: %d"" % divmod(x, y)
print ""Power: %d"" % x**y
 
## Only used to keep the display up when the program ends
raw_input( )"
ky3n,python,Arithmetic/Rational,Mathematics,Algebra and Arithmetic,"from fractions import Fraction
 
for candidate in range(2, 2**19):
  sum = Fraction(1, candidate)
  for factor in range(2, int(candidate**0.5)+1):
    if candidate % factor == 0:
      sum += Fraction(1, factor) + Fraction(1, candidate // factor)
  if sum.denominator == 1:
    print(""Sum of recipr. factors of %d = %d exactly %s"" %
           (candidate, int(sum), ""perfect!"" if sum == 1 else """"))"
rat4,python,Array concatenation,Programming Concepts,Fundamentals,"arr1 = [1, 2, 3]
arr2 = [4, 5, 6]
arr3 = [7, 8, 9]
arr4 = arr1 + arr2
assert arr4 == [1, 2, 3, 4, 5, 6]
arr4.extend(arr3)
assert arr4 == [1, 2, 3, 4, 5, 6, 7, 8, 9]"
pbkw,python,Array length,Text Processing,String Manipulation,">>> print(len(['apple', 'orange']))
2
>>> "
gjmf,python,Arrays,Algorithms and Data Structures,Data Structures,"array = []
 
array.append(1)
array.append(3)
 
array[0] = 2
 
print array[0]"
m8bj,python,Ascending primes,Mathematics,Number Theory,"from sympy import isprime
 
def ascending(x=0):
    for y in range(x*10 + (x%10) + 1, x*10 + 10):
        yield from ascending(y)
        yield(y)
 
print(sorted(x for x in ascending() if isprime(x)))"
5pw5,python,Assertions,Programming Concepts,Fundamentals,"a = 5
#...input or change a here
assert a == 42 # throws an AssertionError when a is not 42
assert a == 42, ""Error message"" # throws an AssertionError
       # when a is not 42 with ""Error message"" for the message
       # the error message can be any expression"
hxtd,python,Associative array/Creation,Algorithms and Data Structures,Data Structures,"hash = dict()  # 'dict' is the dictionary type.
hash = dict(red=""FF0000"", green=""00FF00"", blue=""0000FF"")
hash = { 'key1':1, 'key2':2, }
value = hash[key]"
sawn,python,Associative array/Iteration,Algorithms and Data Structures,Data Structures,"myDict = { ""hello"": 13,
	   ""world"": 31,
	   ""!""    : 71 }
 
# iterating over key-value pairs:
for key, value in myDict.items():
    print (""key = %s, value = %s"" % (key, value))
 
# iterating over keys:
for key in myDict:
    print (""key = %s"" % key)
# (is a shortcut for:)
for key in myDict.keys():
    print (""key = %s"" % key)
 
# iterating over values:
for value in myDict.values():
    print (""value = %s"" % value)"
k5jn,python,Associative array/Merging,Programming Concepts,Fundamentals,"base = {""name"":""Rocket Skates"", ""price"":12.75, ""color"":""yellow""}
update = {""price"":15.25, ""color"":""red"", ""year"":1974}
 
result = {**base, **update}
 
print(result)"
1eo6,python,Atomic updates,Concurrency and Parallelism,Multithreading and Thread Management,"from __future__ import with_statement # required for Python 2.5
import threading
import random
import time
 
terminate = threading.Event()
 
class Buckets:
    def __init__(self, nbuckets):
        self.nbuckets = nbuckets
        self.values = [random.randrange(10) for i in range(nbuckets)]
        self.lock = threading.Lock()
 
    def __getitem__(self, i):
        return self.values[i]
 
    def transfer(self, src, dst, amount):
        with self.lock:
            amount = min(amount, self.values[src])
            self.values[src] -= amount
            self.values[dst] += amount
 
    def snapshot(self):
        # copy of the current state (synchronized)
        with self.lock:
            return self.values[:]
 
def randomize(buckets):
    nbuckets = buckets.nbuckets
    while not terminate.isSet():
        src = random.randrange(nbuckets)
        dst = random.randrange(nbuckets)
        if dst!=src:
            amount = random.randrange(20)
            buckets.transfer(src, dst, amount)
 
def equalize(buckets):
    nbuckets = buckets.nbuckets
    while not terminate.isSet():
        src = random.randrange(nbuckets)
        dst = random.randrange(nbuckets)
        if dst!=src:
            amount = (buckets[src] - buckets[dst]) // 2
            if amount>=0: buckets.transfer(src, dst, amount)
            else: buckets.transfer(dst, src, -amount)
 
def print_state(buckets):
    snapshot = buckets.snapshot()
    for value in snapshot:
        print '%2d' % value,
    print '=', sum(snapshot)
 
# create 15 buckets
buckets = Buckets(15)
 
# the randomize thread
t1 = threading.Thread(target=randomize, args=[buckets])
t1.start()
 
# the equalize thread
t2 = threading.Thread(target=equalize, args=[buckets])
t2.start()
 
# main thread, display
try:
    while True:
        print_state(buckets)
        time.sleep(1)
except KeyboardInterrupt: # ^C to finish
    terminate.set()
 
# wait until all worker threads finish
t1.join()
t2.join()"
zvki,python,Attractive numbers,Mathematics,Number Theory,"from sympy import sieve # library for primes
 
def get_pfct(n): 
	i = 2; factors = []
	while i * i <= n:
		if n % i:
			i += 1
		else:
			n //= i
			factors.append(i)
	if n > 1:
		factors.append(n)
	return len(factors) 
 
sieve.extend(110) # first 110 primes...
primes=sieve._list
 
pool=[]
 
for each in xrange(0,121):
	pool.append(get_pfct(each))
 
for i,each in enumerate(pool):
	if each in primes:
		print i,"
se57,python,Average loop length,Mathematics,Probability and Statistics,"from __future__ import division # Only necessary for Python 2.X
from math import factorial
from random import randrange
 
MAX_N = 20
TIMES = 1000000
 
def analytical(n):
	return sum(factorial(n) / pow(n, i) / factorial(n -i) for i in range(1, n+1))
 
def test(n, times):
    count = 0
    for i in range(times):
        x, bits = 1, 0
        while not (bits & x):
            count += 1
            bits |= x
            x = 1 << randrange(n)
    return count / times
 
if __name__ == '__main__':
    print("" n\tavg\texp.\tdiff\n-------------------------------"")
    for n in range(1, MAX_N+1):
        avg = test(n, TIMES)
        theory = analytical(n)
        diff = (avg / theory - 1) * 100
        print(""%2d %8.4f %8.4f %6.3f%%"" % (n, avg, theory, diff))"
0twf,python,Averages/Arithmetic mean,Mathematics,Probability and Statistics,"from math import fsum
def average(x):
    return fsum(x)/float(len(x)) if x else 0
print (average([0,0,3,1,4,1,5,9,0,0]))
print (average([1e20,-1e-20,3,1,4,1,5,9,-1e20,1e-20]))"
69jf,python,Averages/Mean angle,Mathematics,Geometry and Trigonometry,">>> from cmath import rect, phase
>>> from math import radians, degrees
>>> def mean_angle(deg):
...     return degrees(phase(sum(rect(1, radians(d)) for d in deg)/len(deg)))
... 
>>> for angles in [[350, 10], [90, 180, 270, 360], [10, 20, 30]]:
...     print('The mean angle of', angles, 'is:', round(mean_angle(angles), 12), 'degrees')
...     
The mean angle of [350, 10] is: -0.0 degrees
The mean angle of [90, 180, 270, 360] is: -90.0 degrees
The mean angle of [10, 20, 30] is: 20.0 degrees
>>> "
exuo,python,Averages/Mean time of day,Mathematics,Probability and Statistics,"from cmath import rect, phase
from math import radians, degrees
 
 
def mean_angle(deg):
    return degrees(phase(sum(rect(1, radians(d)) for d in deg)/len(deg)))
 
def mean_time(times):
    t = (time.split(':') for time in times)
    seconds = ((float(s) + int(m) * 60 + int(h) * 3600) 
               for h, m, s in t)
    day = 24 * 60 * 60
    to_angles = [s * 360. / day for s in seconds]
    mean_as_angle = mean_angle(to_angles)
    mean_seconds = mean_as_angle * day / 360.
    if mean_seconds < 0:
        mean_seconds += day
    h, m = divmod(mean_seconds, 3600)
    m, s = divmod(m, 60)
    return '%02i:%02i:%02i' % (h, m, s)
 
 
if __name__ == '__main__':
    print( mean_time([""23:00:17"", ""23:40:20"", ""00:12:45"", ""00:17:19""]) )"
dam1,python,Averages/Median,Mathematics,Probability and Statistics,"def median(aray):
    srtd = sorted(aray)
    alen = len(srtd)
    return 0.5*( srtd[(alen-1)//2] + srtd[alen//2])
 
a = (4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2)
print a, median(a)
a = (4.1, 7.2, 1.7, 9.3, 4.4, 3.2)
print a, median(a)"
e3q8,python,Averages/Mode,Mathematics,Probability and Statistics,">>> from collections import defaultdict
>>> def modes(values):
	count = defaultdict(int)
	for v in values:
		count[v] +=1
	best = max(count.values())
	return [k for k,v in count.items() if v == best]
 
>>> modes([1,3,6,6,6,6,7,7,12,12,17])
[6]
>>> modes((1,1,2,4,4))
[1, 4]"
8d1q,python,Averages/Pythagorean means,Mathematics,Probability and Statistics,"from operator import mul
from functools import reduce
 
 
def amean(num):
    return sum(num) / len(num)
 
 
def gmean(num):
    return reduce(mul, num, 1)**(1 / len(num))
 
 
def hmean(num):
    return len(num) / sum(1 / n for n in num)
 
 
numbers = range(1, 11)  # 1..10
a, g, h = amean(numbers), gmean(numbers), hmean(numbers)
print(a, g, h)
assert a >= g >= h"
p9zs,python,Averages/Root mean square,Mathematics,Probability and Statistics,">>> from math import sqrt
>>> def qmean(num):
	return sqrt(sum(n*n for n in num)/len(num))
 
>>> qmean(range(1,11))
6.2048368229954285"
xgeo,python,Averages/Simple moving average,Mathematics,Probability and Statistics,"from collections import deque
 
def simplemovingaverage(period):
    assert period == int(period) and period > 0, ""Period must be an integer >0""
 
    summ = n = 0.0
    values = deque([0.0] * period)     # old value queue
 
    def sma(x):
        nonlocal summ, n
 
        values.append(x)
        summ += x - values.popleft()
        n = min(n+1, period)
        return summ / n
 
    return sma"
gaci,python,Babbage problem,Mathematics,Number Theory," 
# Lines that start by # are a comments:
# they will be ignored by the machine
 
n=0 # n is a variable and its value is 0
 
# we will increase its value by one until
# its square ends in 269,696
 
while n**2 % 1000000 != 269696:
 
    # n**2 -> n squared
    # %    -> 'modulo' or remainer after division
    # !=   -> not equal to
 
    n += 1 # += -> increase by a certain number
 
print(n) # prints n
 
# short version
>>> [x for x in range(30000) if (x*x) % 1000000 == 269696] [0]
25264
 "
sau2,python,Balanced brackets,Puzzles and Games,Logic and Mathematical Puzzles,">>> def gen(N):
...     txt = ['[', ']'] * N
...     random.shuffle( txt )
...     return ''.join(txt)
... 
>>> def balanced(txt):
...     braced = 0
...     for ch in txt:
...         if ch == '[': braced += 1
...         if ch == ']':
...             braced -= 1
...             if braced < 0: return False
...     return braced == 0
... 
>>> for txt in (gen(N) for N in range(10)):
...     print (""%-22r is%s balanced"" % (txt, '' if balanced(txt) else ' not'))
... 
''                     is balanced
'[]'                   is balanced
'[][]'                 is balanced
'][[[]]'               is not balanced
'[]][[][]'             is not balanced
'[][[][]]]['           is not balanced
'][]][][[]][['         is not balanced
'[[]]]]][]][[[['       is not balanced
'[[[[]][]]][[][]]'     is balanced
'][[][[]]][]]][[[[]'   is not balanced"
hui2,python,Balanced ternary,Mathematics,Number Theory,"class BalancedTernary:
    # Represented as a list of 0, 1 or -1s, with least significant digit first.
 
    str2dig = {'+': 1, '-': -1, '0': 0} # immutable
    dig2str = {1: '+', -1: '-', 0: '0'} # immutable
    table = ((0, -1), (1, -1), (-1, 0), (0, 0), (1, 0), (-1, 1), (0, 1)) # immutable
 
    def __init__(self, inp):
        if isinstance(inp, str):
            self.digits = [BalancedTernary.str2dig[c] for c in reversed(inp)]
        elif isinstance(inp, int):
            self.digits = self._int2ternary(inp)
        elif isinstance(inp, BalancedTernary):
            self.digits = list(inp.digits)
        elif isinstance(inp, list):
            if all(d in (0, 1, -1) for d in inp):
                self.digits = list(inp)
            else:
                raise ValueError(""BalancedTernary: Wrong input digits."")
        else:
            raise TypeError(""BalancedTernary: Wrong constructor input."")
 
    @staticmethod
    def _int2ternary(n):
        if n == 0: return []
        if (n % 3) == 0: return [0] + BalancedTernary._int2ternary(n // 3)
        if (n % 3) == 1: return [1] + BalancedTernary._int2ternary(n // 3)
        if (n % 3) == 2: return [-1] + BalancedTernary._int2ternary((n + 1) // 3)
 
    def to_int(self):
        return reduce(lambda y,x: x + 3 * y, reversed(self.digits), 0)
 
    def __repr__(self):
        if not self.digits: return ""0""
        return """".join(BalancedTernary.dig2str[d] for d in reversed(self.digits))
 
    @staticmethod
    def _neg(digs):
        return [-d for d in digs]
 
    def __neg__(self):
        return BalancedTernary(BalancedTernary._neg(self.digits))
 
    @staticmethod
    def _add(a, b, c=0):
        if not (a and b):
            if c == 0:
                return a or b
            else:
                return BalancedTernary._add([c], a or b)
        else:
            (d, c) = BalancedTernary.table[3 + (a[0] if a else 0) + (b[0] if b else 0) + c]
            res = BalancedTernary._add(a[1:], b[1:], c)
            # trim leading zeros
            if res or d != 0:
                return [d] + res
            else:
                return res
 
    def __add__(self, b):
        return BalancedTernary(BalancedTernary._add(self.digits, b.digits))
 
    def __sub__(self, b):
        return self + (-b)
 
    @staticmethod
    def _mul(a, b):
        if not (a and b):
            return []
        else:
            if   a[0] == -1: x = BalancedTernary._neg(b)
            elif a[0] ==  0: x = []
            elif a[0] ==  1: x = b
            else: assert False
            y = [0] + BalancedTernary._mul(a[1:], b)
            return BalancedTernary._add(x, y)
 
    def __mul__(self, b):
        return BalancedTernary(BalancedTernary._mul(self.digits, b.digits))
 
 
def main():
    a = BalancedTernary(""+-0++0+"")
    print ""a:"", a.to_int(), a
 
    b = BalancedTernary(-436)
    print ""b:"", b.to_int(), b
 
    c = BalancedTernary(""+-++-"")
    print ""c:"", c.to_int(), c
 
    r = a * (b - c)
    print ""a * (b - c):"", r.to_int(), r
 
main()"
tm4q,python,Barnsley fern,Mathematics,Fractals," 
 
import random
from PIL import Image
 
 
class BarnsleyFern(object):
    def __init__(self, img_width, img_height, paint_color=(0, 150, 0),
                 bg_color=(255, 255, 255)):
        self.img_width, self.img_height = img_width, img_height
        self.paint_color = paint_color
        self.x, self.y = 0, 0
        self.age = 0
 
        self.fern = Image.new('RGB', (img_width, img_height), bg_color)
        self.pix = self.fern.load()
        self.pix[self.scale(0, 0)] = paint_color
 
    def scale(self, x, y):
        h = (x + 2.182)*(self.img_width - 1)/4.8378
        k = (9.9983 - y)*(self.img_height - 1)/9.9983
        return h, k
 
    def transform(self, x, y):
        rand = random.uniform(0, 100)
        if rand < 1:
            return 0, 0.16*y
        elif 1 <= rand < 86:
            return 0.85*x + 0.04*y, -0.04*x + 0.85*y + 1.6
        elif 86 <= rand < 93:
            return 0.2*x - 0.26*y, 0.23*x + 0.22*y + 1.6
        else:
            return -0.15*x + 0.28*y, 0.26*x + 0.24*y + 0.44
 
    def iterate(self, iterations):
        for _ in range(iterations):
            self.x, self.y = self.transform(self.x, self.y)
            self.pix[self.scale(self.x, self.y)] = self.paint_color
        self.age += iterations
 
fern = BarnsleyFern(500, 500)
fern.iterate(1000000)
fern.fern.show()
 
 "
kjh9,python,Base64 decode data,Text Processing,Encoding and Decoding," 
import base64
data = 'VG8gZXJyIGlzIGh1bWFuLCBidXQgdG8gcmVhbGx5IGZvdWwgdGhpbmdzIHVwIHlvdSBuZWVkIGEgY29tcHV0ZXIuCiAgICAtLSBQYXVsIFIuIEVocmxpY2g='
print(base64.b64decode(data).decode('utf-8'))
 "
yqd5,python,Bell numbers,Mathematics,Combinatorics,"def bellTriangle(n):
    tri = [None] * n
    for i in xrange(n):
        tri[i] = [0] * i
    tri[1][0] = 1
    for i in xrange(2, n):
        tri[i][0] = tri[i - 1][i - 2]
        for j in xrange(1, i):
            tri[i][j] = tri[i][j - 1] + tri[i - 1][j - 1]
    return tri
 
def main():
    bt = bellTriangle(51)
    print ""First fifteen and fiftieth Bell numbers:""
    for i in xrange(1, 16):
        print ""%2d: %d"" % (i, bt[i][0])
    print ""50:"", bt[50][0]
    print
    print ""The first ten rows of Bell's triangle:""
    for i in xrange(1, 11):
        print bt[i]
 
main()"
y0hc,python,Benford's law,Mathematics,Probability and Statistics,"from __future__ import division
from itertools import islice, count
from collections import Counter
from math import log10
from random import randint
 
expected = [log10(1+1/d) for d in range(1,10)]
 
def fib():
    a,b = 1,1
    while True:
        yield a
        a,b = b,a+b
 
# powers of 3 as a test sequence
def power_of_threes():
    return (3**k for k in count(0))
 
def heads(s):
    for a in s: yield int(str(a)[0])
 
def show_dist(title, s):
    c = Counter(s)
    size = sum(c.values())
    res = [c[d]/size for d in range(1,10)]
 
    print(""\n%s Benfords deviation"" % title)
    for r, e in zip(res, expected):
        print(""%5.1f%% %5.1f%%  %5.1f%%"" % (r*100., e*100., abs(r - e)*100.))
 
def rand1000():
    while True: yield randint(1,9999)
 
if __name__ == '__main__':
    show_dist(""fibbed"", islice(heads(fib()), 1000))
    show_dist(""threes"", islice(heads(power_of_threes()), 1000))
 
    # just to show that not all kind-of-random sets behave like that
    show_dist(""random"", islice(heads(rand1000()), 10000))"
4gkf,python,Bernoulli numbers,Mathematics,Number Theory,"from fractions import Fraction as Fr
 
def bernoulli(n):
    A = [0] * (n+1)
    for m in range(n+1):
        A[m] = Fr(1, m+1)
        for j in range(m, 0, -1):
          A[j-1] = j*(A[j-1] - A[j])
    return A[0] # (which is Bn)
 
bn = [(i, bernoulli(i)) for i in range(61)]
bn = [(i, b) for i,b in bn if b]
width = max(len(str(b.numerator)) for i,b in bn)
for i,b in bn:
    print('B(%2i) = %*i/%i' % (i, width, b.numerator, b.denominator))"
s5tp,python,Best shuffle,Puzzles and Games,Puzzle Solving Algorithms,"import random
 
def count(w1,wnew):
    return sum(c1==c2 for c1,c2 in zip(w1, wnew))
 
def best_shuffle(w):
    wnew = list(w)
    n = len(w)
    rangelists = (list(range(n)), list(range(n)))
    for r in rangelists:
        random.shuffle(r)
    rangei, rangej = rangelists
    for i in rangei:
        for j in rangej:
            if i != j and wnew[j] != wnew[i] and w[i] != wnew[j] and w[j] != wnew[i]:
                wnew[j], wnew[i] = wnew[i], wnew[j]
                break
    wnew = ''.join(wnew)
    return wnew, count(w, wnew)
 
 
if __name__ == '__main__':
    test_words = ('tree abracadabra seesaw elk grrrrrr up a ' 
                  + 'antidisestablishmentarianism hounddogs').split()
    test_words += ['aardvarks are ant eaters', 'immediately', 'abba']
    for w in test_words:
        wnew, c = best_shuffle(w)
        print(""%29s, %-29s ,(%i)"" % (w, wnew, c))"
r7d8,python,Bin given limits,Algorithms and Data Structures,Algorithms,"from bisect import bisect_right
 
def bin_it(limits: list, data: list) -> list:
    ""Bin data according to (ascending) limits.""
    bins = [0] * (len(limits) + 1)      # adds under/over range bins too
    for d in data:
        bins[bisect_right(limits, d)] += 1
    return bins
 
def bin_print(limits: list, bins: list) -> list:
    print(f""          < {limits[0]:3} := {bins[0]:3}"")
    for lo, hi, count in zip(limits, limits[1:], bins[1:]):
        print(f"">= {lo:3} .. < {hi:3} := {count:3}"")
    print(f"">= {limits[-1]:3}          := {bins[-1]:3}"")
 
 
if __name__ == ""__main__"":
    print(""RC FIRST EXAMPLE\n"")
    limits  = [23, 37, 43, 53, 67, 83]
    data = [95,21,94,12,99,4,70,75,83,93,52,80,57,5,53,86,65,17,92,83,71,61,54,58,47,
            16, 8, 9,32,84,7,87,46,19,30,37,96,6,98,40,79,97,45,64,60,29,49,36,43,55]
    bins = bin_it(limits, data)
    bin_print(limits, bins)
 
    print(""\nRC SECOND EXAMPLE\n"")
    limits = [14, 18, 249, 312, 389, 392, 513, 591, 634, 720]
    data = [445,814,519,697,700,130,255,889,481,122,932, 77,323,525,570,219,367,523,442,933,
            416,589,930,373,202,253,775, 47,731,685,293,126,133,450,545,100,741,583,763,306,
            655,267,248,477,549,238, 62,678, 98,534,622,907,406,714,184,391,913, 42,560,247,
            346,860, 56,138,546, 38,985,948, 58,213,799,319,390,634,458,945,733,507,916,123,
            345,110,720,917,313,845,426,  9,457,628,410,723,354,895,881,953,677,137,397, 97,
            854,740, 83,216,421, 94,517,479,292,963,376,981,480, 39,257,272,157,  5,316,395,
            787,942,456,242,759,898,576, 67,298,425,894,435,831,241,989,614,987,770,384,692,
            698,765,331,487,251,600,879,342,982,527,736,795,585, 40, 54,901,408,359,577,237,
            605,847,353,968,832,205,838,427,876,959,686,646,835,127,621,892,443,198,988,791,
            466, 23,707,467, 33,670,921,180,991,396,160,436,717,918,  8,374,101,684,727,749]
    bins = bin_it(limits, data)
    bin_print(limits, bins)"
u1n4,python,Binary digits,Algorithms and Data Structures,Algorithms,">>> for i in range(16): print('{0:b}'.format(i))
 
0
1
10
11
100
101
110
111
1000
1001
1010
1011
1100
1101
1110
1111"
3nac,python,Binary search,Algorithms and Data Structures,Algorithms,"def binary_search(l, value):
    low = 0
    high = len(l)-1
    while low <= high: 
        mid = (low+high)//2
        if l[mid] > value: high = mid-1
        elif l[mid] < value: low = mid+1
        else: return mid
    return -1"
gg5w,python,Binary strings,Text Processing,String Manipulation,"s1 = ""A 'string' literal \n""
s2 = 'You may use any of \' or "" as delimiter'
s3 = """"""This text 
   goes over several lines
       up to the closing triple quote"""""""
dfau,python,Bioinformatics/Sequence mutation,Bioinformatics,Sequence Analysis and Mutation,"import random
from collections import Counter
 
def basecount(dna):
    return sorted(Counter(dna).items())
 
def seq_split(dna, n=50):
    return [dna[i: i+n] for i in range(0, len(dna), n)]
 
def seq_pp(dna, n=50):
    for i, part in enumerate(seq_split(dna, n)):
        print(f""{i*n:>5}: {part}"")
    print(""\n  BASECOUNT:"")
    tot = 0
    for base, count in basecount(dna):
        print(f""    {base:>3}: {count}"")
        tot += count
    base, count = 'TOT', tot
    print(f""    {base:>3}= {count}"")
 
def seq_mutate(dna, count=1, kinds=""IDSSSS"", choice=""ATCG"" ):
    mutation = []
    k2txt = dict(I='Insert', D='Delete', S='Substitute')
    for _ in range(count):
        kind = random.choice(kinds)
        index = random.randint(0, len(dna))
        if kind == 'I':    # Insert
            dna = dna[:index] + random.choice(choice) + dna[index:]
        elif kind == 'D' and dna:  # Delete
            dna = dna[:index] + dna[index+1:]
        elif kind == 'S' and dna:  # Substitute
            dna = dna[:index] + random.choice(choice) + dna[index+1:]
        mutation.append((k2txt[kind], index))
    return dna, mutation
 
if __name__ == '__main__':
    length = 250
    print(""SEQUENCE:"")
    sequence = ''.join(random.choices('ACGT', weights=(1, 0.8, .9, 1.1), k=length))
    seq_pp(sequence)
    print(""\n\nMUTATIONS:"")
    mseq, m = seq_mutate(sequence, 10)
    for kind, index in m:
        print(f"" {kind:>10} @{index}"")
    print()
    seq_pp(mseq)"
st2f,python,Bioinformatics/base count,Bioinformatics,Sequence Analysis,"from collections import Counter
 
def basecount(dna):
    return sorted(Counter(dna).items())
 
def seq_split(dna, n=50):
    return [dna[i: i+n] for i in range(0, len(dna), n)]
 
def seq_pp(dna, n=50):
    for i, part in enumerate(seq_split(dna, n)):
        print(f""{i*n:>5}: {part}"")
    print(""\n  BASECOUNT:"")
    tot = 0
    for base, count in basecount(dna):
        print(f""    {base:>3}: {count}"")
        tot += count
    base, count = 'TOT', tot
    print(f""    {base:>3}= {count}"")
 
if __name__ == '__main__':
    print(""SEQUENCE:"")
    sequence = '''\
CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATG\
CTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTG\
AGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGAT\
GGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT\
CGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGG\
TCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA\
TTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTAT\
CGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTG\
TCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGAC\
GACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT'''
    seq_pp(sequence)
 "
cc33,python,Biorhythms,Mathematics,Mathematical Sequences and Series," 
""""""
 
Python implementation of
 
http://rosettacode.org/wiki/Biorhythms
 
""""""
 
from datetime import date, timedelta
from math import floor, sin, pi
 
def biorhythms(birthdate,targetdate):
    """"""
    Print out biorhythm data for targetdate assuming you were
    born on birthdate.
 
    birthdate and targetdata are strings in this format:
 
    YYYY-MM-DD e.g. 1964-12-26
    """"""
 
    # print dates
 
    print(""Born: ""+birthdate+"" Target: ""+targetdate)    
 
    # convert to date types - Python 3.7 or later
 
    birthdate = date.fromisoformat(birthdate)
    targetdate = date.fromisoformat(targetdate)
 
    # days between
 
    days = (targetdate - birthdate).days
 
    print(""Day: ""+str(days))
 
    # cycle logic - mostly from Julia example
 
    cycle_labels = [""Physical"", ""Emotional"", ""Mental""]
    cycle_lengths = [23, 28, 33]
    quadrants = [(""up and rising"", ""peak""), (""up but falling"", ""transition""),
                   (""down and falling"", ""valley""), (""down but rising"", ""transition"")]
 
    for i in range(3):
        label = cycle_labels[i]
        length = cycle_lengths[i]
        position = days % length
        quadrant = int(floor((4 * position) / length))
        percentage = int(round(100 * sin(2 * pi * position / length),0))
        transition_date = targetdate + timedelta(days=floor((quadrant + 1)/4 * length) - position)
        trend, next = quadrants[quadrant]
 
        if percentage > 95:
            description = ""peak""
        elif percentage < -95:
             description = ""valley""
        elif abs(percentage) < 5:
             description = ""critical transition""
        else:
             description = str(percentage)+""% (""+trend+"", next ""+next+"" ""+str(transition_date)+"")""
        print(label+"" day ""+str(position)+"": ""+description)
 
 
biorhythms(""1943-03-09"",""1972-07-11"")
 "
t61m,python,Bitcoin/address validation,Security and Cryptography,Cryptographic Techniques,"from hashlib import sha256
 
digits58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
 
def decode_base58(bc, length):
    n = 0
    for char in bc:
        n = n * 58 + digits58.index(char)
    return n.to_bytes(length, 'big')
def check_bc(bc):
    try:
        bcbytes = decode_base58(bc, 25)
        return bcbytes[-4:] == sha256(sha256(bcbytes[:-4]).digest()).digest()[:4]
    except Exception:
        return False
 
print(check_bc('1AGNa15ZQXAZUgFiqJ3i7Z2DPU2J6hW62i'))
print(check_bc(""17NdbrSGoUotzeGCcMMCqnFkEvLymoou9j""))"
s8yu,python,Bitcoin/public point to address,Security and Cryptography,Cryptographic Techniques,"#!/usr/bin/env python3
 
import binascii
import functools
import hashlib
 
digits58 = b'123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
 
def b58(n):
    return b58(n//58) + digits58[n%58:n%58+1] if n else b''
 
def public_point_to_address(x, y):
    c = b'\x04' + binascii.unhexlify(x) + binascii.unhexlify(y)
    r = hashlib.new('ripemd160')
    r.update(hashlib.sha256(c).digest())
    c = b'\x00' + r.digest()
    d = hashlib.sha256(hashlib.sha256(c).digest()).digest()
    return b58(functools.reduce(lambda n, b: n<<8|b, c + d[:4]))
 
if __name__ == '__main__':
    print(public_point_to_address(
        b'50863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B2352',
        b'2CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6'))"
mrjg,python,Bitmap,Graphics and Visualization,Graphics Programming,"#  See the class definitions and constructors with, e.g. 
getClass(""pixmapIndexed"", package=pixmap)
pixmapIndexed
 
# Image with all one colour
plot(p1 <- pixmapIndexed(matrix(0, nrow=3, ncol=4), col=""red""))
 
# Image with one pixel specified
cols <- rep(""blue"", 12); cols[7] <- ""red""
plot(p2 <- pixmapIndexed(matrix(1:12, nrow=3, ncol=4), col=cols))
 
# Retrieve colour of a pixel
getcol <- function(pm, i, j)
{
   pmcol <- pm@col
   dim(pmcol) <- dim(pm@index)
   pmcol[i,j]   
}
getcol(p2, 3, 4)  #red"
lwcj,python,Bitmap/Bresenham's line algorithm,Graphics and Visualization,Graphics Programming,"def line(self, x0, y0, x1, y1):
    ""Bresenham's line algorithm""
    dx = abs(x1 - x0)
    dy = abs(y1 - y0)
    x, y = x0, y0
    sx = -1 if x0 > x1 else 1
    sy = -1 if y0 > y1 else 1
    if dx > dy:
        err = dx / 2.0
        while x != x1:
            self.set(x, y)
            err -= dy
            if err < 0:
                y += sy
                err += dx
            x += sx
    else:
        err = dy / 2.0
        while y != y1:
            self.set(x, y)
            err -= dx
            if err < 0:
                x += sx
                err += dy
            y += sy        
    self.set(x, y)
Bitmap.line = line
 
bitmap = Bitmap(17,17)
for points in ((1,8,8,16),(8,16,16,8),(16,8,8,1),(8,1,1,8)):
    bitmap.line(*points)
bitmap.chardisplay()
 
'''
The origin, 0,0; is the lower left, with x increasing to the right,
and Y increasing upwards.
 
The chardisplay above produces the following output :
+-----------------+
|        @        |
|       @ @       |
|      @   @      |
|     @     @     |
|    @       @    |
|    @        @   |
|   @          @  |
|  @            @ |
| @              @|
|  @            @ |
|   @          @  |
|    @       @@   |
|     @     @     |
|      @   @      |
|       @ @       |
|        @        |
|                 |
+-----------------+
'''"
broc,python,Bitmap/Bézier curves/Cubic,Graphics and Visualization,Graphics Programming,"def cubicbezier(self, x0, y0, x1, y1, x2, y2, x3, y3, n=20):
    pts = []
    for i in range(n+1):
        t = i / n
        a = (1. - t)**3
        b = 3. * t * (1. - t)**2
        c = 3.0 * t**2 * (1.0 - t)
        d = t**3
 
        x = int(a * x0 + b * x1 + c * x2 + d * x3)
        y = int(a * y0 + b * y1 + c * y2 + d * y3)
        pts.append( (x, y) )
    for i in range(n):
        self.line(pts[i][0], pts[i][1], pts[i+1][0], pts[i+1][1])
Bitmap.cubicbezier = cubicbezier
 
bitmap = Bitmap(17,17)
bitmap.cubicbezier(16,1, 1,4, 3,16, 15,11)
bitmap.chardisplay()
 
 
'''
The origin, 0,0; is the lower left, with x increasing to the right,
and Y increasing upwards.
 
The chardisplay above produces the following output :
+-----------------+
|                 |
|                 |
|                 |
|                 |
|         @@@@    |
|      @@@    @@@ |
|     @           |
|     @           |
|     @           |
|     @           |
|      @          |
|      @          |
|       @         |
|        @        |
|         @@@@    |
|             @@@@|
|                 |
+-----------------+
'''"
1ywn,python,Bitmap/Bézier curves/Quadratic,Graphics and Visualization,Graphics Programming," 
#lang racket
(require racket/draw)
 
(define (draw-line dc p q)
  (match* (p q) [((list x y) (list s t)) (send dc draw-line x y s t)]))
 
(define (draw-lines dc ps)
  (void
   (for/fold ([p0 (first ps)]) ([p (rest ps)])
     (draw-line dc p0 p)
     p)))
 
(define (int t p q)
  (define ((int1 t) x0 x1) (+ (* (- 1 t) x0) (* t x1)))
  (map (int1 t) p q))
 
(define (bezier-points p0 p1 p2)
  (for/list ([t (in-range 0.0 1.0 (/ 1.0 20))])
    (int t (int t p0 p1) (int t p1 p2))))
 
(define bm (make-object bitmap% 17 17))
(define dc (new bitmap-dc% [bitmap bm]))
(send dc set-smoothing 'unsmoothed)
(send dc set-pen ""red"" 1 'solid)
(draw-lines dc (bezier-points '(16 1) '(1 4) '(3 16)))
bm
 "
yhfo,python,Bitmap/Flood fill,Graphics and Visualization,Graphics Programming," 
import Image
def FloodFill( fileName, initNode, targetColor, replaceColor ):
   img = Image.open( fileName )
   pix = img.load()
   xsize, ysize = img.size
   Q = []
   if pix[ initNode[0], initNode[1] ] != targetColor:
      return img
   Q.append( initNode )
   while Q != []:
      node = Q.pop(0)
      if pix[ node[0], node[1] ] == targetColor:
         W = list( node )
         if node[0] + 1 < xsize:
            E = list( [ node[0] + 1, node[1] ] )
         else:
            E = list( node )
      # Move west until color of node does not match targetColor
      while pix[ W[0], W[1] ] == targetColor:
         pix[ W[0], W[1] ] = replaceColor
         if W[1] + 1 < ysize:
            if pix[ W[0], W[1] + 1 ] == targetColor:
               Q.append( [ W[0], W[1] + 1 ] )
         if W[1] - 1 >= 0:
            if pix[ W[0], W[1] - 1 ] == targetColor:
               Q.append( [ W[0], W[1] - 1 ] )
         if W[0] - 1 >= 0:
            W[0] = W[0] - 1
         else:
            break
      # Move east until color of node does not match targetColor
      while pix[ E[0], E[1] ] == targetColor:
         pix[ E[0], E[1] ] = replaceColor
         if E[1] + 1 < ysize:
            if pix[ E[0], E[1] + 1 ] == targetColor:
               Q.append( [ E[0], E[1] + 1 ] )
         if E[1] - 1 >= 0:
            if pix[ E[0], E[1] - 1 ] == targetColor:
               Q.append( [ E[0], E[1] -1 ] )
         if E[0] + 1 < xsize:
            E[0] = E[0] + 1
         else:
            break
      return img
 "
d1vt,python,Bitmap/Histogram,Graphics and Visualization,Graphics Programming,"from PIL import Image
 
# Open the image
image = Image.open(""lena.jpg"")
# Get the width and height of the image
width, height = image.size
# Calculate the amount of pixels
amount = width * height
 
# Total amount of greyscale
total = 0
# B/W image
bw_image = Image.new('L', (width, height), 0)
# Bitmap image
bm_image = Image.new('1', (width, height), 0)
 
for h in range(0, height):
    for w in range(0, width):
        r, g, b = image.getpixel((w, h))
 
        greyscale = int((r + g + b) / 3)
        total += greyscale
 
        bw_image.putpixel((w, h), gray_scale)
 
# The average greyscale
avg = total / amount
 
black = 0
white = 1
 
for h in range(0, height):
    for w in range(0, width):
        v = bw_image.getpixel((w, h))
 
        if v >= avg:
            bm_image.putpixel((w, h), white)
        else:
            bm_image.putpixel((w, h), black)
 
bw_image.show()
bm_image.show()"
zaja,python,Bitmap/Midpoint circle algorithm,Graphics and Visualization,Graphics Programming,"def circle(self, x0, y0, radius, colour=black):
    f = 1 - radius
    ddf_x = 1
    ddf_y = -2 * radius
    x = 0
    y = radius
    self.set(x0, y0 + radius, colour)
    self.set(x0, y0 - radius, colour)
    self.set(x0 + radius, y0, colour)
    self.set(x0 - radius, y0, colour)
 
    while x < y:
        if f >= 0: 
            y -= 1
            ddf_y += 2
            f += ddf_y
        x += 1
        ddf_x += 2
        f += ddf_x    
        self.set(x0 + x, y0 + y, colour)
        self.set(x0 - x, y0 + y, colour)
        self.set(x0 + x, y0 - y, colour)
        self.set(x0 - x, y0 - y, colour)
        self.set(x0 + y, y0 + x, colour)
        self.set(x0 - y, y0 + x, colour)
        self.set(x0 + y, y0 - x, colour)
        self.set(x0 - y, y0 - x, colour)
Bitmap.circle = circle
 
bitmap = Bitmap(25,25)
bitmap.circle(x0=12, y0=12, radius=12)
bitmap.chardisplay()
 
'''
The origin, 0,0; is the lower left, with x increasing to the right,
and Y increasing upwards.
 
The program above produces the following display :
 
+-------------------------+
|         @@@@@@@         |
|       @@       @@       |
|     @@           @@     |
|    @               @    |
|   @                 @   |
|  @                   @  |
|  @                   @  |
| @                     @ |
| @                     @ |
|@                       @|
|@                       @|
|@                       @|
|@                       @|
|@                       @|
|@                       @|
|@                       @|
| @                     @ |
| @                     @ |
|  @                   @  |
|  @                   @  |
|   @                 @   |
|    @               @    |
|     @@           @@     |
|       @@       @@       |
|         @@@@@@@         |
+-------------------------+
'''
 "
on1u,python,Bitmap/PPM conversion through a pipe,Systems Programming and File I/O,File Operations," 
""""""
Adapted from https://stackoverflow.com/questions/26937143/ppm-to-jpeg-jpg-conversion-for-python-3-4-1
Requires pillow-5.3.0 with Python 3.7.1 32-bit on Windows.
Sample ppm graphics files from http://www.cs.cornell.edu/courses/cs664/2003fa/images/
""""""
 
from PIL import Image
 
im = Image.open(""boxes_1.ppm"")
im.save(""boxes_1.jpg"")
 "
aqa3,python,Bitmap/Read a PPM file,Graphics and Visualization,Graphics Programming,"# With help from http://netpbm.sourceforge.net/doc/ppm.html
 
# String masquerading as ppm file (version P3)
import io
 
ppmtxt = '''P3
# feep.ppm
4 4
15
 0  0  0    0  0  0    0  0  0   15  0 15
 0  0  0    0 15  7    0  0  0    0  0  0
 0  0  0    0  0  0    0 15  7    0  0  0
15  0 15    0  0  0    0  0  0    0  0  0
'''
 
 
def tokenize(f):
    for line in f:
        if line[0] != '#':
            for t in line.split():
                yield t
 
def ppmp3tobitmap(f):
    t = tokenize(f)
    nexttoken = lambda : next(t)
    assert 'P3' == nexttoken(), 'Wrong filetype'
    width, height, maxval = (int(nexttoken()) for i in range(3))
    bitmap = Bitmap(width, height, Colour(0, 0, 0))
    for h in range(height-1, -1, -1):
        for w in range(0, width):
            bitmap.set(w, h, Colour( *(int(nexttoken()) for i in range(3))))
 
    return bitmap
 
print('Original Colour PPM file')
print(ppmtxt)
ppmfile = io.StringIO(ppmtxt)
bitmap = ppmp3tobitmap(ppmfile)
print('Grey PPM:')
bitmap.togreyscale()
ppmfileout = io.StringIO('')
bitmap.writeppmp3(ppmfileout)
print(ppmfileout.getvalue())
 
 
'''
The print statements above produce the following output:
 
Original Colour PPM file
P3
# feep.ppm
4 4
15
 0  0  0    0  0  0    0  0  0   15  0 15
 0  0  0    0 15  7    0  0  0    0  0  0
 0  0  0    0  0  0    0 15  7    0  0  0
15  0 15    0  0  0    0  0  0    0  0  0
 
Grey PPM:
P3
# generated from Bitmap.writeppmp3
4 4
11
    0  0  0    0  0  0    0  0  0    4  4  4
    0  0  0   11 11 11    0  0  0    0  0  0
    0  0  0    0  0  0   11 11 11    0  0  0
    4  4  4    0  0  0    0  0  0    0  0  0
 
'''"
1g01,python,Bitmap/Read an image through a pipe,Systems Programming and File I/O,File Operations," 
""""""
Adapted from https://stackoverflow.com/questions/26937143/ppm-to-jpeg-jpg-conversion-for-python-3-4-1
Requires pillow-5.3.0 with Python 3.7.1 32-bit on Windows.
Sample ppm graphics files from http://www.cs.cornell.edu/courses/cs664/2003fa/images/
""""""
 
from PIL import Image
 
# boxes_1.jpg is the jpg version of boxes_1.ppm
 
im = Image.open(""boxes_1.jpg"")
im.save(""boxes_1v2.ppm"")
 "
gprg,python,Bitmap/Write a PPM file,Graphics and Visualization,Graphics Programming," 
# String masquerading as ppm file (version P3)
import io
ppmfileout = io.StringIO('')
 
def writeppmp3(self, f):
    self.writeppm(f, ppmformat='P3')
 
def writeppm(self, f, ppmformat='P6'):
    assert ppmformat in ['P3', 'P6'], 'Format wrong'
    magic = ppmformat + '\n'
    comment = '# generated from Bitmap.writeppm\n'
    maxval = max(max(max(bit) for bit in row) for row in self.map)
    assert ppmformat == 'P3' or 0 <= maxval < 256, 'R,G,B must fit in a byte'
    if ppmformat == 'P6':
        fwrite = lambda s: f.write(bytes(s, 'UTF-8'))
        maxval = 255
    else:
        fwrite = f.write
        numsize=len(str(maxval))
    fwrite(magic)
    fwrite(comment)
    fwrite('%i %i\n%i\n' % (self.width, self.height, maxval))
    for h in range(self.height-1, -1, -1):
        for w in range(self.width):
            r, g, b = self.get(w, h)
            if ppmformat == 'P3':
                fwrite('   %*i %*i %*i' % (numsize, r, numsize, g, numsize, b))
            else:
                fwrite('%c%c%c' % (r, g, b))
        if ppmformat == 'P3':
            fwrite('\n')
 
Bitmap.writeppmp3 = writeppmp3
Bitmap.writeppm = writeppm
 
# Draw something simple
bitmap = Bitmap(4, 4, black)
bitmap.fillrect(1, 0, 1, 2, white)
bitmap.set(3, 3, Colour(127, 0, 63))
# Write to the open 'file' handle
bitmap.writeppmp3(ppmfileout)
# Whats in the generated PPM file
print(ppmfileout.getvalue())
 
'''
The print statement above produces the following output :
 
P3
# generated from Bitmap.writeppmp3
4 4
255
     0   0   0     0   0   0     0   0   0   127   0  63
     0   0   0     0   0   0     0   0   0     0   0   0
     0   0   0   255 255 255     0   0   0     0   0   0
     0   0   0   255 255 255     0   0   0     0   0   0
 
'''
 
# Write a P6 file
ppmfileout = open('tmp.ppm', 'wb')
bitmap.writeppm(ppmfileout)
ppmfileout.close()
 "
sdc7,python,Bitwise IO,Systems Programming and File I/O,File Operations,"class BitWriter(object):
    def __init__(self, f):
        self.accumulator = 0
        self.bcount = 0
        self.out = f
 
    def __enter__(self):
        return self
 
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.flush()
 
    def __del__(self):
        try:
            self.flush()
        except ValueError:   # I/O operation on closed file.
            pass
 
    def _writebit(self, bit):
        if self.bcount == 8:
            self.flush()
        if bit > 0:
            self.accumulator |= 1 << 7-self.bcount
        self.bcount += 1
 
    def writebits(self, bits, n):
        while n > 0:
            self._writebit(bits & 1 << n-1)
            n -= 1
 
    def flush(self):
        self.out.write(bytearray([self.accumulator]))
        self.accumulator = 0
        self.bcount = 0
 
 
class BitReader(object):
    def __init__(self, f):
        self.input = f
        self.accumulator = 0
        self.bcount = 0
        self.read = 0
 
    def __enter__(self):
        return self
 
    def __exit__(self, exc_type, exc_val, exc_tb):
        pass
 
    def _readbit(self):
        if not self.bcount:
            a = self.input.read(1)
            if a:
                self.accumulator = ord(a)
            self.bcount = 8
            self.read = len(a)
        rv = (self.accumulator & (1 << self.bcount-1)) >> self.bcount-1
        self.bcount -= 1
        return rv
 
    def readbits(self, n):
        v = 0
        while n > 0:
            v = (v << 1) | self._readbit()
            n -= 1
        return v
 
if __name__ == '__main__':
    import os
    import sys
    # Determine this module's name from it's file name and import it.
    module_name = os.path.splitext(os.path.basename(__file__))[0]
    bitio = __import__(module_name)
 
    with open('bitio_test.dat', 'wb') as outfile:
        with bitio.BitWriter(outfile) as writer:
            chars = '12345abcde'
            for ch in chars:
                writer.writebits(ord(ch), 7)
 
    with open('bitio_test.dat', 'rb') as infile:
        with bitio.BitReader(infile) as reader:
            chars = []
            while True:
                x = reader.readbits(7)
                if not reader.read:  # End-of-file?
                    break
                chars.append(chr(x))
            print(''.join(chars))
 "
tzjp,python,Bitwise operations,Programming Concepts,Fundamentals,"def bitwise_built_ins(width, a, b):
    mask = (1 << width) - 1
    print(f""""""\
    AND:     0b{a :0{width}b} 
           & 0b{b :0{width}b} 
           = 0b{(a & b) & mask :0{width}b}
 
    OR:      0b{a :0{width}b} 
           | 0b{b :0{width}b} 
           = 0b{(a | b) & mask :0{width}b}
 
    XOR:     0b{a :0{width}b} 
           ^ 0b{b :0{width}b} 
           = 0b{(a ^ b) & mask :0{width}b}
 
    NOT:   ~ 0b{a :0{width}b} 
           = 0b{(~a) & mask :0{width}b}
 
    SHIFTS
 
      RIGHT:   0b{a :0{width}b} >> 1
             = 0b{(a >> 1) & mask :0{width}b}      
 
      LEFT:    0b{a :0{width}b} << 1
             = 0b{(a << 1) & mask :0{width}b}      
"""""")
 
def rotr(width, a, n):
    ""Rotate a, n times to the right""
    if n < 0:
        return rotl(width, a, -n)
    elif n == 0:
        return a
    else:
        mask = (1 << width) - 1
        a, n = a & mask, n % width
        return ((a >> n)    # top moved down
                | ((a & ((1 << n) - 1))   # Bottom masked...
                   << (width - n)))  # ... then moved up    
 
def rotl(width, a, n):
    ""Rotate a, n times to the left""
    if n < 0:
        return rotr(width, a, -n)
    elif n == 0:
        return a
    else:
        mask = (1 << width) - 1
        a, n = a & mask, n % width
        return (((a << n) & mask)      # bottom shifted up and masked
                | (a >> (width - n)))  # Top moved down  
 
def asr(width, a, n):
    ""Arithmetic shift a, n times to the right. (sign preserving).""
    mask, top_bit_mask = ((1 << width) - 1), 1 << (width - 1)
    if n < 0:
        return  (a << -n) & mask
    elif n == 0:
        return a
    elif n >= width:
        return mask if a & top_bit_mask else 0
    else:
        a = a & mask
        if a & top_bit_mask:    # Sign bit set?
            signs = (1 << n) - 1
            return a >> n | (signs << width - n)
        else:
            return a >> n
 
 
def helper_funcs(width, a):
    mask, top_bit_mask = ((1 << width) - 1), 1 << (width - 1)
    aa = a | top_bit_mask  # a with top bit set
    print(f""""""\
    ROTATIONS
 
      RIGHT:   rotr({width}, 0b{a :0{width}b}, 1)
               =       0b{rotr(width, a, 1) :0{width}b}      
               rotr({width}, 0b{a :0{width}b}, 2)
               =       0b{rotr(width, a, 2) :0{width}b}      
               rotr({width}, 0b{a :0{width}b}, 4)
               =       0b{rotr(width, a, 4) :0{width}b}      
 
      LEFT:    rotl({width}, 0b{a :0{width}b}, 1)
               =       0b{rotl(width, a, 1) :0{width}b}      
               rotl({width}, 0b{a :0{width}b}, 2)
               =       0b{rotl(width, a, 2) :0{width}b}      
               rotl({width}, 0b{a :0{width}b}, 4)
               =       0b{rotl(width, a, 4) :0{width}b}    
 
    SIGN-EXTENDING ARITHMETIC SHIFT RIGHT
 
               asr({width}, 0b{a :0{width}b}, 1)
               =      0b{asr(width, a, 1) :0{width}b}      
               asr({width}, 0b{aa :0{width}b}, 1)
               =      0b{asr(width, aa, 1) :0{width}b}      
               asr({width}, 0b{a :0{width}b}, 2)
               =      0b{asr(width, a, 2) :0{width}b}      
               asr({width}, 0b{aa :0{width}b}, 2)
               =      0b{asr(width, aa, 2) :0{width}b}      
               asr({width}, 0b{a :0{width}b}, 4)
               =      0b{asr(width, a, 4) :0{width}b} 
               asr({width}, 0b{aa :0{width}b}, 4)
               =      0b{asr(width, aa, 4) :0{width}b} 
"""""")
 
if __name__ == '__main__':
    bitwise_built_ins(8, 27, 125)
    helper_funcs(8, 27)"
pktw,python,Boolean values,Programming Concepts,Fundamentals,">>> True
True
>>> not True
False
>>> # As numbers
>>> False + 0
0
>>> True + 0
1
>>> False + 0j
0j
>>> True * 3.141
3.141
>>> # Numbers as booleans
>>> not 0
True
>>> not not 0
False
>>> not 1234
False
>>> bool(0.0)
False
>>> bool(0j)
False
>>> bool(1+2j)
True
>>> # Collections as booleans
>>> bool([])
False
>>> bool([None])
True
>>> 'I contain something' if (None,) else 'I am empty'
'I contain something'
>>> bool({})
False
>>> bool("""")
False
>>> bool(""False"")
True"
b3x6,python,Box the compass,Puzzles and Games,Logic and Mathematical Puzzles,"majors   = 'north east south west'.split()
majors   *= 2 # no need for modulo later
quarter1 = 'N,N by E,N-NE,NE by N,NE,NE by E,E-NE,E by N'.split(',')
quarter2 = [p.replace('NE','EN') for p in quarter1]
 
def degrees2compasspoint(d):
    d = (d % 360) + 360/64
    majorindex, minor = divmod(d, 90.)
    majorindex = int(majorindex)
    minorindex  = int( (minor*4) // 45 )
    p1, p2 = majors[majorindex: majorindex+2]
    if p1 in {'north', 'south'}:
        q = quarter1
    else:
        q = quarter2
    return q[minorindex].replace('N', p1).replace('E', p2).capitalize()
 
if __name__ == '__main__':
    for i in range(33):
        d = i * 11.25
        m = i % 3
        if   m == 1: d += 5.62
        elif m == 2: d -= 5.62
        n = i % 32 + 1
        print( '%2i %-18s %7.2f°' % (n, degrees2compasspoint(d), d) )"
9s5e,python,Brace expansion,Programming Concepts,Fundamentals,"def getitem(s, depth=0):
    out = [""""]
    while s:
        c = s[0]
        if depth and (c == ',' or c == '}'):
            return out,s
        if c == '{':
            x = getgroup(s[1:], depth+1)
            if x:
                out,s = [a+b for a in out for b in x[0]], x[1]
                continue
        if c == '\\' and len(s) > 1:
            s, c = s[1:], c + s[1]
 
        out, s = [a+c for a in out], s[1:]
 
    return out,s
 
def getgroup(s, depth):
    out, comma = [], False
    while s:
        g,s = getitem(s, depth)
        if not s: break
        out += g
 
        if s[0] == '}':
            if comma: return out, s[1:]
            return ['{' + a + '}' for a in out], s[1:]
 
        if s[0] == ',':
            comma,s = True, s[1:]
 
    return None
 
# stolen cowbells from Raku example
for s in '''~/{Downloads,Pictures}/*.{jpg,gif,png}
It{{em,alic}iz,erat}e{d,}, please.
{,{,gotta have{ ,\, again\, }}more }cowbell!
{}} some }{,{\\\\{ edge, edge} \,}{ cases, {here} \\\\\\\\\}'''.split('\n'):
    print ""\n\t"".join([s] + getitem(s)[0]) + ""\n"""
kylk,python,Brazilian numbers,Mathematics,Number Theory,"'''Brazilian numbers'''
 
from itertools import count, islice
 
 
# isBrazil :: Int -> Bool
def isBrazil(n):
    '''True if n is a Brazilian number,
       in the sense of OEIS:A125134.
    '''
    return 7 <= n and (
        0 == n % 2 or any(
            map(monoDigit(n), range(2, n - 1))
        )
    )
 
 
# monoDigit :: Int -> Int -> Bool
def monoDigit(n):
    '''True if all the digits of n,
       in the given base, are the same.
    '''
    def go(base):
        def g(b, n):
            (q, d) = divmod(n, b)
 
            def p(qr):
                return d != qr[1] or 0 == qr[0]
 
            def f(qr):
                return divmod(qr[0], b)
            return d == until(p)(f)(
                (q, d)
            )[1]
        return g(base, n)
    return go
 
 
# -------------------------- TEST --------------------------
# main :: IO ()
def main():
    '''First 20 members each of:
        OEIS:A125134
        OEIS:A257521
        OEIS:A085104
    '''
    for kxs in ([
            (' ', count(1)),
            (' odd ', count(1, 2)),
            (' prime ', primes())
    ]):
        print(
            'First 20' + kxs[0] + 'Brazilians:\n' +
            showList(take(20)(filter(isBrazil, kxs[1]))) + '\n'
        )
 
 
# ------------------- GENERIC FUNCTIONS --------------------
 
# primes :: [Int]
def primes():
    ''' Non finite sequence of prime numbers.
    '''
    n = 2
    dct = {}
    while True:
        if n in dct:
            for p in dct[n]:
                dct.setdefault(n + p, []).append(p)
            del dct[n]
        else:
            yield n
            dct[n * n] = [n]
        n = 1 + n
 
 
# showList :: [a] -> String
def showList(xs):
    '''Stringification of a list.'''
    return '[' + ','.join(str(x) for x in xs) + ']'
 
 
# take :: Int -> [a] -> [a]
# take :: Int -> String -> String
def take(n):
    '''The prefix of xs of length n,
       or xs itself if n > length xs.
    '''
    def go(xs):
        return (
            xs[0:n]
            if isinstance(xs, (list, tuple))
            else list(islice(xs, n))
        )
    return go
 
 
# until :: (a -> Bool) -> (a -> a) -> a -> a
def until(p):
    '''The result of repeatedly applying f until p holds.
       The initial seed value is x.
    '''
    def go(f):
        def g(x):
            v = x
            while not p(v):
                v = f(v)
            return v
        return g
    return go
 
 
# MAIN ---
if __name__ == '__main__':
    main()"
72td,python,Break OO privacy,Programming Concepts,Advanced Concepts,">>> class MyClassName:
	__private = 123
	non_private = __private * 2
 
 
>>> mine = MyClassName()
>>> mine.non_private
246
>>> mine.__private
Traceback (most recent call last):
  File ""<pyshell#23>"", line 1, in <module>
    mine.__private
AttributeError: 'MyClassName' object has no attribute '__private'
>>> mine._MyClassName__private
123
>>> "
gt2t,python,Brilliant numbers,Mathematics,Number Theory,"from primesieve.numpy import primes
from math import isqrt
import numpy as np
 
max_order = 9
blocks = [primes(10**n, 10**(n + 1)) for n in range(max_order)]
 
def smallest_brilliant(lb):
    pos = 1
    root = isqrt(lb)
 
    for blk in blocks:
        n = len(blk)
        if blk[-1]*blk[-1] < lb:
            pos += n*(n + 1)//2
            continue
 
        i = np.searchsorted(blk, root, 'left')
        i += blk[i]*blk[i] < lb
 
        if not i:
            return blk[0]*blk[0], pos
 
        p = blk[:i + 1]
        q = (lb - 1)//p
        idx = np.searchsorted(blk, q, 'right')
 
        sel = idx < n
        p, idx = p[sel], idx[sel]
        q = blk[idx]
 
        sel = q >= p
        p, q, idx = p[sel], q[sel], idx[sel]
 
        pos += np.sum(idx - np.arange(len(idx)))
        return np.min(p*q), pos
 
res = []
p = 0
for i in range(100):
    p, _ = smallest_brilliant(p + 1)
    res.append(p)
 
print(f'first 100 are {res}')
 
for i in range(max_order*2):
    thresh = 10**i
    p, pos = smallest_brilliant(thresh)
    print(f'Above 10^{i:2d}: {p:20d} at #{pos}')"
tazi,python,Brownian tree,Graphics and Visualization,Graphics Programming,"import pygame, sys, os
from pygame.locals import *
from random import randint
pygame.init()
 
MAXSPEED = 15
SIZE = 3
COLOR = (45, 90, 45)
WINDOWSIZE = 400
TIMETICK = 1
MAXPART = 50
 
freeParticles = pygame.sprite.Group()
tree = pygame.sprite.Group()
 
window = pygame.display.set_mode((WINDOWSIZE, WINDOWSIZE))
pygame.display.set_caption(""Brownian Tree"")
 
screen = pygame.display.get_surface()
 
 
class Particle(pygame.sprite.Sprite):
    def __init__(self, vector, location, surface):
        pygame.sprite.Sprite.__init__(self)
        self.vector = vector
        self.surface = surface
        self.accelerate(vector)
        self.add(freeParticles)
        self.rect = pygame.Rect(location[0], location[1], SIZE, SIZE)
        self.surface.fill(COLOR, self.rect)
 
    def onEdge(self):
        if self.rect.left <= 0:
            self.vector = (abs(self.vector[0]), self.vector[1])
        elif self.rect.top <= 0:
            self.vector = (self.vector[0], abs(self.vector[1]))
        elif self.rect.right >= WINDOWSIZE:
            self.vector = (-abs(self.vector[0]), self.vector[1])
        elif self.rect.bottom >= WINDOWSIZE:
            self.vector = (self.vector[0], -abs(self.vector[1]))
 
    def update(self):
        if freeParticles in self.groups():
            self.surface.fill((0,0,0), self.rect)
            self.remove(freeParticles)
            if pygame.sprite.spritecollideany(self, freeParticles):
                self.accelerate((randint(-MAXSPEED, MAXSPEED), 
                                 randint(-MAXSPEED, MAXSPEED)))
                self.add(freeParticles)
            elif pygame.sprite.spritecollideany(self, tree):
                self.stop()
            else:
                self.add(freeParticles)
 
            self.onEdge()
 
            if (self.vector == (0,0)) and tree not in self.groups():
                self.accelerate((randint(-MAXSPEED, MAXSPEED), 
                                 randint(-MAXSPEED, MAXSPEED)))
            self.rect.move_ip(self.vector[0], self.vector[1])
        self.surface.fill(COLOR, self.rect)
 
    def stop(self):
        self.vector = (0,0)
        self.remove(freeParticles)
        self.add(tree)
 
    def accelerate(self, vector):
        self.vector = vector
 
NEW = USEREVENT + 1
TICK = USEREVENT + 2
 
pygame.time.set_timer(NEW, 50)
pygame.time.set_timer(TICK, TIMETICK)
 
 
def input(events):
    for event in events:
        if event.type == QUIT:
            sys.exit(0)
        elif event.type == NEW and (len(freeParticles) < MAXPART):
            Particle((randint(-MAXSPEED,MAXSPEED),
                      randint(-MAXSPEED,MAXSPEED)),
                     (randint(0, WINDOWSIZE), randint(0, WINDOWSIZE)), 
                     screen)
        elif event.type == TICK:
            freeParticles.update()
 
 
half = WINDOWSIZE/2
tenth = WINDOWSIZE/10
 
root = Particle((0,0),
                (randint(half-tenth, half+tenth), 
                 randint(half-tenth, half+tenth)), screen)
root.stop()
 
while True:
    input(pygame.event.get())
    pygame.display.flip()"
qs8i,python,Bulls and cows,Puzzles and Games,Game Development,"'''
 Bulls and cows. A game pre-dating, and similar to, Mastermind.
'''
 
import random
 
digits = '123456789'
size = 4
chosen = ''.join(random.sample(digits,size))
#print chosen # Debug
print '''I have chosen a number from %s unique digits from 1 to 9 arranged in a random order.
You need to input a %i digit, unique digit number as a guess at what I have chosen''' % (size, size)
guesses = 0
while True:
    guesses += 1
    while True:
        # get a good guess
        guess = raw_input('\nNext guess [%i]: ' % guesses).strip()
        if len(guess) == size and \
           all(char in digits for char in guess) \
           and len(set(guess)) == size:
            break
        print ""Problem, try again. You need to enter %i unique digits from 1 to 9"" % size
    if guess == chosen:
        print '\nCongratulations you guessed correctly in',guesses,'attempts'
        break
    bulls = cows = 0
    for i in range(size):
        if guess[i] == chosen[i]:
            bulls += 1
        elif guess[i] in chosen:
            cows += 1
    print '  %i Bulls\n  %i Cows' % (bulls, cows)"
nsmy,python,Bulls and cows/Player,Puzzles and Games,Puzzle Solving Algorithms,"from itertools import permutations
from random import shuffle
 
try:
    raw_input
except:
    raw_input = input
try:
    from itertools import izip
except:
    izip = zip
 
digits = '123456789'
size = 4
 
def parse_score(score):
    score = score.strip().split(',')
    return tuple(int(s.strip()) for s in score)
 
def scorecalc(guess, chosen):
    bulls = cows = 0
    for g,c in izip(guess, chosen):
        if g == c:
            bulls += 1
        elif g in chosen:
            cows += 1
    return bulls, cows
 
choices = list(permutations(digits, size))
shuffle(choices)
answers = []
scores  = []
 
print (""Playing Bulls & Cows with %i unique digits\n"" % size)
 
while True:
    ans = choices[0]
    answers.append(ans)
    #print (""(Narrowed to %i possibilities)"" % len(choices))
    score = raw_input(""Guess %2i is %*s. Answer (Bulls, cows)? ""
                      % (len(answers), size, ''.join(ans)))
    score = parse_score(score)
    scores.append(score)
    #print(""Bulls: %i, Cows: %i"" % score)
    found =  score == (size, 0)
    if found:
        print (""Ye-haw!"")
        break
    choices = [c for c in choices if scorecalc(c, ans) == score]
    if not choices:
        print (""Bad scoring? nothing fits those scores you gave:"")
        print ('  ' +
               '\n  '.join(""%s -> %s"" % (''.join(an),sc)
                           for an,sc in izip(answers, scores)))
        break"
z61u,python,Burrows–Wheeler transform,Algorithms and Data Structures,Algorithms," 
def bwt(s):
    """"""Apply Burrows-Wheeler transform to input string.""""""
    assert ""\002"" not in s and ""\003"" not in s, ""Input string cannot contain STX and ETX characters""
    s = ""\002"" + s + ""\003""  # Add start and end of text marker
    table = sorted(s[i:] + s[:i] for i in range(len(s)))  # Table of rotations of string
    last_column = [row[-1:] for row in table]  # Last characters of each row
    return """".join(last_column)  # Convert list of characters into string
 
 
def ibwt(r):
    """"""Apply inverse Burrows-Wheeler transform.""""""
    table = [""""] * len(r)  # Make empty table
    for i in range(len(r)):
        table = sorted(r[i] + table[i] for i in range(len(r)))  # Add a column of r
    s = [row for row in table if row.endswith(""\003"")][0]  # Find the correct row (ending in ETX)
    return s.rstrip(""\003"").strip(""\002"")  # Get rid of start and end markers
 "
h3pd,python,CRC-32,Security and Cryptography,Cryptographic Techniques,">>> s = 'The quick brown fox jumps over the lazy dog'
>>> import zlib
>>> hex(zlib.crc32(s))
'0x414fa339'
 
>>> import binascii
>>> hex(binascii.crc32(s))
'0x414fa339'"
l6z2,python,CSV data manipulation,Databases and Data Management,Data Serialization and Formats,"import fileinput
 
changerow, changecolumn, changevalue = 2, 4, '""Spam""'
 
with fileinput.input('csv_data_manipulation.csv', inplace=True) as f:
    for line in f:
        if fileinput.filelineno() == changerow:
            fields = line.rstrip().split(',')
            fields[changecolumn-1] = changevalue
            line = ','.join(fields) + '\n'
        print(line, end='')"
92ie,python,CSV to HTML translation,Text Processing,Parsing and Tokenization,"csvtxt = '''\
Character,Speech
The multitude,The messiah! Show us the messiah!
Brians mother,<angry>Now you listen here! He's not the messiah; he's a very naughty boy! Now go away!</angry>
The multitude,Who are you?
Brians mother,I'm his mother; that's who!
The multitude,Behold his mother! Behold his mother!\
'''
 
from cgi import escape
 
def _row2tr(row, attr=None):
    cols = escape(row).split(',')
    return ('<TR>'
            + ''.join('<TD>%s</TD>' % data for data in cols)
            + '</TR>')
 
def csv2html(txt):
    htmltxt = '<TABLE summary=""csv2html program output"">\n'
    for rownum, row in enumerate(txt.split('\n')):
        htmlrow = _row2tr(row)
        htmlrow = '  <TBODY>%s</TBODY>\n' % htmlrow
        htmltxt += htmlrow
    htmltxt += '</TABLE>\n'
    return htmltxt
 
htmltxt = csv2html(csvtxt)
print(htmltxt)"
cbrw,python,CUSIP,Mathematics,Number Theory,"#!/usr/bin/env python3
 
import math
 
def cusip_check(cusip):
    if len(cusip) != 9:
        raise ValueError('CUSIP must be 9 characters')
 
    cusip = cusip.upper()
    total = 0
    for i in range(8):
        c = cusip[i]
        if c.isdigit():
            v = int(c)
        elif c.isalpha():
            p = ord(c) - ord('A') + 1
            v = p + 9
        elif c == '*':
            v = 36
        elif c == '@':
            v = 37
        elif c == '#':
            v = 38
 
        if i % 2 != 0:
            v *= 2
 
        total += int(v / 10) + v % 10
    check = (10 - (total % 10)) % 10
    return str(check) == cusip[-1]
 
if __name__ == '__main__':
    codes = [
            '037833100',
            '17275R102',
            '38259P508',
            '594918104',
            '68389X106',
            '68389X105'
            ]
    for code in codes:
        print(f'{code} -> {cusip_check(code)}')
 "
362p,python,Caesar cipher,Security and Cryptography,Cryptographic Techniques,"def caesar(s, k, decode = False):
	if decode: k = 26 - k
	return """".join([chr((ord(i) - 65 + k) % 26 + 65)
				for i in s.upper()
				if ord(i) >= 65 and ord(i) <= 90 ])
 
msg = ""The quick brown fox jumped over the lazy dogs""
print msg
enc = caesar(msg, 11)
print enc
print caesar(enc, 11, decode = True)"
5abs,python,Calculating the value of e,Mathematics,Numerical Methods,"import math
#Implementation of Brother's formula
e0 = 0
e = 2
n = 0
fact = 1
while(e-e0 > 1e-15):
	e0 = e
	n += 1
	fact *= 2*n*(2*n+1)
	e += (2.*n+2)/fact
 
print ""Computed e = ""+str(e)
print ""Real e = ""+str(math.e)
print ""Error = ""+str(math.e-e)
print ""Number of iterations = ""+str(n)"
ketk,python,Calendar,Miscellaneous Topics,Time and Date Manipulation,">>> import calendar
>>> help(calendar.prcal)
Help on method pryear in module calendar:
 
pryear(self, theyear, w=0, l=0, c=6, m=3) method of calendar.TextCalendar instance
    Print a years calendar.
 
>>> calendar.prcal(1969)
                                  1969
 
      January                   February                   March
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
       1  2  3  4  5                      1  2                      1  2
 6  7  8  9 10 11 12       3  4  5  6  7  8  9       3  4  5  6  7  8  9
13 14 15 16 17 18 19      10 11 12 13 14 15 16      10 11 12 13 14 15 16
20 21 22 23 24 25 26      17 18 19 20 21 22 23      17 18 19 20 21 22 23
27 28 29 30 31            24 25 26 27 28            24 25 26 27 28 29 30
                                                    31
 
       April                      May                       June
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
    1  2  3  4  5  6                1  2  3  4                         1
 7  8  9 10 11 12 13       5  6  7  8  9 10 11       2  3  4  5  6  7  8
14 15 16 17 18 19 20      12 13 14 15 16 17 18       9 10 11 12 13 14 15
21 22 23 24 25 26 27      19 20 21 22 23 24 25      16 17 18 19 20 21 22
28 29 30                  26 27 28 29 30 31         23 24 25 26 27 28 29
                                                    30
 
        July                     August                  September
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
    1  2  3  4  5  6                   1  2  3       1  2  3  4  5  6  7
 7  8  9 10 11 12 13       4  5  6  7  8  9 10       8  9 10 11 12 13 14
14 15 16 17 18 19 20      11 12 13 14 15 16 17      15 16 17 18 19 20 21
21 22 23 24 25 26 27      18 19 20 21 22 23 24      22 23 24 25 26 27 28
28 29 30 31               25 26 27 28 29 30 31      29 30
 
      October                   November                  December
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
       1  2  3  4  5                      1  2       1  2  3  4  5  6  7
 6  7  8  9 10 11 12       3  4  5  6  7  8  9       8  9 10 11 12 13 14
13 14 15 16 17 18 19      10 11 12 13 14 15 16      15 16 17 18 19 20 21
20 21 22 23 24 25 26      17 18 19 20 21 22 23      22 23 24 25 26 27 28
27 28 29 30 31            24 25 26 27 28 29 30      29 30 31"
hofm,python,Calkin-Wilf sequence,Mathematics,Mathematical Sequences and Series,"from fractions import Fraction
from math import floor
from itertools import islice, groupby
 
 
def cw():
    a = Fraction(1)
    while True:
        yield a
        a = 1 / (2 * floor(a) + 1 - a)
 
def r2cf(rational):
    num, den = rational.numerator, rational.denominator
    while den:
        num, (digit, den) = den, divmod(num, den)
        yield digit
 
def get_term_num(rational):
    ans, dig, pwr = 0, 1, 0
    for n in r2cf(rational):
        for _ in range(n):
            ans |= dig << pwr
            pwr += 1
        dig ^= 1
    return ans
 
 
if __name__ == '__main__':
    print('TERMS 1..20: ', ', '.join(str(x) for x in islice(cw(), 20)))
    x = Fraction(83116, 51639)
    print(f""\n{x} is the {get_term_num(x):_}'th term."")"
dk3a,python,Call a foreign-language function,Programming Concepts,Fundamentals,"import ctypes
libc = ctypes.CDLL(""/lib/libc.so.6"")
libc.strcmp(""abc"", ""def"")     # -1
libc.strcmp(""hello"", ""hello"") #  0"
1twf,python,Call a function,Programming Concepts,Fundamentals,"def no_args():
    pass
# call
no_args()
 
def fixed_args(x, y):
    print('x=%r, y=%r' % (x, y))
# call
fixed_args(1, 2)        # x=1, y=2
 
## Can also called them using the parameter names, in either order:
fixed_args(y=2, x=1)
 
## Can also ""apply"" fixed_args() to a sequence:
myargs=(1,2) # tuple
fixed_args(*myargs)
 
def opt_args(x=1):
    print(x)
# calls
opt_args()              # 1
opt_args(3.141)         # 3.141
 
def var_args(*v):
    print(v)
# calls	
var_args(1, 2, 3)       # (1, 2, 3)
var_args(1, (2,3))      # (1, (2, 3))
var_args()              # ()
 
## Named arguments
fixed_args(y=2, x=1)    # x=1, y=2
 
## As a statement
if 1:
    no_args()
 
## First-class within an expression
assert no_args() is None
 
def return_something():
    return 1
x = return_something()
 
def is_builtin(x):
	print(x.__name__ in dir(__builtins__))
# calls
is_builtin(pow)         # True
is_builtin(is_builtin)  # False
 
# Very liberal function definition
 
def takes_anything(*args, **kwargs):
    for each in args:
        print(each)
    for key, value in sorted(kwargs.items()):
        print(""%s:%s"" % (key, value))
    # Passing those to another, wrapped, function:
    wrapped_fn(*args, **kwargs)
    # (Function being wrapped can have any parameter list
    # ... that doesn't have to match this prototype)
 
## A subroutine is merely a function that has no explicit
## return statement and will return None.
 
## Python uses ""Call by Object Reference"".
## See, for example, http://www.python-course.eu/passing_arguments.php
 
## For partial function application see:
##   http://rosettacode.org/wiki/Partial_function_application#Python"
7efm,python,Call a function in a shared library,Systems Programming and File I/O,File Operations,"import ctypes
 
user32_dll = ctypes.cdll.LoadLibrary('User32.dll')
print user32_dll.GetDoubleClickTime()"
tq4m,python,Call an object method,Programming Concepts,Fundamentals,"class MyClass(object):
	@classmethod
	def myClassMethod(self, x):
		pass
	@staticmethod
	def myStaticMethod(x):
		pass
	def myMethod(self, x):
		return 42 + x
 
myInstance = MyClass()
 
# Instance method
myInstance.myMethod(someParameter)
# A method can also be retrieved as an attribute from the class, and then explicitly called on an instance:
MyClass.myMethod(myInstance, someParameter)
 
 
# Class or static methods
MyClass.myClassMethod(someParameter)
MyClass.myStaticMethod(someParameter)
# You can also call class or static methods on an instance, which will simply call it on the instance's class
myInstance.myClassMethod(someParameter)
myInstance.myStaticMethod(someParameter)"
6s4k,python,Canny edge detector,Graphics and Visualization,Graphics Programming,"#!/bin/python
import numpy as np
from scipy.ndimage.filters import convolve, gaussian_filter
from scipy.misc import imread, imshow
 
def CannyEdgeDetector(im, blur = 1, highThreshold = 91, lowThreshold = 31):
	im = np.array(im, dtype=float) #Convert to float to prevent clipping values
 
	#Gaussian blur to reduce noise
	im2 = gaussian_filter(im, blur)
 
	#Use sobel filters to get horizontal and vertical gradients
	im3h = convolve(im2,[[-1,0,1],[-2,0,2],[-1,0,1]]) 
	im3v = convolve(im2,[[1,2,1],[0,0,0],[-1,-2,-1]])
 
	#Get gradient and direction
	grad = np.power(np.power(im3h, 2.0) + np.power(im3v, 2.0), 0.5)
	theta = np.arctan2(im3v, im3h)
	thetaQ = (np.round(theta * (5.0 / np.pi)) + 5) % 5 #Quantize direction
 
	#Non-maximum suppression
	gradSup = grad.copy()
	for r in range(im.shape[0]):
		for c in range(im.shape[1]):
			#Suppress pixels at the image edge
			if r == 0 or r == im.shape[0]-1 or c == 0 or c == im.shape[1] - 1:
				gradSup[r, c] = 0
				continue
			tq = thetaQ[r, c] % 4
 
			if tq == 0: #0 is E-W (horizontal)
				if grad[r, c] <= grad[r, c-1] or grad[r, c] <= grad[r, c+1]:
					gradSup[r, c] = 0
			if tq == 1: #1 is NE-SW
				if grad[r, c] <= grad[r-1, c+1] or grad[r, c] <= grad[r+1, c-1]:
					gradSup[r, c] = 0
			if tq == 2: #2 is N-S (vertical)
				if grad[r, c] <= grad[r-1, c] or grad[r, c] <= grad[r+1, c]:
					gradSup[r, c] = 0
			if tq == 3: #3 is NW-SE
				if grad[r, c] <= grad[r-1, c-1] or grad[r, c] <= grad[r+1, c+1]:
					gradSup[r, c] = 0
 
	#Double threshold
	strongEdges = (gradSup > highThreshold)
 
	#Strong has value 2, weak has value 1
	thresholdedEdges = np.array(strongEdges, dtype=np.uint8) + (gradSup > lowThreshold)
 
	#Tracing edges with hysteresis	
	#Find weak edge pixels near strong edge pixels
	finalEdges = strongEdges.copy()
	currentPixels = []
	for r in range(1, im.shape[0]-1):
		for c in range(1, im.shape[1]-1):	
			if thresholdedEdges[r, c] != 1:
				continue #Not a weak pixel
 
			#Get 3x3 patch	
			localPatch = thresholdedEdges[r-1:r+2,c-1:c+2]
			patchMax = localPatch.max()
			if patchMax == 2:
				currentPixels.append((r, c))
				finalEdges[r, c] = 1
 
	#Extend strong edges based on current pixels
	while len(currentPixels) > 0:
		newPix = []
		for r, c in currentPixels:
			for dr in range(-1, 2):
				for dc in range(-1, 2):
					if dr == 0 and dc == 0: continue
					r2 = r+dr
					c2 = c+dc
					if thresholdedEdges[r2, c2] == 1 and finalEdges[r2, c2] == 0:
						#Copy this weak pixel to final result
						newPix.append((r2, c2))
						finalEdges[r2, c2] = 1
		currentPixels = newPix
 
	return finalEdges
 
if __name__==""__main__"":
	im = imread(""test.jpg"", mode=""L"") #Open image, convert to greyscale
	finalEdges = CannyEdgeDetector(im)
	imshow(finalEdges)"
wm6l,python,Canonicalize CIDR,Networking and Web Development,Networking,"#!/usr/bin/env python
# canonicalize a CIDR block specification:
# make sure none of the host bits are set
 
import sys
from socket import inet_aton, inet_ntoa
from struct import pack, unpack
 
args = sys.argv[1:]
if len(args) == 0:
    args = sys.stdin.readlines()
 
for cidr in args:
   # IP in dotted-decimal / bits in network part
   dotted, size_str = cidr.split('/')
   size = int(size_str)
 
   numeric = unpack('!I', inet_aton(dotted))[0]  # IP as an integer
   binary = f'{numeric:#034b}'                   # then as a padded binary string
   prefix = binary[:size + 2]                    # just the network part
                                                 #   (34 and +2 are to account
                                                 #    for leading '0b')
 
   canon_binary = prefix + '0' * (32 - size)     # replace host part with all zeroes
   canon_numeric = int(canon_binary, 2)          # convert back to integer
   canon_dotted = inet_ntoa(pack('!I',
                            (canon_numeric)))    # and then to dotted-decimal
   print(f'{canon_dotted}/{size}')               # output result"
1e5j,python,Cantor set,Mathematics,Combinatorics,"WIDTH = 81
HEIGHT = 5
 
lines=[]
def cantor(start, len, index):
    seg = len / 3
    if seg == 0:
        return None
    for it in xrange(HEIGHT-index):
        i = index + it
        for jt in xrange(seg):
            j = start + seg + jt
            pos = i * WIDTH + j
            lines[pos] = ' '
    cantor(start,           seg, index + 1)
    cantor(start + seg * 2, seg, index + 1)
    return None
 
lines = ['*'] * (WIDTH*HEIGHT)
cantor(0, WIDTH, 1)
 
for i in xrange(HEIGHT):
    beg = WIDTH * i
    print ''.join(lines[beg : beg+WIDTH])"
le0k,python,Carmichael 3 strong pseudoprimes,Mathematics,Number Theory,"class Isprime():
    '''
    Extensible sieve of Eratosthenes
 
    >>> isprime.check(11)
    True
    >>> isprime.multiples
    {2, 4, 6, 8, 9, 10}
    >>> isprime.primes
    [2, 3, 5, 7, 11]
    >>> isprime(13)
    True
    >>> isprime.multiples
    {2, 4, 6, 7, 8, 9, 10, 11, 12, 14, 15, 16, 18, 20, 21, 22}
    >>> isprime.primes
    [2, 3, 5, 7, 11, 13, 17, 19]
    >>> isprime.nmax
    22
    >>> 
    '''
    multiples = {2}
    primes = [2]
    nmax = 2
 
    def __init__(self, nmax):
        if nmax > self.nmax:
            self.check(nmax)
 
    def check(self, n):
        if type(n) == float:
            if not n.is_integer(): return False
            n = int(n)
        multiples = self.multiples
        if n <= self.nmax:
            return n not in multiples
        else:
            # Extend the sieve
            primes, nmax = self.primes, self.nmax
            newmax = max(nmax*2, n)
            for p in primes:
                multiples.update(range(p*((nmax + p + 1) // p), newmax+1, p))
            for i in range(nmax+1, newmax+1):
                if i not in multiples:
                    primes.append(i)
                    multiples.update(range(i*2, newmax+1, i))
            self.nmax = newmax
            return n not in multiples
 
    __call__ = check
 
 
def carmichael(p1):
    ans = []
    if isprime(p1):
        for h3 in range(2, p1):
            g = h3 + p1
            for d in range(1, g):
                if (g * (p1 - 1)) % d == 0 and (-p1 * p1) % h3 == d % h3:
                    p2 = 1 + ((p1 - 1)* g // d)
                    if isprime(p2):
                        p3 = 1 + (p1 * p2 // h3)
                        if isprime(p3):
                            if (p2 * p3) % (p1 - 1) == 1:
                                #print('%i X %i X %i' % (p1, p2, p3))
                                ans += [tuple(sorted((p1, p2, p3)))]
    return ans
 
isprime = Isprime(2)
 
ans = sorted(sum((carmichael(n) for n in range(62) if isprime(n)), []))
print(',\n'.join(repr(ans[i:i+5])[1:-1] for i in range(0, len(ans)+1, 5)))"
unae,python,Cartesian product of two or more lists,Algorithms and Data Structures,Algorithms,"import itertools
 
def cp(lsts):
    return list(itertools.product(*lsts))
 
if __name__ == '__main__':
    from pprint import pprint as pp
 
    for lists in [[[1,2],[3,4]], [[3,4],[1,2]], [[], [1, 2]], [[1, 2], []],
                  ((1776, 1789),  (7, 12), (4, 14, 23), (0, 1)),
                  ((1, 2, 3), (30,), (500, 100)),
                  ((1, 2, 3), (), (500, 100))]:
        print(lists, '=>')
        pp(cp(lists), indent=2)
 "
ltvh,python,Case-sensitivity of identifiers,Programming Concepts,Fundamentals,">>> dog = 'Benjamin'; Dog = 'Samba'; DOG = 'Bernie'
>>> print ('The three dogs are named ',dog,', ',Dog,', and ',DOG)
The three dogs are named  Benjamin ,  Samba , and  Bernie
>>> "
a6ne,python,Casting out nines,Mathematics,Number Theory,"# Casting out Nines
#
# Nigel Galloway: June 27th., 2012,
#
def CastOut(Base=10, Start=1, End=999999):
  ran = [y for y in range(Base-1) if y%(Base-1) == (y*y)%(Base-1)]
  x,y = divmod(Start, Base-1)
  while True:
    for n in ran:
      k = (Base-1)*x + n
      if k < Start:
        continue
      if k > End:
        return
      yield k
    x += 1
 
for V in CastOut(Base=16,Start=1,End=255):
  print(V, end=' ')"
lz3m,python,Catalan numbers,Mathematics,Combinatorics,"from math import factorial
import functools
 
 
def memoize(func):
    cache = {}
 
    def memoized(key):
        # Returned, new, memoized version of decorated function
        if key not in cache:
            cache[key] = func(key)
        return cache[key]
    return functools.update_wrapper(memoized, func)
 
 
@memoize
def fact(n):
    return factorial(n)
 
 
def cat_direct(n):
    return fact(2 * n) // fact(n + 1) // fact(n)
 
 
@memoize
def catR1(n):
    return 1 if n == 0 else (
        sum(catR1(i) * catR1(n - 1 - i) for i in range(n))
    )
 
 
@memoize
def catR2(n):
    return 1 if n == 0 else (
        ((4 * n - 2) * catR2(n - 1)) // (n + 1)
    )
 
 
if __name__ == '__main__':
    def pr(results):
        fmt = '%-10s %-10s %-10s'
        print((fmt % tuple(c.__name__ for c in defs)).upper())
        print(fmt % (('=' * 10,) * 3))
        for r in zip(*results):
            print(fmt % r)
 
    defs = (cat_direct, catR1, catR2)
    results = [tuple(c(i) for i in range(15)) for c in defs]
    pr(results)"
uheo,python,Catalan numbers/Pascal's triangle,Mathematics,Combinatorics,">>> n = 15
>>> t = [0] * (n + 2)
>>> t[1] = 1
>>> for i in range(1, n + 1):
	for j in range(i, 1, -1): t[j] += t[j - 1]
	t[i + 1] = t[i]
	for j in range(i + 1, 1, -1): t[j] += t[j - 1]
	print(t[i+1] - t[i], end=' ')
 
 
1 2 5 14 42 132 429 1430 4862 16796 58786 208012 742900 2674440 9694845 
>>> "
kyjo,python,Catamorphism,Algorithms and Data Structures,Algorithms,">>> # Python 2.X
>>> from operator import add
>>> listoflists = [['the', 'cat'], ['sat', 'on'], ['the', 'mat']]
>>> help(reduce)
Help on built-in function reduce in module __builtin__:
 
reduce(...)
    reduce(function, sequence[, initial]) -> value
 
    Apply a function of two arguments cumulatively to the items of a sequence,
    from left to right, so as to reduce the sequence to a single value.
    For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates
    ((((1+2)+3)+4)+5).  If initial is present, it is placed before the items
    of the sequence in the calculation, and serves as a default when the
    sequence is empty.
 
>>> reduce(add, listoflists, [])
['the', 'cat', 'sat', 'on', 'the', 'mat']
>>> "
5j9w,python,Catmull–Clark subdivision surface,Graphics and Visualization,Graphics Programming," 
""""""
 
Input and output are assumed to be in this form based on the talk
page for the task:
 
input_points = [
  [-1.0,  1.0,  1.0],
  [-1.0, -1.0,  1.0],
  [ 1.0, -1.0,  1.0],
  [ 1.0,  1.0,  1.0],
  [ 1.0, -1.0, -1.0],
  [ 1.0,  1.0, -1.0],
  [-1.0, -1.0, -1.0],
  [-1.0,  1.0, -1.0]
]
 
input_faces = [
  [0, 1, 2, 3],
  [3, 2, 4, 5],
  [5, 4, 6, 7],
  [7, 0, 3, 5],
  [7, 6, 1, 0],
  [6, 1, 2, 4],
]
 
So, the graph is a list of points and a list of faces.
Each face is a list of indexes into the points list.
 
""""""
 
from mpl_toolkits.mplot3d import axes3d
import matplotlib.pyplot as plt
import numpy as np
import sys
 
def center_point(p1, p2):
    """""" 
    returns a point in the center of the 
    segment ended by points p1 and p2
    """"""
    cp = []
    for i in range(3):
        cp.append((p1[i]+p2[i])/2)
 
    return cp
 
def sum_point(p1, p2):
    """""" 
    adds points p1 and p2
    """"""
    sp = []
    for i in range(3):
        sp.append(p1[i]+p2[i])
 
    return sp
 
def div_point(p, d):
    """""" 
    divide point p by d
    """"""
    sp = []
    for i in range(3):
        sp.append(p[i]/d)
 
    return sp
 
def mul_point(p, m):
    """""" 
    multiply point p by m
    """"""
    sp = []
    for i in range(3):
        sp.append(p[i]*m)
 
    return sp
 
def get_face_points(input_points, input_faces):
    """"""
    From http://rosettacode.org/wiki/Catmull%E2%80%93Clark_subdivision_surface
 
    1. for each face, a face point is created which is the average of all the points of the face.
    """"""
 
    # 3 dimensional space
 
    NUM_DIMENSIONS = 3
 
    # face_points will have one point for each face
 
    face_points = []
 
    for curr_face in input_faces:
        face_point = [0.0, 0.0, 0.0]
        for curr_point_index in curr_face:
            curr_point = input_points[curr_point_index]
            # add curr_point to face_point
            # will divide later
            for i in range(NUM_DIMENSIONS):
                face_point[i] += curr_point[i]
        # divide by number of points for average
        num_points = len(curr_face)
        for i in range(NUM_DIMENSIONS):
            face_point[i] /= num_points
        face_points.append(face_point)
 
    return face_points
 
def get_edges_faces(input_points, input_faces):
    """"""
 
    Get list of edges and the one or two adjacent faces in a list.
    also get center point of edge
 
    Each edge would be [pointnum_1, pointnum_2, facenum_1, facenum_2, center]
 
    """"""
 
    # will have [pointnum_1, pointnum_2, facenum]
 
    edges = []
 
    # get edges from each face
 
    for facenum in range(len(input_faces)):
        face = input_faces[facenum]
        num_points = len(face)
        # loop over index into face
        for pointindex in range(num_points):
            # if not last point then edge is curr point and next point
            if pointindex < num_points - 1:
                pointnum_1 = face[pointindex]
                pointnum_2 = face[pointindex+1]
            else:
                # for last point edge is curr point and first point
                pointnum_1 = face[pointindex]
                pointnum_2 = face[0]
            # order points in edge by lowest point number
            if pointnum_1 > pointnum_2:
                temp = pointnum_1
                pointnum_1 = pointnum_2
                pointnum_2 = temp
            edges.append([pointnum_1, pointnum_2, facenum])
 
    # sort edges by pointnum_1, pointnum_2, facenum
 
    edges = sorted(edges)
 
    # merge edges with 2 adjacent faces
    # [pointnum_1, pointnum_2, facenum_1, facenum_2] or
    # [pointnum_1, pointnum_2, facenum_1, None]
 
    num_edges = len(edges)
    eindex = 0
    merged_edges = []
 
    while eindex < num_edges:
        e1 = edges[eindex]
        # check if not last edge
        if eindex < num_edges - 1:
            e2 = edges[eindex+1]
            if e1[0] == e2[0] and e1[1] == e2[1]:
                merged_edges.append([e1[0],e1[1],e1[2],e2[2]])
                eindex += 2
            else:
                merged_edges.append([e1[0],e1[1],e1[2],None])
                eindex += 1
        else:
            merged_edges.append([e1[0],e1[1],e1[2],None])
            eindex += 1
 
    # add edge centers
 
    edges_centers = []
 
    for me in merged_edges:
        p1 = input_points[me[0]]
        p2 = input_points[me[1]]
        cp = center_point(p1, p2)
        edges_centers.append(me+[cp])
 
    return edges_centers
 
def get_edge_points(input_points, edges_faces, face_points):
    """"""
    for each edge, an edge point is created which is the average 
    between the center of the edge and the center of the segment made
    with the face points of the two adjacent faces.
    """"""
 
    edge_points = []
 
    for edge in edges_faces:
        # get center of edge
        cp = edge[4]
        # get center of two facepoints
        fp1 = face_points[edge[2]]
        # if not two faces just use one facepoint
        # should not happen for solid like a cube
        if edge[3] == None:
            fp2 = fp1
        else:
            fp2 = face_points[edge[3]]
        cfp = center_point(fp1, fp2)
        # get average between center of edge and
        # center of facepoints
        edge_point = center_point(cp, cfp)
        edge_points.append(edge_point)      
 
    return edge_points
 
def get_avg_face_points(input_points, input_faces, face_points):
    """"""
 
    for each point calculate
 
    the average of the face points of the faces the point belongs to (avg_face_points)
 
    create a list of lists of two numbers [facepoint_sum, num_points] by going through the
    points in all the faces.
 
    then create the avg_face_points list of point by dividing point_sum (x, y, z) by num_points
 
    """"""
 
    # initialize list with [[0.0, 0.0, 0.0], 0]
 
    num_points = len(input_points)
 
    temp_points = []
 
    for pointnum in range(num_points):
        temp_points.append([[0.0, 0.0, 0.0], 0])
 
    # loop through faces updating temp_points
 
    for facenum in range(len(input_faces)):
        fp = face_points[facenum]
        for pointnum in input_faces[facenum]:
            tp = temp_points[pointnum][0]
            temp_points[pointnum][0] = sum_point(tp,fp)
            temp_points[pointnum][1] += 1
 
    # divide to create avg_face_points
 
    avg_face_points = []
 
    for tp in temp_points:
       afp = div_point(tp[0], tp[1])
       avg_face_points.append(afp)
 
    return avg_face_points
 
def get_avg_mid_edges(input_points, edges_faces):
    """"""
 
    the average of the centers of edges the point belongs to (avg_mid_edges)
 
    create list with entry for each point 
    each entry has two elements. one is a point that is the sum of the centers of the edges
    and the other is the number of edges. after going through all edges divide by
    number of edges.
 
    """"""
 
    # initialize list with [[0.0, 0.0, 0.0], 0]
 
    num_points = len(input_points)
 
    temp_points = []
 
    for pointnum in range(num_points):
        temp_points.append([[0.0, 0.0, 0.0], 0])
 
    # go through edges_faces using center updating each point
 
    for edge in edges_faces:
        cp = edge[4]
        for pointnum in [edge[0], edge[1]]:
            tp = temp_points[pointnum][0]
            temp_points[pointnum][0] = sum_point(tp,cp)
            temp_points[pointnum][1] += 1
 
    # divide out number of points to get average
 
    avg_mid_edges = []
 
    for tp in temp_points:
       ame = div_point(tp[0], tp[1])
       avg_mid_edges.append(ame)
 
    return avg_mid_edges
 
def get_points_faces(input_points, input_faces):
    # initialize list with 0
 
    num_points = len(input_points)
 
    points_faces = []
 
    for pointnum in range(num_points):
        points_faces.append(0)
 
    # loop through faces updating points_faces
 
    for facenum in range(len(input_faces)):
        for pointnum in input_faces[facenum]:
            points_faces[pointnum] += 1
 
    return points_faces
 
def get_new_points(input_points, points_faces, avg_face_points, avg_mid_edges):
    """"""
 
    m1 = (n - 3.0) / n
    m2 = 1.0 / n
    m3 = 2.0 / n
    new_coords = (m1 * old_coords)
               + (m2 * avg_face_points)
               + (m3 * avg_mid_edges)
 
    """"""
 
    new_points =[]
 
    for pointnum in range(len(input_points)):
        n = points_faces[pointnum]
        m1 = (n - 3.0) / n
        m2 = 1.0 / n
        m3 = 2.0 / n
        old_coords = input_points[pointnum]
        p1 = mul_point(old_coords, m1)
        afp = avg_face_points[pointnum]
        p2 = mul_point(afp, m2)
        ame = avg_mid_edges[pointnum]
        p3 = mul_point(ame, m3)
        p4 = sum_point(p1, p2)
        new_coords = sum_point(p4, p3)
 
        new_points.append(new_coords)
 
    return new_points
 
def switch_nums(point_nums):
    """"""
    Returns tuple of point numbers
    sorted least to most
    """"""
    if point_nums[0] < point_nums[1]:
        return point_nums
    else:
        return (point_nums[1], point_nums[0])    
 
def cmc_subdiv(input_points, input_faces):
    # 1. for each face, a face point is created which is the average of all the points of the face.
    # each entry in the returned list is a point (x, y, z).
 
    face_points = get_face_points(input_points, input_faces)
 
    # get list of edges with 1 or 2 adjacent faces
    # [pointnum_1, pointnum_2, facenum_1, facenum_2, center] or
    # [pointnum_1, pointnum_2, facenum_1, None, center]
 
    edges_faces = get_edges_faces(input_points, input_faces)
 
    # get edge points, a list of points
 
    edge_points = get_edge_points(input_points, edges_faces, face_points)
 
    # the average of the face points of the faces the point belongs to (avg_face_points)                
 
    avg_face_points = get_avg_face_points(input_points, input_faces, face_points)
 
    # the average of the centers of edges the point belongs to (avg_mid_edges)
 
    avg_mid_edges = get_avg_mid_edges(input_points, edges_faces) 
 
    # how many faces a point belongs to
 
    points_faces = get_points_faces(input_points, input_faces)
 
    """"""
 
    m1 = (n - 3) / n
    m2 = 1 / n
    m3 = 2 / n
    new_coords = (m1 * old_coords)
               + (m2 * avg_face_points)
               + (m3 * avg_mid_edges)
 
    """"""
 
    new_points = get_new_points(input_points, points_faces, avg_face_points, avg_mid_edges)
 
    """"""
 
    Then each face is replaced by new faces made with the new points,
 
    for a triangle face (a,b,c):
       (a, edge_point ab, face_point abc, edge_point ca)
       (b, edge_point bc, face_point abc, edge_point ab)
       (c, edge_point ca, face_point abc, edge_point bc)
 
    for a quad face (a,b,c,d):
       (a, edge_point ab, face_point abcd, edge_point da)
       (b, edge_point bc, face_point abcd, edge_point ab)
       (c, edge_point cd, face_point abcd, edge_point bc)
       (d, edge_point da, face_point abcd, edge_point cd)
 
    face_points is a list indexed by face number so that is
    easy to get.
 
    edge_points is a list indexed by the edge number
    which is an index into edges_faces.
 
    need to add face_points and edge points to 
    new_points and get index into each.
 
    then create two new structures
 
    face_point_nums - list indexes by facenum
    whose value is the index into new_points
 
    edge_point num - dictionary with key (pointnum_1, pointnum_2)
    and value is index into new_points
 
    """"""
 
    # add face points to new_points
 
    face_point_nums = []
 
    # point num after next append to new_points
    next_pointnum = len(new_points)
 
    for face_point in face_points:
        new_points.append(face_point)
        face_point_nums.append(next_pointnum)
        next_pointnum += 1
 
    # add edge points to new_points
 
    edge_point_nums = dict()
 
    for edgenum in range(len(edges_faces)):
        pointnum_1 = edges_faces[edgenum][0]
        pointnum_2 = edges_faces[edgenum][1]
        edge_point = edge_points[edgenum]
        new_points.append(edge_point)
        edge_point_nums[(pointnum_1, pointnum_2)] = next_pointnum
        next_pointnum += 1
 
    # new_points now has the points to output. Need new
    # faces
 
    """"""
 
    just doing this case for now:
 
    for a quad face (a,b,c,d):
       (a, edge_point ab, face_point abcd, edge_point da)
       (b, edge_point bc, face_point abcd, edge_point ab)
       (c, edge_point cd, face_point abcd, edge_point bc)
       (d, edge_point da, face_point abcd, edge_point cd)
 
    new_faces will be a list of lists where the elements are like this:
 
    [pointnum_1, pointnum_2, pointnum_3, pointnum_4]
 
    """"""
 
    new_faces =[]
 
    for oldfacenum in range(len(input_faces)):
        oldface = input_faces[oldfacenum]
        # 4 point face
        if len(oldface) == 4:
            a = oldface[0]
            b = oldface[1]
            c = oldface[2]
            d = oldface[3]
            face_point_abcd = face_point_nums[oldfacenum]
            edge_point_ab = edge_point_nums[switch_nums((a, b))]
            edge_point_da = edge_point_nums[switch_nums((d, a))]
            edge_point_bc = edge_point_nums[switch_nums((b, c))]
            edge_point_cd = edge_point_nums[switch_nums((c, d))]
            new_faces.append((a, edge_point_ab, face_point_abcd, edge_point_da))
            new_faces.append((b, edge_point_bc, face_point_abcd, edge_point_ab))
            new_faces.append((c, edge_point_cd, face_point_abcd, edge_point_bc))
            new_faces.append((d, edge_point_da, face_point_abcd, edge_point_cd))    
 
    return new_points, new_faces
 
 
def graph_output(output_points, output_faces):
 
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
 
    """"""
 
    Plot each face
 
    """"""
 
    for facenum in range(len(output_faces)):
        curr_face = output_faces[facenum]
        xcurr = []
        ycurr = []
        zcurr = []
        for pointnum in range(len(curr_face)):
            xcurr.append(output_points[curr_face[pointnum]][0])
            ycurr.append(output_points[curr_face[pointnum]][1])
            zcurr.append(output_points[curr_face[pointnum]][2])
        xcurr.append(output_points[curr_face[0]][0])
        ycurr.append(output_points[curr_face[0]][1])
        zcurr.append(output_points[curr_face[0]][2])
 
        ax.plot(xcurr,ycurr,zcurr,color='b')
 
    plt.show()
 
 
# cube
 
input_points = [
  [-1.0,  1.0,  1.0],
  [-1.0, -1.0,  1.0],
  [ 1.0, -1.0,  1.0],
  [ 1.0,  1.0,  1.0],
  [ 1.0, -1.0, -1.0],
  [ 1.0,  1.0, -1.0],
  [-1.0, -1.0, -1.0],
  [-1.0,  1.0, -1.0]
]
 
input_faces = [
  [0, 1, 2, 3],
  [3, 2, 4, 5],
  [5, 4, 6, 7],
  [7, 0, 3, 5],
  [7, 6, 1, 0],
  [6, 1, 2, 4],
]
 
if len(sys.argv) != 2:
    print(""Should have one argument integer number of iterations"")
    sys.exit()
else:
    iterations = int(sys.argv[1])
 
    output_points, output_faces = input_points, input_faces
 
    for i in range(iterations):
        output_points, output_faces = cmc_subdiv(output_points, output_faces)
 
graph_output(output_points, output_faces)
 "
s1ie,python,Chaocipher,Security and Cryptography,Cryptographic Techniques,"# Python3 implementation of Chaocipher 
# left wheel = ciphertext wheel
# right wheel = plaintext wheel
 
def main():
    # letters only! makealpha(key) helps generate lalpha/ralpha. 
    lalpha = ""HXUCZVAMDSLKPEFJRIGTWOBNYQ""
    ralpha = ""PTLNBQDEOYSFAVZKGJRIHWXUMC""
    msg = ""WELLDONEISBETTERTHANWELLSAID""
 
    print(""L:"", lalpha)
    print(""R:"", ralpha)
    print(""I:"", msg)
    print(""O:"", do_chao(msg, lalpha, ralpha, 1, 0), ""\n"")
 
    do_chao(msg, lalpha, ralpha, 1, 1)
 
def do_chao(msg, lalpha, ralpha, en=1, show=0):
    msg = correct_case(msg)
    out = """"    
    if show:
        print(""=""*54)        
        print(10*"" "" + ""left:"" + 21*"" "" + ""right: "")
        print(""=""*54)        
        print(lalpha, ralpha, ""\n"")
    for L in msg:
        if en:
            lalpha, ralpha = rotate_wheels(lalpha, ralpha, L)
            out += lalpha[0]
        else:
            ralpha, lalpha = rotate_wheels(ralpha, lalpha, L)
            out += ralpha[0]
        lalpha, ralpha = scramble_wheels(lalpha, ralpha)
        if show:
            print(lalpha, ralpha)            
    return out
 
def makealpha(key=""""):
    alpha = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
    z = set()
    key = [x.upper() for x in (key + alpha[::-1])
           if not (x.upper() in z or z.add(x.upper()))]
    return """".join(key)
 
def correct_case(string):
    return """".join([s.upper() for s in string if s.isalpha()])
 
def permu(alp, num):
    alp = alp[:num], alp[num:]
    return """".join(alp[::-1])
 
def rotate_wheels(lalph, ralph, key):
    newin = ralph.index(key)
    return permu(lalph, newin), permu(ralph, newin)    
 
def scramble_wheels(lalph, ralph):
    # LEFT = cipher wheel 
    # Cycle second[1] through nadir[14] forward
    lalph = list(lalph)
    lalph = """".join([*lalph[0],
                    *lalph[2:14],
                    lalph[1],
                    *lalph[14:]])
 
    # RIGHT = plain wheel                    
    # Send the zenith[0] character to the end[25],
    # cycle third[2] through nadir[14] characters forward
    ralph = list(ralph)
    ralph = """".join([*ralph[1:3],
                     *ralph[4:15],
                     ralph[3],
                     *ralph[15:],
                     ralph[0]])
    return lalph, ralph
 
main()"
rut1,python,Chaos game,Puzzles and Games,Simulation and Modeling," 
import argparse
import random
import shapely.geometry as geometry
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
 
 
def main(args):
    # Styles
    plt.style.use(""ggplot"")
 
    # Creating figure
    fig = plt.figure()
    line, = plt.plot([], [], ""."")
 
    # Limit axes
    plt.xlim(0, 1)
    plt.ylim(0, 1)
 
    # Titles
    title = ""Chaos Game""
    plt.title(title)
    fig.canvas.set_window_title(title)
 
    # Getting data
    data = get_data(args.frames)
 
    # Creating animation
    line_ani = animation.FuncAnimation(
        fig=fig,
        func=update_line,
        frames=args.frames,
        fargs=(data, line),
        interval=args.interval,
        repeat=False
    )
 
    # To save the animation install ffmpeg and uncomment
    # line_ani.save(""chaos_game.gif"")
 
    plt.show()
 
 
def get_data(n):
    """"""
    Get data to plot
    """"""
    leg = 1
    triangle = get_triangle(leg)
    cur_point = gen_point_within_poly(triangle)
    data = []
    for _ in range(n):
        data.append((cur_point.x, cur_point.y))
        cur_point = next_point(triangle, cur_point)
    return data
 
 
def get_triangle(n):
    """"""
    Create right triangle
    """"""
    ax = ay = 0.0
    a = ax, ay
 
    bx = 0.5  *  n
    by = 0.75 * (n ** 2)
    b = bx, by
 
    cx = n
    cy = 0.0
    c = cx, cy
 
    triangle = geometry.Polygon([a, b, c])
    return triangle
 
 
def gen_point_within_poly(poly):
    """"""
    Generate random point inside given polygon
    """"""
    minx, miny, maxx, maxy = poly.bounds
    while True:
        x = random.uniform(minx, maxx)
        y = random.uniform(miny, maxy)
        point = geometry.Point(x, y)
        if point.within(poly):
            return point
 
 
def next_point(poly, point):
    """"""
    Generate next point according to chaos game rules
    """"""
    vertices = poly.boundary.coords[:-1]  # Last point is the same as the first one
    random_vertex = geometry.Point(random.choice(vertices))
    line = geometry.linestring.LineString([point, random_vertex])
    return line.centroid
 
 
def update_line(num, data, line):
    """"""
    Update line with new points
    """"""
    new_data = zip(*data[:num]) or [(), ()]
    line.set_data(new_data)
    return line,
 
 
if __name__ == ""__main__"":
    arg_parser = argparse.ArgumentParser(description=""Chaos Game by Suenweek (c) 2017"")
    arg_parser.add_argument(""-f"", dest=""frames"", type=int, default=1000)
    arg_parser.add_argument(""-i"", dest=""interval"", type=int, default=10)
 
    main(arg_parser.parse_args())
 
 "
bo44,python,Character codes,Text Processing,Unicode and Character Sets,"print ord('a') # prints ""97""
print chr(97)  # prints ""a"""
lni4,python,Chat server,Networking and Web Development,Networking,"#!/usr/bin/env python
 
import socket
import thread
import time
 
HOST = """"
PORT = 4004
 
def accept(conn):
    """"""
    Call the inner func in a thread so as not to block. Wait for a 
    name to be entered from the given connection. Once a name is 
    entered, set the connection to non-blocking and add the user to 
    the users dict.
    """"""
    def threaded():
        while True:
            conn.send(""Please enter your name: "")
            try:
                name = conn.recv(1024).strip()
            except socket.error:
                continue
            if name in users:
                conn.send(""Name entered is already in use.\n"")
            elif name:
                conn.setblocking(False)
                users[name] = conn
                broadcast(name, ""+++ %s arrived +++"" % name)
                break
    thread.start_new_thread(threaded, ())
 
def broadcast(name, message):
    """"""
    Send a message to all users from the given name.
    """"""
    print message
    for to_name, conn in users.items():
        if to_name != name:
            try:
                conn.send(message + ""\n"")
            except socket.error:
                pass
 
# Set up the server socket.
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
server.setblocking(False)
server.bind((HOST, PORT))
server.listen(1)
print ""Listening on %s"" % (""%s:%s"" % server.getsockname())
 
# Main event loop.
users = {}
while True:
    try:
        # Accept new connections.
        while True:
            try:
                conn, addr = server.accept()
            except socket.error:
                break
            accept(conn)
        # Read from connections.
        for name, conn in users.items():
            try:
                message = conn.recv(1024)
            except socket.error:
                continue
            if not message:
                # Empty string is given on disconnect.
                del users[name]
                broadcast(name, ""--- %s leaves ---"" % name)
            else:
                broadcast(name, ""%s> %s"" % (name, message.strip()))
        time.sleep(.1)
    except (SystemExit, KeyboardInterrupt):
        break"
8gke,python,Check Machin-like formulas,Mathematics,Algebra and Arithmetic,"import re
from fractions import Fraction
from pprint import pprint as pp
 
 
equationtext = '''\
  pi/4 = arctan(1/2) + arctan(1/3) 
  pi/4 = 2*arctan(1/3) + arctan(1/7)
  pi/4 = 4*arctan(1/5) - arctan(1/239)
  pi/4 = 5*arctan(1/7) + 2*arctan(3/79)
  pi/4 = 5*arctan(29/278) + 7*arctan(3/79)
  pi/4 = arctan(1/2) + arctan(1/5) + arctan(1/8) 
  pi/4 = 4*arctan(1/5) - arctan(1/70) + arctan(1/99) 
  pi/4 = 5*arctan(1/7) + 4*arctan(1/53) + 2*arctan(1/4443)
  pi/4 = 6*arctan(1/8) + 2*arctan(1/57) + arctan(1/239)
  pi/4 = 8*arctan(1/10) - arctan(1/239) - 4*arctan(1/515)
  pi/4 = 12*arctan(1/18) + 8*arctan(1/57) - 5*arctan(1/239)
  pi/4 = 16*arctan(1/21) + 3*arctan(1/239) + 4*arctan(3/1042)
  pi/4 = 22*arctan(1/28) + 2*arctan(1/443) - 5*arctan(1/1393) - 10*arctan(1/11018)
  pi/4 = 22*arctan(1/38) + 17*arctan(7/601) + 10*arctan(7/8149)
  pi/4 = 44*arctan(1/57) + 7*arctan(1/239) - 12*arctan(1/682) + 24*arctan(1/12943)
  pi/4 = 88*arctan(1/172) + 51*arctan(1/239) + 32*arctan(1/682) + 44*arctan(1/5357) + 68*arctan(1/12943)
  pi/4 = 88*arctan(1/172) + 51*arctan(1/239) + 32*arctan(1/682) + 44*arctan(1/5357) + 68*arctan(1/12944)
'''
 
def parse_eqn(equationtext=equationtext):
    eqn_re = re.compile(r""""""(?mx)
    (?P<lhs> ^ \s* pi/4 \s* = \s*)?             # LHS of equation
    (?:                                         # RHS
        \s* (?P<sign> [+-])? \s* 
        (?: (?P<mult> \d+) \s* \*)? 
        \s* arctan\( (?P<numer> \d+) / (?P<denom> \d+)
    )"""""")
 
    found = eqn_re.findall(equationtext)
    machins, part = [], []
    for lhs, sign, mult, numer, denom in eqn_re.findall(equationtext):
        if lhs and part:
            machins.append(part)
            part = []
        part.append( ( (-1 if sign == '-' else 1) * ( int(mult) if mult else 1),
                       Fraction(int(numer), (int(denom) if denom else 1)) ) )
    machins.append(part)
    return machins
 
 
def tans(xs):
    xslen = len(xs)
    if xslen == 1:
        return tanEval(*xs[0])
    aa, bb = xs[:xslen//2], xs[xslen//2:]
    a, b = tans(aa), tans(bb)
    return (a + b) / (1 - a * b)
 
def tanEval(coef, f):
    if coef == 1:
        return f
    if coef < 0:
        return -tanEval(-coef, f)
    ca = coef // 2
    cb = coef - ca
    a, b = tanEval(ca, f), tanEval(cb, f)
    return (a + b) / (1 - a * b)
 
 
if __name__ == '__main__':
    machins = parse_eqn()
    #pp(machins, width=160)
    for machin, eqn in zip(machins, equationtext.split('\n')):
        ans = tans(machin)
        print('%5s: %s' % ( ('OK' if ans == 1 else 'ERROR'), eqn))"
6.60E+06,python,Check input device is a terminal,Systems Programming and File I/O,File Operations,"from sys import stdin
if stdin.isatty():
    print(""Input comes from tty."")
else:
    print(""Input doesn't come from tty."")"
d2ra,python,Check output device is a terminal,Operating Systems and Shell Programming,Operating System Concepts,"from sys import stdout
if stdout.isatty():
    print 'The output device is a teletype. Or something like a teletype.'
else:
    print 'The output device isn\'t like a teletype.'"
kqgv,python,Check that file exists,Systems Programming and File I/O,File Operations,"import os
 
os.path.isfile(""input.txt"")
os.path.isfile(""/input.txt"")
os.path.isdir(""docs"")
os.path.isdir(""/docs"")"
53jp,python,Checkpoint synchronization,Concurrency and Parallelism,Synchronization Mechanisms," 
""""""
 
Based on https://pymotw.com/3/threading/
 
""""""
 
import threading
import time
import random
 
 
def worker(workernum, barrier):
    # task 1
    sleeptime = random.random()
    print('Starting worker '+str(workernum)+"" task 1, sleeptime=""+str(sleeptime))
    time.sleep(sleeptime)
    print('Exiting worker'+str(workernum))
    barrier.wait()
    # task 2
    sleeptime = random.random()
    print('Starting worker '+str(workernum)+"" task 2, sleeptime=""+str(sleeptime))
    time.sleep(sleeptime)
    print('Exiting worker'+str(workernum))
 
barrier = threading.Barrier(3)
 
w1 = threading.Thread(target=worker, args=((1,barrier)))
w2 = threading.Thread(target=worker, args=((2,barrier)))
w3 = threading.Thread(target=worker, args=((3,barrier)))
 
w1.start()
w2.start()
w3.start()
 "
8m72,python,Chernick's Carmichael numbers,Mathematics,Number Theory," 
""""""
 
Python implementation of
http://rosettacode.org/wiki/Chernick%27s_Carmichael_numbers
 
""""""
 
# use sympy for prime test
 
from sympy import isprime
 
# based on C version
 
def primality_pretest(k):
    if not (k % 3) or not (k % 5) or not (k % 7) or not (k % 11) or not(k % 13) or not (k % 17) or not (k % 19) or not (k % 23):
        return (k <= 23)
 
    return True
 
def is_chernick(n, m):
 
    t = 9 * m
 
    if not primality_pretest(6 * m + 1):
        return False
 
    if not primality_pretest(12 * m + 1):
        return False
 
    for i in range(1,n-1):
        if not primality_pretest((t << i) + 1):
            return False
 
    if not isprime(6 * m + 1):
        return False
 
    if not isprime(12 * m + 1):
        return False
 
    for i in range(1,n - 1):
        if not isprime((t << i) + 1):
            return False
 
    return True
 
for n in range(3,10):
 
    if n > 4:
        multiplier = 1 << (n - 4)
    else:
        multiplier = 1
 
    if n > 5:
        multiplier *= 5
 
 
    k = 1
 
    while True:
        m = k * multiplier
 
        if is_chernick(n, m): 
            print(""a(""+str(n)+"") has m = ""+str(m))
            break
 
        k += 1
 "
j91u,python,Cheryl's birthday,Puzzles and Games,Logic and Mathematical Puzzles,"'''Cheryl's Birthday'''
 
from itertools import groupby
from re import split
 
 
# main :: IO ()
def main():
    '''Derivation of the date.'''
 
    month, day = 0, 1
    print(
        # (3 :: A ""Then I also know"")
        # (A's month contains only one remaining day)
        uniquePairing(month)(
            # (2 :: B ""I know now"")
            # (B's day is paired with only one remaining month)
            uniquePairing(day)(
                # (1 :: A ""I know that Bernard does not know"")
                # (A's month is not among those with unique days)
                monthsWithUniqueDays(False)([
                    # 0 :: Cheryl's list:
                    tuple(x.split()) for x in
                    split(
                        ', ',
                        'May 15, May 16, May 19, ' +
                        'June 17, June 18, ' +
                        'July 14, July 16, ' +
                        'Aug 14, Aug 15, Aug 17'
                    )
                ])
            )
        )
    )
 
 
# ------------------- QUERY FUNCTIONS --------------------
 
# monthsWithUniqueDays :: Bool -> [(Month, Day)] -> [(Month, Day)]
def monthsWithUniqueDays(blnInclude):
    '''The subset of months with (or without) unique days.
    '''
    def go(xs):
        month, day = 0, 1
        months = [fst(x) for x in uniquePairing(day)(xs)]
        return [
            md for md in xs
            if blnInclude or not (md[month] in months)
        ]
    return go
 
 
# uniquePairing :: DatePart -> [(Month, Day)] -> [(Month, Day)]
def uniquePairing(i):
    '''Subset of months (or days) with a unique intersection.
    '''
    def go(xs):
        def inner(md):
            dct = md[i]
            uniques = [
                k for k in dct.keys()
                if 1 == len(dct[k])
            ]
            return [tpl for tpl in xs if tpl[i] in uniques]
        return inner
    return ap(bindPairs)(go)
 
 
# bindPairs :: [(Month, Day)] ->
# ((Dict String [String], Dict String [String])
# -> [(Month, Day)]) -> [(Month, Day)]
def bindPairs(xs):
    '''List monad injection operator for lists
       of (Month, Day) pairs.
    '''
    return lambda f: f(
        (
            dictFromPairs(xs),
            dictFromPairs(
                [(b, a) for (a, b) in xs]
            )
        )
    )
 
 
# dictFromPairs :: [(Month, Day)] -> Dict Text [Text]
def dictFromPairs(xs):
    '''A dictionary derived from a list of
       month day pairs.
    '''
    return {
        k: [snd(x) for x in m] for k, m in groupby(
            sorted(xs, key=fst), key=fst
        )
    }
 
 
# ----------------------- GENERIC ------------------------
 
# ap :: (a -> b -> c) -> (a -> b) -> a -> c
def ap(f):
    '''Applicative instance for functions.
    '''
    def go(g):
        def fxgx(x):
            return f(x)(
                g(x)
            )
        return fxgx
    return go
 
 
# fst :: (a, b) -> a
def fst(tpl):
    '''First component of a pair.
    '''
    return tpl[0]
 
 
# snd :: (a, b) -> b
def snd(tpl):
    '''Second component of a pair.
    '''
    return tpl[1]
 
 
if __name__ == '__main__':
    main()"
f87r,python,Chinese remainder theorem,Mathematics,Number Theory,"# Python 2.7
def chinese_remainder(n, a):
    sum = 0
    prod = reduce(lambda a, b: a*b, n)
 
    for n_i, a_i in zip(n, a):
        p = prod / n_i
        sum += a_i * mul_inv(p, n_i) * p
    return sum % prod
 
 
def mul_inv(a, b):
    b0 = b
    x0, x1 = 0, 1
    if b == 1: return 1
    while a > 1:
        q = a / b
        a, b = b, a%b
        x0, x1 = x1 - q * x0, x0
    if x1 < 0: x1 += b0
    return x1
 
if __name__ == '__main__':
    n = [3, 5, 7]
    a = [2, 3, 2]
    print chinese_remainder(n, a)"
wdzl,python,Chinese zodiac,Mathematics,Numerical Methods," 
# coding: utf-8
 
from __future__ import print_function
from datetime import datetime
 
pinyin = {
  '甲': 'jiă',
  '乙': 'yĭ',
  '丙': 'bĭng',
  '丁': 'dīng',
  '戊': 'wù',
  '己': 'jĭ',
  '庚': 'gēng',
  '辛': 'xīn',
  '壬': 'rén',
  '癸': 'gŭi',
 
  '子': 'zĭ',
  '丑': 'chŏu',
  '寅': 'yín',
  '卯': 'măo',
  '辰': 'chén',
  '巳': 'sì',
  '午': 'wŭ',
  '未': 'wèi',
  '申': 'shēn',
  '酉': 'yŏu',
  '戌': 'xū',
  '亥': 'hài'
}
 
animals = ['Rat', 'Ox', 'Tiger', 'Rabbit', 'Dragon', 'Snake',
           'Horse', 'Goat', 'Monkey', 'Rooster', 'Dog', 'Pig']
elements = ['Wood', 'Fire', 'Earth', 'Metal', 'Water']
 
celestial = ['甲', '乙', '丙', '丁', '戊', '己', '庚', '辛', '壬', '癸']
terrestrial = ['子', '丑', '寅', '卯', '辰', '巳', '午', '未', '申', '酉', '戌', '亥']
aspects = ['yang', 'yin']
 
 
def calculate(year):
    BASE = 4
    year = int(year)
    cycle_year = year - BASE
    stem_number = cycle_year % 10
    stem_han = celestial[stem_number]
    stem_pinyin = pinyin[stem_han]
    element_number = stem_number // 2
    element = elements[element_number]
    branch_number = cycle_year % 12
    branch_han = terrestrial[branch_number]
    branch_pinyin = pinyin[branch_han]
    animal = animals[branch_number]
    aspect_number = cycle_year % 2
    aspect = aspects[aspect_number]
    index = cycle_year % 60 + 1
    print(""{}: {}{} ({}-{}, {} {}; {} - year {} of the cycle)""
          .format(year, stem_han, branch_han,
                  stem_pinyin, branch_pinyin, element, animal, aspect, index))
 
 
current_year = datetime.now().year
years = [1935, 1938, 1968, 1972, 1976, current_year]
for year in years:
    calculate(year)"
z19x,python,Cholesky decomposition,Mathematics,Numerical Methods,"from __future__ import print_function
 
from pprint import pprint
from math import sqrt
 
 
def cholesky(A):
    L = [[0.0] * len(A) for _ in xrange(len(A))]
    for i in xrange(len(A)):
        for j in xrange(i+1):
            s = sum(L[i][k] * L[j][k] for k in xrange(j))
            L[i][j] = sqrt(A[i][i] - s) if (i == j) else \
                      (1.0 / L[j][j] * (A[i][j] - s))
    return L
 
if __name__ == ""__main__"":
    m1 = [[25, 15, -5],
          [15, 18,  0],
          [-5,  0, 11]]
    pprint(cholesky(m1))
    print()
 
    m2 = [[18, 22,  54,  42],
          [22, 70,  86,  62],
          [54, 86, 174, 134],
          [42, 62, 134, 106]]
    pprint(cholesky(m2), width=120)"
32ls,python,Chowla numbers,Mathematics,Number Theory,"# https://docs.sympy.org/latest/modules/ntheory.html#sympy.ntheory.factor_.divisors
from sympy import divisors
 
def chowla(n):
    return 0 if n < 2 else sum(divisors(n, generator=True)) - 1 -n
 
def is_prime(n):
    return chowla(n) == 0
 
def primes_to(n):
    return sum(chowla(i) == 0 for i in range(2, n))
 
def perfect_between(n, m):
    c = 0
    print(f""\nPerfect numbers between [{n:_}, {m:_})"")
    for i in range(n, m):
        if i > 1 and chowla(i) == i - 1:
            print(f""  {i:_}"")
            c += 1
    print(f""Found {c} Perfect numbers between [{n:_}, {m:_})"")
 
 
if __name__ == '__main__':
    for i in range(1, 38):
        print(f""chowla({i:2}) == {chowla(i)}"")
    for i in range(2, 6):
        print(f""primes_to({10**i:_}) == {primes_to(10**i):_}"")
    perfect_between(1, 1_000_000)
    print()
    for i in range(6, 8):
        print(f""primes_to({10**i:_}) == {primes_to(10**i):_}"")
    perfect_between(1_000_000, 35_000_000)"
jajy,python,Church numerals,Mathematics,Mathematical Sequences and Series,"'''Church numerals'''
 
from itertools import repeat
from functools import reduce
 
 
# ----- CHURCH ENCODINGS OF NUMERALS AND OPERATIONS ------
 
def churchZero():
    '''The identity function.
       No applications of any supplied f
       to its argument.
    '''
    return lambda f: identity
 
 
def churchSucc(cn):
    '''The successor of a given
       Church numeral. One additional
       application of f. Equivalent to
       the arithmetic addition of one.
    '''
    return lambda f: compose(f)(cn(f))
 
 
def churchAdd(m):
    '''The arithmetic sum of two Church numerals.'''
    return lambda n: lambda f: compose(m(f))(n(f))
 
 
def churchMult(m):
    '''The arithmetic product of two Church numerals.'''
    return lambda n: compose(m)(n)
 
 
def churchExp(m):
    '''Exponentiation of Church numerals. m^n'''
    return lambda n: n(m)
 
 
def churchFromInt(n):
    '''The Church numeral equivalent of
       a given integer.
    '''
    return lambda f: (
        foldl
        (compose)
        (identity)
        (replicate(n)(f))
    )
 
 
# OR, alternatively:
def churchFromInt_(n):
    '''The Church numeral equivalent of a given
       integer, by explicit recursion.
    '''
    if 0 == n:
        return churchZero()
    else:
        return churchSucc(churchFromInt(n - 1))
 
 
def intFromChurch(cn):
    '''The integer equivalent of a
       given Church numeral.
    '''
    return cn(succ)(0)
 
 
# ------------------------- TEST -------------------------
# main :: IO ()
def main():
    'Tests'
 
    cThree = churchFromInt(3)
    cFour = churchFromInt(4)
 
    print(list(map(intFromChurch, [
        churchAdd(cThree)(cFour),
        churchMult(cThree)(cFour),
        churchExp(cFour)(cThree),
        churchExp(cThree)(cFour),
    ])))
 
 
# ------------------ GENERIC FUNCTIONS -------------------
 
# compose (flip (.)) :: (a -> b) -> (b -> c) -> a -> c
def compose(f):
    '''A left to right composition of two
       functions f and g'''
    return lambda g: lambda x: g(f(x))
 
 
# foldl :: (a -> b -> a) -> a -> [b] -> a
def foldl(f):
    '''Left to right reduction of a list,
       using the binary operator f, and
       starting with an initial value a.
    '''
    def go(acc, xs):
        return reduce(lambda a, x: f(a)(x), xs, acc)
    return lambda acc: lambda xs: go(acc, xs)
 
 
# identity :: a -> a
def identity(x):
    '''The identity function.'''
    return x
 
 
# replicate :: Int -> a -> [a]
def replicate(n):
    '''A list of length n in which every
       element has the value x.
    '''
    return lambda x: repeat(x, n)
 
 
# succ :: Enum a => a -> a
def succ(x):
    '''The successor of a value.
       For numeric types, (1 +).
    '''
    return 1 + x if isinstance(x, int) else (
        chr(1 + ord(x))
    )
 
 
if __name__ == '__main__':
    main()"
mhll,python,Circles of given radius through two points,Mathematics,Geometry and Trigonometry,"from collections import namedtuple
from math import sqrt
 
Pt = namedtuple('Pt', 'x, y')
Circle = Cir = namedtuple('Circle', 'x, y, r')
 
def circles_from_p1p2r(p1, p2, r):
    'Following explanation at http://mathforum.org/library/drmath/view/53027.html'
    if r == 0.0:
        raise ValueError('radius of zero')
    (x1, y1), (x2, y2) = p1, p2
    if p1 == p2:
        raise ValueError('coincident points gives infinite number of Circles')
    # delta x, delta y between points
    dx, dy = x2 - x1, y2 - y1
    # dist between points
    q = sqrt(dx**2 + dy**2)
    if q > 2.0*r:
        raise ValueError('separation of points > diameter')
    # halfway point
    x3, y3 = (x1+x2)/2, (y1+y2)/2
    # distance along the mirror line
    d = sqrt(r**2-(q/2)**2)
    # One answer
    c1 = Cir(x = x3 - d*dy/q,
             y = y3 + d*dx/q,
             r = abs(r))
    # The other answer
    c2 = Cir(x = x3 + d*dy/q,
             y = y3 - d*dx/q,
             r = abs(r))
    return c1, c2
 
if __name__ == '__main__':
    for p1, p2, r in [(Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 2.0),
                      (Pt(0.0000, 2.0000), Pt(0.0000, 0.0000), 1.0),
                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 2.0),
                      (Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 0.5),
                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 0.0)]:
        print('Through points:\n  %r,\n  %r\n  and radius %f\nYou can construct the following circles:'
              % (p1, p2, r))
        try:
            print('  %r\n  %r\n' % circles_from_p1p2r(p1, p2, r))
        except ValueError as v:
            print('  ERROR: %s\n' % (v.args[0],))"
3iob,python,Circular primes,Mathematics,Number Theory," 
import random
 
def is_Prime(n):
    """"""
    Miller-Rabin primality test.
 
    A return value of False means n is certainly not prime. A return value of
    True means n is very likely a prime.
    """"""
    if n!=int(n):
        return False
    n=int(n)
    #Miller-Rabin test for prime
    if n==0 or n==1 or n==4 or n==6 or n==8 or n==9:
        return False
 
    if n==2 or n==3 or n==5 or n==7:
        return True
    s = 0
    d = n-1
    while d%2==0:
        d>>=1
        s+=1
    assert(2**s * d == n-1)
 
    def trial_composite(a):
        if pow(a, d, n) == 1:
            return False
        for i in range(s):
            if pow(a, 2**i * d, n) == n-1:
                return False
        return True
 
    for i in range(8):#number of trials
        a = random.randrange(2, n)
        if trial_composite(a):
            return False
 
    return True
 
def isPrime(n: int) -> bool:
    '''
        https://www.geeksforgeeks.org/python-program-to-check-whether-a-number-is-prime-or-not/
    '''
    # Corner cases
    if (n <= 1) :
        return False
    if (n <= 3) :
        return True
    # This is checked so that we can skip
    # middle five numbers in below loop
    if (n % 2 == 0 or n % 3 == 0) :
        return False
    i = 5
    while(i * i <= n) :
        if (n % i == 0 or n % (i + 2) == 0) :
            return False
        i = i + 6
    return True
 
def rotations(n: int)-> set((int,)):
    '''
        >>> {123, 231, 312} == rotations(123)
        True
    '''
    a = str(n)
    return set(int(a[i:] + a[:i]) for i in range(len(a)))
 
def isCircular(n: int) -> bool:
    '''
        >>> [isCircular(n) for n in (11, 31, 47,)]
	[True, True, False]
    '''
    return all(isPrime(int(o)) for o in rotations(n))
 
from itertools import product
 
def main():
    result = [2, 3, 5, 7]
    first = '137'
    latter = '1379'
    for i in range(1, 6):
        s = set(int(''.join(a)) for a in product(first, *((latter,) * i)))
        while s:
            a = s.pop()
            b = rotations(a)
            if isCircular(a):
                result.append(min(b))
            s -= b
    result.sort()
    return result
 
assert [2, 3, 5, 7, 11, 13, 17, 37, 79, 113, 197, 199, 337, 1193, 3779, 11939, 19937, 193939, 199933] == main()
 
 
repunit = lambda n: int('1' * n)
 
def repmain(n: int) -> list:
    '''
        returns the first n repunit primes, probably.
    '''
    result = []
    i = 2
    while len(result) < n:
        if is_Prime(repunit(i)):
            result.append(i)
        i += 1
    return result
 
assert [2, 19, 23, 317, 1031] == repmain(5)
 
# because this Miller-Rabin test is already on rosettacode there's no good reason to test the longer repunits.
 "
aoin,python,Cistercian numerals,Mathematics,Number Theory,"# -*- coding: utf-8 -*-
""""""
Some UTF-8 chars used:
 
‾	8254	203E	&oline;	OVERLINE
┃	9475	2503	 	BOX DRAWINGS HEAVY VERTICAL
╱	9585	2571	 	BOX DRAWINGS LIGHT DIAGONAL UPPER RIGHT TO LOWER LEFT
╲	9586	2572	 	BOX DRAWINGS LIGHT DIAGONAL UPPER LEFT TO LOWER RIGHT
◸	9720	25F8	 	UPPER LEFT TRIANGLE
◹	9721	25F9	 	UPPER RIGHT TRIANGLE
◺	9722	25FA	 	LOWER LEFT TRIANGLE
◻	9723	25FB	 	WHITE MEDIUM SQUARE
◿	9727	25FF	 	LOWER RIGHT TRIANGLE
 
""""""
 
#%% digit sections
 
def _init():
    ""digit sections for forming numbers""
    digi_bits = """"""
#0  1   2  3  4  5  6   7   8   9
#
 .  ‾   _  ╲  ╱  ◸  .|  ‾|  _|  ◻
#
 .  ‾   _  ╱  ╲  ◹  |.  |‾  |_  ◻
#
 .  _  ‾   ╱  ╲  ◺  .|  _|  ‾|  ◻
#
 .  _  ‾   ╲  ╱  ◿  |.  |_  |‾  ◻
 
"""""".strip()
 
    lines = [[d.replace('.', ' ') for d in ln.strip().split()]
             for ln in digi_bits.strip().split('\n')
             if '#' not in ln]
    formats = '<2 >2 <2 >2'.split()
    digits = [[f""{dig:{f}}"" for dig in line]
              for f, line in zip(formats, lines)]
 
    return digits
 
_digits = _init()
 
 
#%% int to 3-line strings
def _to_digits(n):
    assert 0 <= n < 10_000 and int(n) == n
 
    return [int(digit) for digit in f""{int(n):04}""][::-1]
 
def num_to_lines(n):
    global _digits
    d = _to_digits(n)
    lines = [
        ''.join((_digits[1][d[1]], '┃',  _digits[0][d[0]])),
        ''.join((_digits[0][   0], '┃',  _digits[0][   0])),
        ''.join((_digits[3][d[3]], '┃',  _digits[2][d[2]])),
        ]
 
    return lines
 
def cjoin(c1, c2, spaces='   '):
    return [spaces.join(by_row) for by_row in zip(c1, c2)]
 
#%% main
if __name__ == '__main__':
    #n = 6666
    #print(f""Arabic {n} to Cistercian:\n"")
    #print('\n'.join(num_to_lines(n)))
 
    for pow10 in range(4):    
        step = 10 ** pow10
        print(f'\nArabic {step}-to-{9*step} by {step} in Cistercian:\n')
        lines = num_to_lines(step)
        for n in range(step*2, step*10, step):
            lines = cjoin(lines, num_to_lines(n))
        print('\n'.join(lines))
 
 
    numbers = [0, 5555, 6789, 6666]
    print(f'\nArabic {str(numbers)[1:-1]} in Cistercian:\n')
    lines = num_to_lines(numbers[0])
    for n in numbers[1:]:
        lines = cjoin(lines, num_to_lines(n))
    print('\n'.join(lines))"
3lz0,python,Classes,Programming Concepts,Fundamentals,"class MyClass:
    name2 = 2 # Class attribute
 
    def __init__(self):
        """"""
        Constructor  (Technically an initializer rather than a true ""constructor"")
        """"""
        self.name1 = 0 # Instance attribute
 
    def someMethod(self):
        """"""
        Method
        """"""
        self.name1 = 1
        MyClass.name2 = 3
 
 
myclass = MyClass() # class name, invoked as a function is the constructor syntax.
 
class MyOtherClass:
    count = 0  # Population of ""MyOtherClass"" objects
    def __init__(self, name, gender=""Male"", age=None):
        """"""
        One initializer required, others are optional (with different defaults)
        """"""
        MyOtherClass.count += 1
        self.name = name
        self.gender = gender
        if age is not None:
            self.age = age
    def __del__(self):
        MyOtherClass.count -= 1
 
person1 = MyOtherClass(""John"")
print person1.name, person1.gender  # ""John Male""
print person1.age                   # Raises AttributeError exception!
person2 = MyOtherClass(""Jane"", ""Female"", 23)
print person2.name, person2.gender, person2.age  # ""Jane Female 23"""
7osc,python,Closest-pair problem,Algorithms and Data Structures,Algorithms,"""""""
  Compute nearest pair of points using two algorithms
 
  First algorithm is 'brute force' comparison of every possible pair.
  Second, 'divide and conquer', is based on:
    www.cs.iupui.edu/~xkzou/teaching/CS580/Divide-and-conquer-closestPair.ppt 
""""""
 
from random import randint, randrange
from operator import itemgetter, attrgetter
 
infinity = float('inf')
 
# Note the use of complex numbers to represent 2D points making distance == abs(P1-P2)
 
def bruteForceClosestPair(point):
    numPoints = len(point)
    if numPoints < 2:
        return infinity, (None, None)
    return min( ((abs(point[i] - point[j]), (point[i], point[j]))
                 for i in range(numPoints-1)
                 for j in range(i+1,numPoints)),
                key=itemgetter(0))
 
def closestPair(point):
    xP = sorted(point, key= attrgetter('real'))
    yP = sorted(point, key= attrgetter('imag'))
    return _closestPair(xP, yP)
 
def _closestPair(xP, yP):
    numPoints = len(xP)
    if numPoints <= 3:
        return bruteForceClosestPair(xP)
    Pl = xP[:numPoints/2]
    Pr = xP[numPoints/2:]
    Yl, Yr = [], []
    xDivider = Pl[-1].real
    for p in yP:
        if p.real <= xDivider:
            Yl.append(p)
        else:
            Yr.append(p)
    dl, pairl = _closestPair(Pl, Yl)
    dr, pairr = _closestPair(Pr, Yr)
    dm, pairm = (dl, pairl) if dl < dr else (dr, pairr)
    # Points within dm of xDivider sorted by Y coord
    closeY = [p for p in yP  if abs(p.real - xDivider) < dm]
    numCloseY = len(closeY)
    if numCloseY > 1:
        # There is a proof that you only need compare a max of 7 next points
        closestY = min( ((abs(closeY[i] - closeY[j]), (closeY[i], closeY[j]))
                         for i in range(numCloseY-1)
                         for j in range(i+1,min(i+8, numCloseY))),
                        key=itemgetter(0))
        return (dm, pairm) if dm <= closestY[0] else closestY
    else:
        return dm, pairm
 
def times():
    ''' Time the different functions
    '''
    import timeit
 
    functions = [bruteForceClosestPair, closestPair]
    for f in functions:
        print 'Time for', f.__name__, timeit.Timer(
            '%s(pointList)' % f.__name__,
            'from closestpair import %s, pointList' % f.__name__).timeit(number=1)
 
 
 
pointList = [randint(0,1000)+1j*randint(0,1000) for i in range(2000)]
 
if __name__ == '__main__':
    pointList = [(5+9j), (9+3j), (2+0j), (8+4j), (7+4j), (9+10j), (1+9j), (8+2j), 10j, (9+6j)]
    print pointList
    print '  bruteForceClosestPair:', bruteForceClosestPair(pointList)
    print '            closestPair:', closestPair(pointList)
    for i in range(10):
        pointList = [randrange(11)+1j*randrange(11) for i in range(10)]
        print '\n', pointList
        print ' bruteForceClosestPair:', bruteForceClosestPair(pointList)
        print '           closestPair:', closestPair(pointList)
    print '\n'
    times()
    times()
    times()"
khwm,python,Closures/Value capture,Programming Concepts,Fundamentals,"funcs = []
for i in range(10):
    funcs.append(lambda: i * i)
print funcs[3]() # prints 81"
oj6y,python,Collections,Algorithms and Data Structures,Data Structures,"collection = [0, '1']                 # Lists are mutable (editable) and can be sorted in place
x = collection[0]                     # accessing an item (which happens to be a numeric 0 (zero)
collection.append(2)                  # adding something to the end of the list
collection.insert(0, '-1')            # inserting a value into the beginning
y = collection[0]                     # now returns a string of ""-1""
collection.extend([2,'3'])            # same as [collection.append(i) for i in [2,'3']] ... but faster
collection += [2,'3']                 # same as previous line
collection[2:6]                       # a ""slice"" (collection of the list elements from the third up to but not including the sixth)
len(collection)                       # get the length of (number of elements in) the collection
collection = (0, 1)                   # Tuples are immutable (not editable)
collection[:]                         # ... slices work on these too; and this is equivalent to collection[0:len(collection)]
collection[-4:-1]                     # negative slices count from the end of the string
collection[::2]                       # slices can also specify a stride --- this returns all even elements of the collection
collection=""some string""              # strings are treated as sequences of characters
x = collection[::-1]                  # slice with negative step returns reversed sequence (string in this case).
collection[::2] == ""some string""[::2] # True, literal objects don't need to be bound to name/variable to access slices or object methods
collection.__getitem__(slice(0,len(collection),2))  # same as previous expressions.
collection = {0: ""zero"", 1: ""one""}    # Dictionaries (Hash)
collection['zero'] = 2                # Dictionary members accessed using same syntax as list/array indexes.
collection = set([0, '1'])            # sets (Hash)"
wk3r,python,Color of a screen pixel,Graphics and Visualization,Graphics Programming,"def get_pixel_colour(i_x, i_y):
	import win32gui
	i_desktop_window_id = win32gui.GetDesktopWindow()
	i_desktop_window_dc = win32gui.GetWindowDC(i_desktop_window_id)
	long_colour = win32gui.GetPixel(i_desktop_window_dc, i_x, i_y)
	i_colour = int(long_colour)
	win32gui.ReleaseDC(i_desktop_window_id,i_desktop_window_dc)
	return (i_colour & 0xff), ((i_colour >> 8) & 0xff), ((i_colour >> 16) & 0xff)
 
print (get_pixel_colour(0, 0))"
3ysz,python,Color quantization,Graphics and Visualization,Graphics Programming,"from PIL import Image
 
if __name__==""__main__"":
	im = Image.open(""frog.png"")
	im2 = im.quantize(16)
	im2.show()"
fs16,python,Color wheel,Graphics and Visualization,Graphics Programming,"from PIL import Image
import colorsys
import math
 
if __name__ == ""__main__"":
 
    im = Image.new(""RGB"", (300,300))
    radius = min(im.size)/2.0
    cx, cy = im.size[0]/2, im.size[1]/2
    pix = im.load()
 
    for x in range(im.width):
        for y in range(im.height):
            rx = x - cx
            ry = y - cy
            s = (rx ** 2.0 + ry ** 2.0) ** 0.5 / radius
            if s <= 1.0:
                h = ((math.atan2(ry, rx) / math.pi) + 1.0) / 2.0
                rgb = colorsys.hsv_to_rgb(h, s, 1.0)
                pix[x,y] = tuple([int(round(c*255.0)) for c in rgb])
 
    im.show()"
491e,python,Colour bars/Display,Graphics and Visualization,Graphics Programming," 
#!/usr/bin/env python
#vertical coloured stripes in window in Python 2.7.1
 
from livewires import *
 
horiz=640; vert=480
begin_graphics(width=horiz,height=vert,title=""v_stripes"",background=Colour.black)
NameColors=[""black"",""red"",""green"",""dark_blue"",""purple"",""blue"",""yellow"",""white""]
stepik=horiz/len(NameColors)
 
for index,each in enumerate(NameColors):
	ExcStrng=""set_colour(Colour.""+each+"")""
	exec ExcStrng
	box(index*stepik,0,(index+1)*stepik,vert,filled=1)
 
while keys_pressed() != ['x']: # press x key to terminate program
	pass
 
end_graphics()
 "
srop,python,Colour pinstripe/Display,Graphics and Visualization,Graphics Programming," 
from turtle import *
 
colors = [""black"", ""red"", ""green"", ""blue"", ""magenta"", ""cyan"", ""yellow"", ""white""]
 
# Middle of screen is 0,0
 
screen = getscreen()
 
left_edge = -screen.window_width()//2
 
right_edge = screen.window_width()//2
 
quarter_height = screen.window_height()//4
 
half_height = quarter_height * 2
 
speed(""fastest"")
 
for quarter in range(4):
    pensize(quarter+1)
    colornum = 0
 
    min_y = half_height - ((quarter + 1) * quarter_height)
    max_y = half_height - ((quarter) * quarter_height)
 
    for x in range(left_edge,right_edge,quarter+1):
        penup()
        pencolor(colors[colornum])
        colornum = (colornum + 1) % len(colors)
        setposition(x,min_y)
        pendown()
        setposition(x,max_y)
 
notused = input(""Hit enter to continue: "")
 "
l3wq,python,Colour pinstripe/Printer,Graphics and Visualization,Graphics Programming," 
from turtle import *
from PIL import Image
import time
import subprocess
 
""""""
 
Only works on Windows. Assumes that you have Ghostscript
installed and in your path.
 
https://www.ghostscript.com/download/gsdnld.html
 
Hard coded to 100 pixels per inch.
 
""""""
 
colors = [""black"", ""red"", ""green"", ""blue"", ""magenta"", ""cyan"", ""yellow"", ""white""]
 
screen = getscreen()
 
# width and height in pixels
# aspect ratio for 11 by 8.5 paper
 
inch_width = 11.0
inch_height = 8.5
 
pixels_per_inch = 100
 
pix_width = int(inch_width*pixels_per_inch)
pix_height = int(inch_height*pixels_per_inch)
 
screen.setup (width=pix_width, height=pix_height, startx=0, starty=0)
 
screen.screensize(pix_width,pix_height)
 
# center is 0,0
 
# get coordinates of the edges
 
left_edge = -screen.window_width()//2
 
right_edge = screen.window_width()//2
 
bottom_edge = -screen.window_height()//2
 
top_edge = screen.window_height()//2
 
# draw quickly
 
screen.delay(0)
screen.tracer(5)
 
for inch in range(int(inch_width)-1):
    line_width = inch + 1
    pensize(line_width)
    colornum = 0
 
    min_x = left_edge + (inch * pixels_per_inch)
    max_x = left_edge + ((inch+1) * pixels_per_inch)
 
    for y in range(bottom_edge,top_edge,line_width):
        penup()
        pencolor(colors[colornum])
        colornum = (colornum + 1) % len(colors)
        setposition(min_x,y)
        pendown()
        setposition(max_x,y)
 
screen.getcanvas().postscript(file=""striped.eps"")
 
# convert to jpeg
# won't work without Ghostscript.
 
im = Image.open(""striped.eps"")
im.save(""striped.jpg"")
 
# Got idea from http://rosettacode.org/wiki/Colour_pinstripe/Printer#Go
 
subprocess.run([""mspaint"", ""/pt"", ""striped.jpg""])
 "
b5sl,python,Combinations,Mathematics,Combinatorics,">>> from itertools import combinations
>>> list(combinations(range(5),3))
[(0, 1, 2), (0, 1, 3), (0, 1, 4), (0, 2, 3), (0, 2, 4), (0, 3, 4), (1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]"
wvzp,python,Combinations and permutations,Mathematics,Combinatorics,"from __future__ import print_function
 
from scipy.misc import factorial as fact
from scipy.misc import comb
 
def perm(N, k, exact=0):
    return comb(N, k, exact) * fact(k, exact)
 
exact=True
print('Sample Perms 1..12')
for N in range(1, 13):
    k = max(N-2, 1)
    print('%iP%i =' % (N, k), perm(N, k, exact), end=', ' if N % 5 else '\n')
 
print('\n\nSample Combs 10..60')
for N in range(10, 61, 10):
    k = N-2
    print('%iC%i =' % (N, k), comb(N, k, exact), end=', ' if N % 50 else '\n')
 
exact=False
print('\n\nSample Perms 5..1500 Using FP approximations')
for N in [5, 15, 150, 1500, 15000]:
    k = N-2
    print('%iP%i =' % (N, k), perm(N, k, exact))
 
print('\nSample Combs 100..1000 Using FP approximations')
for N in range(100, 1001, 100):
    k = N-2
    print('%iC%i =' % (N, k), comb(N, k, exact))
 "
9cev,python,Combinations with repetitions,Mathematics,Combinatorics,">>> from itertools import combinations_with_replacement
>>> n, k = 'iced jam plain'.split(), 2
>>> list(combinations_with_replacement(n,k))
[('iced', 'iced'), ('iced', 'jam'), ('iced', 'plain'), ('jam', 'jam'), ('jam', 'plain'), ('plain', 'plain')]
>>> # Extra credit
>>> len(list(combinations_with_replacement(range(10), 3)))
220
>>> "
k95u,python,Comma quibbling,Puzzles and Games,Puzzle Solving Algorithms,">>> def strcat(sequence):
    return '{%s}' % ', '.join(sequence)[::-1].replace(',', 'dna ', 1)[::-1]
 
>>> for seq in ([], [""ABC""], [""ABC"", ""DEF""], [""ABC"", ""DEF"", ""G"", ""H""]):
    print('Input: %-24r -> Output: %r' % (seq, strcat(seq)))
 
 
Input: []                       -> Output: '{}'
Input: ['ABC']                  -> Output: '{ABC}'
Input: ['ABC', 'DEF']           -> Output: '{ABC and DEF}'
Input: ['ABC', 'DEF', 'G', 'H'] -> Output: '{ABC, DEF, G and H}'
>>> "
fohg,python,Command-line arguments,Operating Systems and Shell Programming,Shell and Command-Line,"import sys
program_name = sys.argv[0]
arguments = sys.argv[1:]
count = len(arguments)"
w77a,python,Commatizing numbers,Text Processing,String Manipulation," 
import re as RegEx
 
 
def Commatize( _string, _startPos=0, _periodLen=3, _separator="","" ):
	outString = """"
	strPos = 0
	matches = RegEx.findall( ""[0-9]*"", _string )
 
	for match in matches[:-1]:
		if not match:
			outString += _string[ strPos ]
			strPos += 1
		else:
			if len(match) > _periodLen:
				leadIn = match[:_startPos]
				periods =  [ match [ i:i + _periodLen ] for i in range ( _startPos, len ( match ), _periodLen ) ]
				outString += leadIn + _separator.join( periods )
			else:
				outString += match
 
			strPos += len( match )
 
	return outString
 
 
 
print ( Commatize( ""pi=3.14159265358979323846264338327950288419716939937510582097494459231"", 0, 5, "" "" ) )
print ( Commatize( ""The author has two Z$100000000000000 Zimbabwe notes (100 trillion)."", 0, 3, ""."" ))
print ( Commatize( ""\""-in Aus$+1411.8millions\"""" ))
print ( Commatize( ""===US$0017440 millions=== (in 2000 dollars)"" ))
print ( Commatize( ""123.e8000 is pretty big."" ))
print ( Commatize( ""The land area of the earth is 57268900(29% of the surface) square miles."" ))
print ( Commatize( ""Ain't no numbers in this here words, nohow, no way, Jose."" ))
print ( Commatize( ""James was never known as 0000000007"" ))
print ( Commatize( ""Arthur Eddington wrote: I believe there are 15747724136275002577605653961181555468044717914527116709366231425076185631031296 protons in the universe."" ))
print ( Commatize( ""␢␢␢$-140000±100 millions."" ))
print ( Commatize( ""6/9/1946 was a good year for some."" ))
 "
8jl4,python,Comments,Programming Concepts,Fundamentals,"# This is a comment
foo = 5 # You can also append comments to statements"
zivw,python,Compare a list of strings,Text Processing,String Manipulation,"all(a == nexta for a, nexta in zip(strings, strings[1:])) # All equal
all(a < nexta for a, nexta in zip(strings, strings[1:])) # Strictly ascending
 
len(set(strings)) == 1  # Concise all equal
sorted(strings, reverse=True) == strings  # Concise (but not particularly efficient) ascending
 "
idf9,python,Compare length of two strings,Text Processing,String Manipulation,"A = 'I am string'
B = 'I am string too'
 
if len(A) > len(B):
    print('""' + A + '""', 'has length', len(A), 'and is the longest of the two strings')
    print('""' + B + '""', 'has length', len(B), 'and is the shortest of the two strings')
elif len(A) < len(B):
    print('""' + B + '""', 'has length', len(B), 'and is the longest of the two strings')
    print('""' + A + '""', 'has length', len(A), 'and is the shortest of the two strings')
else:
    print('""' + A + '""', 'has length', len(A), 'and it is as long as the second string')
    print('""' + B + '""', 'has length', len(B), 'and it is as long as the second string')"
x8qp,python,Compare sorting algorithms' performance,Algorithms and Data Structures,Algorithms,"def builtinsort(x):
    x.sort()
 
def partition(seq, pivot):
   low, middle, up = [], [], []
   for x in seq:
       if x < pivot:
           low.append(x)
       elif x == pivot:
           middle.append(x)
       else:
           up.append(x)
   return low, middle, up
import random
def qsortranpart(seq):
   size = len(seq)
   if size < 2: return seq
   low, middle, up = partition(seq, random.choice(seq))
   return qsortranpart(low) + middle + qsortranpart(up)"
7kb2,python,Compiler/AST interpreter,Programming Concepts,Advanced Concepts,"from __future__ import print_function
import sys, shlex, operator
 
nd_Ident, nd_String, nd_Integer, nd_Sequence, nd_If, nd_Prtc, nd_Prts, nd_Prti, nd_While, \
nd_Assign, nd_Negate, nd_Not, nd_Mul, nd_Div, nd_Mod, nd_Add, nd_Sub, nd_Lss, nd_Leq,     \
nd_Gtr, nd_Geq, nd_Eql, nd_Neq, nd_And, nd_Or = range(25)
 
all_syms = {
    ""Identifier""  : nd_Ident,    ""String""      : nd_String,
    ""Integer""     : nd_Integer,  ""Sequence""    : nd_Sequence,
    ""If""          : nd_If,       ""Prtc""        : nd_Prtc,
    ""Prts""        : nd_Prts,     ""Prti""        : nd_Prti,
    ""While""       : nd_While,    ""Assign""      : nd_Assign,
    ""Negate""      : nd_Negate,   ""Not""         : nd_Not,
    ""Multiply""    : nd_Mul,      ""Divide""      : nd_Div,
    ""Mod""         : nd_Mod,      ""Add""         : nd_Add,
    ""Subtract""    : nd_Sub,      ""Less""        : nd_Lss,
    ""LessEqual""   : nd_Leq,      ""Greater""     : nd_Gtr,
    ""GreaterEqual"": nd_Geq,      ""Equal""       : nd_Eql,
    ""NotEqual""    : nd_Neq,      ""And""         : nd_And,
    ""Or""          : nd_Or}
 
input_file  = None
globals     = {}
 
#*** show error and exit
def error(msg):
    print(""%s"" % (msg))
    exit(1)
 
class Node:
    def __init__(self, node_type, left = None, right = None, value = None):
        self.node_type  = node_type
        self.left  = left
        self.right = right
        self.value = value
 
#***
def make_node(oper, left, right = None):
    return Node(oper, left, right)
 
#***
def make_leaf(oper, n):
    return Node(oper, value = n)
 
#***
def fetch_var(var_name):
    n = globals.get(var_name, None)
    if n == None:
        globals[var_name] = n = 0
    return n
 
#***
def interp(x):
    global globals
 
    if x == None: return None
    elif x.node_type == nd_Integer: return int(x.value)
    elif x.node_type == nd_Ident:   return fetch_var(x.value)
    elif x.node_type == nd_String:  return x.value
 
    elif x.node_type == nd_Assign:
                    globals[x.left.value] = interp(x.right)
                    return None
    elif x.node_type == nd_Add:     return interp(x.left) +   interp(x.right)
    elif x.node_type == nd_Sub:     return interp(x.left) -   interp(x.right)
    elif x.node_type == nd_Mul:     return interp(x.left) *   interp(x.right)
    # use C like division semantics
    # another way: abs(x) / abs(y) * cmp(x, 0) * cmp(y, 0)
    elif x.node_type == nd_Div:     return int(float(interp(x.left)) / interp(x.right))
    elif x.node_type == nd_Mod:     return int(float(interp(x.left)) % interp(x.right))
    elif x.node_type == nd_Lss:     return interp(x.left) <   interp(x.right)
    elif x.node_type == nd_Gtr:     return interp(x.left) >   interp(x.right)
    elif x.node_type == nd_Leq:     return interp(x.left) <=  interp(x.right)
    elif x.node_type == nd_Geq:     return interp(x.left) >=  interp(x.right)
    elif x.node_type == nd_Eql:     return interp(x.left) ==  interp(x.right)
    elif x.node_type == nd_Neq:     return interp(x.left) !=  interp(x.right)
    elif x.node_type == nd_And:     return interp(x.left) and interp(x.right)
    elif x.node_type == nd_Or:      return interp(x.left) or  interp(x.right)
    elif x.node_type == nd_Negate:  return -interp(x.left)
    elif x.node_type == nd_Not:     return not interp(x.left)
 
    elif x.node_type ==  nd_If:
                    if (interp(x.left)):
                        interp(x.right.left)
                    else:
                        interp(x.right.right)
                    return None
 
    elif x.node_type == nd_While:
                    while (interp(x.left)):
                        interp(x.right)
                    return None
 
    elif x.node_type == nd_Prtc:
                    print(""%c"" % (interp(x.left)), end='')
                    return None
 
    elif x.node_type == nd_Prti:
                    print(""%d"" % (interp(x.left)), end='')
                    return None
 
    elif x.node_type == nd_Prts:
                    print(interp(x.left), end='')
                    return None
 
    elif x.node_type == nd_Sequence:
                    interp(x.left)
                    interp(x.right)
                    return None
    else:
        error(""error in code generator - found %d, expecting operator"" % (x.node_type))
 
def str_trans(srce):
    dest = """"
    i = 0
    srce = srce[1:-1]
    while i < len(srce):
        if srce[i] == '\\' and i + 1 < len(srce):
            if srce[i + 1] == 'n':
                dest += '\n'
                i += 2
            elif srce[i + 1] == '\\':
                dest += '\\'
                i += 2
        else:
            dest += srce[i]
            i += 1
 
    return dest
 
def load_ast():
    line = input_file.readline()
    line_list = shlex.split(line, False, False)
 
    text = line_list[0]
 
    value = None
    if len(line_list) > 1:
        value = line_list[1]
        if value.isdigit():
            value = int(value)
 
    if text == "";"":
        return None
    node_type = all_syms[text]
    if value != None:
        if node_type == nd_String:
            value = str_trans(value)
 
        return make_leaf(node_type, value)
    left = load_ast()
    right = load_ast()
    return make_node(node_type, left, right)
 
#*** main driver
input_file = sys.stdin
if len(sys.argv) > 1:
    try:
        input_file = open(sys.argv[1], ""r"", 4096)
    except IOError as e:
        error(0, 0, ""Can't open %s"" % sys.argv[1])
 
n = load_ast()
interp(n)"
om5j,python,Compiler/code generator,Programming Concepts,Advanced Concepts,"from __future__ import print_function
import sys, struct, shlex, operator
 
nd_Ident, nd_String, nd_Integer, nd_Sequence, nd_If, nd_Prtc, nd_Prts, nd_Prti, nd_While, \
nd_Assign, nd_Negate, nd_Not, nd_Mul, nd_Div, nd_Mod, nd_Add, nd_Sub, nd_Lss, nd_Leq,     \
nd_Gtr, nd_Geq, nd_Eql, nd_Neq, nd_And, nd_Or = range(25)
 
all_syms = {
    ""Identifier""  : nd_Ident,    ""String""      : nd_String,
    ""Integer""     : nd_Integer,  ""Sequence""    : nd_Sequence,
    ""If""          : nd_If,       ""Prtc""        : nd_Prtc,
    ""Prts""        : nd_Prts,     ""Prti""        : nd_Prti,
    ""While""       : nd_While,    ""Assign""      : nd_Assign,
    ""Negate""      : nd_Negate,   ""Not""         : nd_Not,
    ""Multiply""    : nd_Mul,      ""Divide""      : nd_Div,
    ""Mod""         : nd_Mod,      ""Add""         : nd_Add,
    ""Subtract""    : nd_Sub,      ""Less""        : nd_Lss,
    ""LessEqual""   : nd_Leq,      ""Greater""     : nd_Gtr,
    ""GreaterEqual"": nd_Geq,      ""Equal""       : nd_Eql,
    ""NotEqual""    : nd_Neq,      ""And""         : nd_And,
    ""Or""          : nd_Or}
 
FETCH, STORE, PUSH, ADD, SUB, MUL, DIV, MOD, LT, GT, LE, GE, EQ, NE, AND, OR, NEG, NOT, \
JMP, JZ, PRTC, PRTS, PRTI, HALT = range(24)
 
operators = {nd_Lss: LT, nd_Gtr: GT, nd_Leq: LE, nd_Geq: GE, nd_Eql: EQ, nd_Neq: NE,
    nd_And: AND, nd_Or: OR, nd_Sub: SUB, nd_Add: ADD, nd_Div: DIV, nd_Mul: MUL, nd_Mod: MOD}
 
unary_operators = {nd_Negate: NEG, nd_Not: NOT}
 
input_file  = None
code        = bytearray()
string_pool = {}
globals     = {}
string_n    = 0
globals_n   = 0
word_size   = 4
 
#*** show error and exit
def error(msg):
    print(""%s"" % (msg))
    exit(1)
 
def int_to_bytes(val):
    return struct.pack(""<i"", val)
 
def bytes_to_int(bstr):
    return struct.unpack(""<i"", bstr)
 
class Node:
    def __init__(self, node_type, left = None, right = None, value = None):
        self.node_type  = node_type
        self.left  = left
        self.right = right
        self.value = value
 
#***
def make_node(oper, left, right = None):
    return Node(oper, left, right)
 
#***
def make_leaf(oper, n):
    return Node(oper, value = n)
 
#***
def emit_byte(x):
    code.append(x)
 
#***
def emit_word(x):
    s = int_to_bytes(x)
    for x in s:
        code.append(x)
 
def emit_word_at(at, n):
    code[at:at+word_size] = int_to_bytes(n)
 
def hole():
    t = len(code)
    emit_word(0)
    return t
 
#***
def fetch_var_offset(name):
    global globals_n
 
    n = globals.get(name, None)
    if n == None:
        globals[name] = globals_n
        n = globals_n
        globals_n += 1
    return n
 
#***
def fetch_string_offset(the_string):
    global string_n
 
    n = string_pool.get(the_string, None)
    if n == None:
        string_pool[the_string] = string_n
        n = string_n
        string_n += 1
    return n
 
#***
def code_gen(x):
    if x == None: return
    elif x.node_type == nd_Ident:
        emit_byte(FETCH)
        n = fetch_var_offset(x.value)
        emit_word(n)
    elif x.node_type == nd_Integer:
        emit_byte(PUSH)
        emit_word(x.value)
    elif x.node_type == nd_String:
        emit_byte(PUSH)
        n = fetch_string_offset(x.value)
        emit_word(n)
    elif x.node_type == nd_Assign:
        n = fetch_var_offset(x.left.value)
        code_gen(x.right)
        emit_byte(STORE)
        emit_word(n)
    elif x.node_type == nd_If:
        code_gen(x.left)              # expr
        emit_byte(JZ)                 # if false, jump
        p1 = hole()                   # make room for jump dest
        code_gen(x.right.left)        # if true statements
        if (x.right.right != None):
            emit_byte(JMP)            # jump over else statements
            p2 = hole()
        emit_word_at(p1, len(code) - p1)
        if (x.right.right != None):
            code_gen(x.right.right)   # else statements
            emit_word_at(p2, len(code) - p2)
    elif x.node_type == nd_While:
        p1 = len(code)
        code_gen(x.left)
        emit_byte(JZ)
        p2 = hole()
        code_gen(x.right)
        emit_byte(JMP)                       # jump back to the top
        emit_word(p1 - len(code))
        emit_word_at(p2, len(code) - p2)
    elif x.node_type == nd_Sequence:
        code_gen(x.left)
        code_gen(x.right)
    elif x.node_type == nd_Prtc:
        code_gen(x.left)
        emit_byte(PRTC)
    elif x.node_type == nd_Prti:
        code_gen(x.left)
        emit_byte(PRTI)
    elif x.node_type == nd_Prts:
        code_gen(x.left)
        emit_byte(PRTS)
    elif x.node_type in operators:
        code_gen(x.left)
        code_gen(x.right)
        emit_byte(operators[x.node_type])
    elif x.node_type in unary_operators:
        code_gen(x.left)
        emit_byte(unary_operators[x.node_type])
    else:
        error(""error in code generator - found %d, expecting operator"" % (x.node_type))
 
#***
def code_finish():
    emit_byte(HALT)
 
#***
def list_code():
    print(""Datasize: %d Strings: %d"" % (len(globals), len(string_pool)))
 
    for k in sorted(string_pool, key=string_pool.get):
        print(k)
 
    pc = 0
    while pc < len(code):
        print(""%4d "" % (pc), end='')
        op = code[pc]
        pc += 1
        if op == FETCH:
            x = bytes_to_int(code[pc:pc+word_size])[0]
            print(""fetch [%d]"" % (x));
            pc += word_size
        elif op == STORE:
            x = bytes_to_int(code[pc:pc+word_size])[0]
            print(""store [%d]"" % (x));
            pc += word_size
        elif op == PUSH:
            x = bytes_to_int(code[pc:pc+word_size])[0]
            print(""push  %d"" % (x));
            pc += word_size
        elif op == ADD:   print(""add"")
        elif op == SUB:   print(""sub"")
        elif op == MUL:   print(""mul"")
        elif op == DIV:   print(""div"")
        elif op == MOD:   print(""mod"")
        elif op == LT:    print(""lt"")
        elif op == GT:    print(""gt"")
        elif op == LE:    print(""le"")
        elif op == GE:    print(""ge"")
        elif op == EQ:    print(""eq"")
        elif op == NE:    print(""ne"")
        elif op == AND:   print(""and"")
        elif op == OR:    print(""or"")
        elif op == NEG:   print(""neg"")
        elif op == NOT:   print(""not"")
        elif op == JMP:
            x = bytes_to_int(code[pc:pc+word_size])[0]
            print(""jmp    (%d) %d"" % (x, pc + x));
            pc += word_size
        elif op == JZ:
            x = bytes_to_int(code[pc:pc+word_size])[0]
            print(""jz     (%d) %d"" % (x, pc + x));
            pc += word_size
        elif op == PRTC:  print(""prtc"")
        elif op == PRTI:  print(""prti"")
        elif op == PRTS:  print(""prts"")
        elif op == HALT:  print(""halt"")
        else: error(""list_code: Unknown opcode %d"", (op));
 
def load_ast():
    line = input_file.readline()
    line_list = shlex.split(line, False, False)
 
    text = line_list[0]
    if text == "";"":
        return None
    node_type = all_syms[text]
 
    if len(line_list) > 1:
        value = line_list[1]
        if value.isdigit():
            value = int(value)
        return make_leaf(node_type, value)
 
    left = load_ast()
    right = load_ast()
    return make_node(node_type, left, right)
 
#*** main driver
input_file = sys.stdin
if len(sys.argv) > 1:
    try:
        input_file = open(sys.argv[1], ""r"", 4096)
    except IOError as e:
        error(""Can't open %s"" % sys.argv[1])
 
n = load_ast()
code_gen(n)
code_finish()
list_code()"
tm4f,python,Compiler/lexical analyzer,Programming Concepts,Advanced Concepts,"from __future__ import print_function
import sys
 
# following two must remain in the same order
 
tk_EOI, tk_Mul, tk_Div, tk_Mod, tk_Add, tk_Sub, tk_Negate, tk_Not, tk_Lss, tk_Leq, tk_Gtr, \
tk_Geq, tk_Eq, tk_Neq, tk_Assign, tk_And, tk_Or, tk_If, tk_Else, tk_While, tk_Print,       \
tk_Putc, tk_Lparen, tk_Rparen, tk_Lbrace, tk_Rbrace, tk_Semi, tk_Comma, tk_Ident,          \
tk_Integer, tk_String = range(31)
 
all_syms = [""End_of_input"", ""Op_multiply"", ""Op_divide"", ""Op_mod"", ""Op_add"", ""Op_subtract"",
    ""Op_negate"", ""Op_not"", ""Op_less"", ""Op_lessequal"", ""Op_greater"", ""Op_greaterequal"",
    ""Op_equal"", ""Op_notequal"", ""Op_assign"", ""Op_and"", ""Op_or"", ""Keyword_if"",
    ""Keyword_else"", ""Keyword_while"", ""Keyword_print"", ""Keyword_putc"", ""LeftParen"",
    ""RightParen"", ""LeftBrace"", ""RightBrace"", ""Semicolon"", ""Comma"", ""Identifier"",
    ""Integer"", ""String""]
 
# single character only symbols
symbols = { '{': tk_Lbrace, '}': tk_Rbrace, '(': tk_Lparen, ')': tk_Rparen, '+': tk_Add, '-': tk_Sub,
    '*': tk_Mul, '%': tk_Mod, ';': tk_Semi, ',': tk_Comma }
 
key_words = {'if': tk_If, 'else': tk_Else, 'print': tk_Print, 'putc': tk_Putc, 'while': tk_While}
 
the_ch = "" ""    # dummy first char - but it must be a space
the_col = 0
the_line = 1
input_file = None
 
#*** show error and exit
def error(line, col, msg):
    print(line, col, msg)
    exit(1)
 
#*** get the next character from the input
def next_ch():
    global the_ch, the_col, the_line
 
    the_ch = input_file.read(1)
    the_col += 1
    if the_ch == '\n':
        the_line += 1
        the_col = 0
    return the_ch
 
#*** 'x' - character constants
def char_lit(err_line, err_col):
    n = ord(next_ch())              # skip opening quote
    if the_ch == '\'':
        error(err_line, err_col, ""empty character constant"")
    elif the_ch == '\\':
        next_ch()
        if the_ch == 'n':
            n = 10
        elif the_ch == '\\':
            n = ord('\\')
        else:
            error(err_line, err_col, ""unknown escape sequence \\%c"" % (the_ch))
    if next_ch() != '\'':
        error(err_line, err_col, ""multi-character constant"")
    next_ch()
    return tk_Integer, err_line, err_col, n
 
#*** process divide or comments
def div_or_cmt(err_line, err_col):
    if next_ch() != '*':
        return tk_Div, err_line, err_col
 
    # comment found
    next_ch()
    while True:
        if the_ch == '*':
            if next_ch() == '/':
                next_ch()
                return gettok()
        elif len(the_ch) == 0:
            error(err_line, err_col, ""EOF in comment"")
        else:
            next_ch()
 
#*** ""string""
def string_lit(start, err_line, err_col):
    global the_ch
    text = """"
 
    while next_ch() != start:
        if len(the_ch) == 0:
            error(err_line, err_col, ""EOF while scanning string literal"")
        if the_ch == '\n':
            error(err_line, err_col, ""EOL while scanning string literal"")
        if the_ch == '\\':
            next_ch()
            if the_ch != 'n':
                error(err_line, err_col, ""escape sequence unknown \\%c"" % the_ch)
            the_ch = '\n'
        text += the_ch
 
    next_ch()
    return tk_String, err_line, err_col, text
 
#*** handle identifiers and integers
def ident_or_int(err_line, err_col):
    is_number = True
    text = """"
 
    while the_ch.isalnum() or the_ch == '_':
        text += the_ch
        if not the_ch.isdigit():
            is_number = False
        next_ch()
 
    if len(text) == 0:
        error(err_line, err_col, ""ident_or_int: unrecognized character: (%d) '%c'"" % (ord(the_ch), the_ch))
 
    if text[0].isdigit():
        if not is_number:
            error(err_line, err_col, ""invalid number: %s"" % (text))
        n = int(text)
        return tk_Integer, err_line, err_col, n
 
    if text in key_words:
        return key_words[text], err_line, err_col
 
    return tk_Ident, err_line, err_col, text
 
#*** look ahead for '>=', etc.
def follow(expect, ifyes, ifno, err_line, err_col):
    if next_ch() == expect:
        next_ch()
        return ifyes, err_line, err_col
 
    if ifno == tk_EOI:
        error(err_line, err_col, ""follow: unrecognized character: (%d) '%c'"" % (ord(the_ch), the_ch))
 
    return ifno, err_line, err_col
 
#*** return the next token type
def gettok():
    while the_ch.isspace():
        next_ch()
 
    err_line = the_line
    err_col  = the_col
 
    if len(the_ch) == 0:    return tk_EOI, err_line, err_col
    elif the_ch == '/':     return div_or_cmt(err_line, err_col)
    elif the_ch == '\'':    return char_lit(err_line, err_col)
    elif the_ch == '<':     return follow('=', tk_Leq, tk_Lss,    err_line, err_col)
    elif the_ch == '>':     return follow('=', tk_Geq, tk_Gtr,    err_line, err_col)
    elif the_ch == '=':     return follow('=', tk_Eq,  tk_Assign, err_line, err_col)
    elif the_ch == '!':     return follow('=', tk_Neq, tk_Not,    err_line, err_col)
    elif the_ch == '&':     return follow('&', tk_And, tk_EOI,    err_line, err_col)
    elif the_ch == '|':     return follow('|', tk_Or,  tk_EOI,    err_line, err_col)
    elif the_ch == '""':     return string_lit(the_ch, err_line, err_col)
    elif the_ch in symbols:
        sym = symbols[the_ch]
        next_ch()
        return sym, err_line, err_col
    else: return ident_or_int(err_line, err_col)
 
#*** main driver
input_file = sys.stdin
if len(sys.argv) > 1:
    try:
        input_file = open(sys.argv[1], ""r"", 4096)
    except IOError as e:
        error(0, 0, ""Can't open %s"" % sys.argv[1])
 
while True:
    t = gettok()
    tok  = t[0]
    line = t[1]
    col  = t[2]
 
    print(""%5d  %5d   %-14s"" % (line, col, all_syms[tok]), end='')
 
    if tok == tk_Integer:  print(""   %5d"" % (t[3]))
    elif tok == tk_Ident:  print(""  %s"" %   (t[3]))
    elif tok == tk_String: print('  ""%s""' % (t[3]))
    else:                  print("""")
 
    if tok == tk_EOI:
        break"
nk7s,python,Compiler/syntax analyzer,Programming Concepts,Advanced Concepts,"from __future__ import print_function
import sys, shlex, operator
 
tk_EOI, tk_Mul, tk_Div, tk_Mod, tk_Add, tk_Sub, tk_Negate, tk_Not, tk_Lss, tk_Leq, tk_Gtr, \
tk_Geq, tk_Eql, tk_Neq, tk_Assign, tk_And, tk_Or, tk_If, tk_Else, tk_While, tk_Print,      \
tk_Putc, tk_Lparen, tk_Rparen, tk_Lbrace, tk_Rbrace, tk_Semi, tk_Comma, tk_Ident,          \
tk_Integer, tk_String = range(31)
 
nd_Ident, nd_String, nd_Integer, nd_Sequence, nd_If, nd_Prtc, nd_Prts, nd_Prti, nd_While, \
nd_Assign, nd_Negate, nd_Not, nd_Mul, nd_Div, nd_Mod, nd_Add, nd_Sub, nd_Lss, nd_Leq,     \
nd_Gtr, nd_Geq, nd_Eql, nd_Neq, nd_And, nd_Or = range(25)
 
# must have same order as above
Tokens = [
    [""EOI""             , False, False, False, -1, -1        ],
    [""*""               , False, True,  False, 13, nd_Mul    ],
    [""/""               , False, True,  False, 13, nd_Div    ],
    [""%""               , False, True,  False, 13, nd_Mod    ],
    [""+""               , False, True,  False, 12, nd_Add    ],
    [""-""               , False, True,  False, 12, nd_Sub    ],
    [""-""               , False, False, True,  14, nd_Negate ],
    [""!""               , False, False, True,  14, nd_Not    ],
    [""<""               , False, True,  False, 10, nd_Lss    ],
    [""<=""              , False, True,  False, 10, nd_Leq    ],
    ["">""               , False, True,  False, 10, nd_Gtr    ],
    ["">=""              , False, True,  False, 10, nd_Geq    ],
    [""==""              , False, True,  False,  9, nd_Eql    ],
    [""!=""              , False, True,  False,  9, nd_Neq    ],
    [""=""               , False, False, False, -1, nd_Assign ],
    [""&&""              , False, True,  False,  5, nd_And    ],
    [""||""              , False, True,  False,  4, nd_Or     ],
    [""if""              , False, False, False, -1, nd_If     ],
    [""else""            , False, False, False, -1, -1        ],
    [""while""           , False, False, False, -1, nd_While  ],
    [""print""           , False, False, False, -1, -1        ],
    [""putc""            , False, False, False, -1, -1        ],
    [""(""               , False, False, False, -1, -1        ],
    ["")""               , False, False, False, -1, -1        ],
    [""{""               , False, False, False, -1, -1        ],
    [""}""               , False, False, False, -1, -1        ],
    ["";""               , False, False, False, -1, -1        ],
    ["",""               , False, False, False, -1, -1        ],
    [""Ident""           , False, False, False, -1, nd_Ident  ],
    [""Integer literal"" , False, False, False, -1, nd_Integer],
    [""String literal""  , False, False, False, -1, nd_String ]
    ]
 
all_syms = {""End_of_input""   : tk_EOI,     ""Op_multiply""    : tk_Mul,
            ""Op_divide""      : tk_Div,     ""Op_mod""         : tk_Mod,
            ""Op_add""         : tk_Add,     ""Op_subtract""    : tk_Sub,
            ""Op_negate""      : tk_Negate,  ""Op_not""         : tk_Not,
            ""Op_less""        : tk_Lss,     ""Op_lessequal""   : tk_Leq,
            ""Op_greater""     : tk_Gtr,     ""Op_greaterequal"": tk_Geq,
            ""Op_equal""       : tk_Eql,     ""Op_notequal""    : tk_Neq,
            ""Op_assign""      : tk_Assign,  ""Op_and""         : tk_And,
            ""Op_or""          : tk_Or,      ""Keyword_if""     : tk_If,
            ""Keyword_else""   : tk_Else,    ""Keyword_while""  : tk_While,
            ""Keyword_print""  : tk_Print,   ""Keyword_putc""   : tk_Putc,
            ""LeftParen""      : tk_Lparen,  ""RightParen""     : tk_Rparen,
            ""LeftBrace""      : tk_Lbrace,  ""RightBrace""     : tk_Rbrace,
            ""Semicolon""      : tk_Semi,    ""Comma""          : tk_Comma,
            ""Identifier""     : tk_Ident,   ""Integer""        : tk_Integer,
            ""String""         : tk_String}
 
Display_nodes = [""Identifier"", ""String"", ""Integer"", ""Sequence"", ""If"", ""Prtc"", ""Prts"",
    ""Prti"", ""While"", ""Assign"", ""Negate"", ""Not"", ""Multiply"", ""Divide"", ""Mod"", ""Add"",
    ""Subtract"", ""Less"", ""LessEqual"", ""Greater"", ""GreaterEqual"", ""Equal"", ""NotEqual"",
    ""And"", ""Or""]
 
TK_NAME         = 0
TK_RIGHT_ASSOC  = 1
TK_IS_BINARY    = 2
TK_IS_UNARY     = 3
TK_PRECEDENCE   = 4
TK_NODE         = 5
 
input_file = None
err_line   = None
err_col    = None
tok        = None
tok_text   = None
 
#*** show error and exit
def error(msg):
    print(""(%d, %d) %s"" % (int(err_line), int(err_col), msg))
    exit(1)
 
#***
def gettok():
    global err_line, err_col, tok, tok_text, tok_other
    line = input_file.readline()
    if len(line) == 0:
        error(""empty line"")
 
    line_list = shlex.split(line, False, False)
    # line col Ident var_name
    # 0    1   2     3
 
    err_line = line_list[0]
    err_col  = line_list[1]
    tok_text = line_list[2]
 
    tok = all_syms.get(tok_text)
    if tok == None:
        error(""Unknown token %s"" % (tok_text))
 
    tok_other = None
    if tok in [tk_Integer, tk_Ident, tk_String]:
        tok_other = line_list[3]
 
class Node:
    def __init__(self, node_type, left = None, right = None, value = None):
        self.node_type  = node_type
        self.left  = left
        self.right = right
        self.value = value
 
#***
def make_node(oper, left, right = None):
    return Node(oper, left, right)
 
#***
def make_leaf(oper, n):
    return Node(oper, value = n)
 
#***
def expect(msg, s):
    if tok == s:
        gettok()
        return
    error(""%s: Expecting '%s', found '%s'"" % (msg, Tokens[s][TK_NAME], Tokens[tok][TK_NAME]))
 
#***
def expr(p):
    x = None
 
    if tok == tk_Lparen:
        x = paren_expr()
    elif tok in [tk_Sub, tk_Add]:
        op = (tk_Negate if tok == tk_Sub else tk_Add)
        gettok()
        node = expr(Tokens[tk_Negate][TK_PRECEDENCE])
        x = (make_node(nd_Negate, node) if op == tk_Negate else node)
    elif tok == tk_Not:
        gettok()
        x = make_node(nd_Not, expr(Tokens[tk_Not][TK_PRECEDENCE]))
    elif tok == tk_Ident:
        x = make_leaf(nd_Ident, tok_other)
        gettok()
    elif tok == tk_Integer:
        x = make_leaf(nd_Integer, tok_other)
        gettok()
    else:
        error(""Expecting a primary, found: %s"" % (Tokens[tok][TK_NAME]))
 
    while Tokens[tok][TK_IS_BINARY] and Tokens[tok][TK_PRECEDENCE] >= p:
        op = tok
        gettok()
        q = Tokens[op][TK_PRECEDENCE]
        if not Tokens[op][TK_RIGHT_ASSOC]:
            q += 1
 
        node = expr(q)
        x = make_node(Tokens[op][TK_NODE], x, node)
 
    return x
 
#***
def paren_expr():
    expect(""paren_expr"", tk_Lparen)
    node = expr(0)
    expect(""paren_expr"", tk_Rparen)
    return node
 
#***
def stmt():
    t = None
 
    if tok == tk_If:
        gettok()
        e = paren_expr()
        s = stmt()
        s2 = None
        if tok == tk_Else:
            gettok()
            s2 = stmt()
        t = make_node(nd_If, e, make_node(nd_If, s, s2))
    elif tok == tk_Putc:
        gettok()
        e = paren_expr()
        t = make_node(nd_Prtc, e)
        expect(""Putc"", tk_Semi)
    elif tok == tk_Print:
        gettok()
        expect(""Print"", tk_Lparen)
        while True:
            if tok == tk_String:
                e = make_node(nd_Prts, make_leaf(nd_String, tok_other))
                gettok()
            else:
                e = make_node(nd_Prti, expr(0))
 
            t = make_node(nd_Sequence, t, e)
            if tok != tk_Comma:
                break
            gettok()
        expect(""Print"", tk_Rparen)
        expect(""Print"", tk_Semi)
    elif tok == tk_Semi:
        gettok()
    elif tok == tk_Ident:
        v = make_leaf(nd_Ident, tok_other)
        gettok()
        expect(""assign"", tk_Assign)
        e = expr(0)
        t = make_node(nd_Assign, v, e)
        expect(""assign"", tk_Semi)
    elif tok == tk_While:
        gettok()
        e = paren_expr()
        s = stmt()
        t = make_node(nd_While, e, s)
    elif tok == tk_Lbrace:
        gettok()
        while tok != tk_Rbrace and tok != tk_EOI:
            t = make_node(nd_Sequence, t, stmt())
        expect(""Lbrace"", tk_Rbrace)
    elif tok == tk_EOI:
        pass
    else:
        error(""Expecting start of statement, found: %s"" % (Tokens[tok][TK_NAME]))
 
    return t
 
#***
def parse():
    t = None
    gettok()
    while True:
        t = make_node(nd_Sequence, t, stmt())
        if tok == tk_EOI or t == None:
            break
    return t
 
def prt_ast(t):
    if t == None:
        print("";"")
    else:
        print(""%-14s"" % (Display_nodes[t.node_type]), end='')
        if t.node_type in [nd_Ident, nd_Integer]:
            print(""%s"" % (t.value))
        elif t.node_type == nd_String:
            print(""%s"" %(t.value))
        else:
            print("""")
            prt_ast(t.left)
            prt_ast(t.right)
 
#*** main driver
input_file = sys.stdin
if len(sys.argv) > 1:
    try:
        input_file = open(sys.argv[1], ""r"", 4096)
    except IOError as e:
        error(0, 0, ""Can't open %s"" % sys.argv[1])
t = parse()
prt_ast(t)"
7zdh,python,Compiler/virtual machine interpreter,Systems Programming and File I/O,System Programming,"from __future__ import print_function
import sys, struct
 
FETCH, STORE, PUSH, ADD, SUB, MUL, DIV, MOD, LT, GT, LE, GE, EQ, NE, AND, OR, NEG, NOT, \
JMP, JZ, PRTC, PRTS, PRTI, HALT = range(24)
 
code_map = {
    ""fetch"": FETCH,
    ""store"": STORE,
    ""push"":  PUSH,
    ""add"":   ADD,
    ""sub"":   SUB,
    ""mul"":   MUL,
    ""div"":   DIV,
    ""mod"":   MOD,
    ""lt"":    LT,
    ""gt"":    GT,
    ""le"":    LE,
    ""ge"":    GE,
    ""eq"":    EQ,
    ""ne"":    NE,
    ""and"":   AND,
    ""or"":    OR,
    ""not"":   NOT,
    ""neg"":   NEG,
    ""jmp"":   JMP,
    ""jz"":    JZ,
    ""prtc"":  PRTC,
    ""prts"":  PRTS,
    ""prti"":  PRTI,
    ""halt"":  HALT
}
 
input_file  = None
code        = bytearray()
string_pool = []
word_size   = 4
 
#*** show error and exit
def error(msg):
    print(""%s"" % (msg))
    exit(1)
 
def int_to_bytes(val):
    return struct.pack(""<i"", val)
 
def bytes_to_int(bstr):
    return struct.unpack(""<i"", bstr)
 
#***
def emit_byte(x):
    code.append(x)
 
#***
def emit_word(x):
    s = int_to_bytes(x)
    for x in s:
        code.append(x)
 
#***
def run_vm(data_size):
    stack = [0 for i in range(data_size + 1)]
    pc = 0
    while True:
        op = code[pc]
        pc += 1
 
        if op == FETCH:
            stack.append(stack[bytes_to_int(code[pc:pc+word_size])[0]]);
            pc += word_size
        elif op == STORE:
            stack[bytes_to_int(code[pc:pc+word_size])[0]] = stack.pop();
            pc += word_size
        elif op == PUSH:
            stack.append(bytes_to_int(code[pc:pc+word_size])[0]);
            pc += word_size
        elif op == ADD:   stack[-2] += stack[-1]; stack.pop()
        elif op == SUB:   stack[-2] -= stack[-1]; stack.pop()
        elif op == MUL:   stack[-2] *= stack[-1]; stack.pop()
        # use C like division semantics
        elif op == DIV:   stack[-2] = int(float(stack[-2]) / stack[-1]); stack.pop()
        elif op == MOD:   stack[-2] = int(float(stack[-2]) % stack[-1]); stack.pop()
        elif op == LT:    stack[-2] = stack[-2] <  stack[-1]; stack.pop()
        elif op == GT:    stack[-2] = stack[-2] >  stack[-1]; stack.pop()
        elif op == LE:    stack[-2] = stack[-2] <= stack[-1]; stack.pop()
        elif op == GE:    stack[-2] = stack[-2] >= stack[-1]; stack.pop()
        elif op == EQ:    stack[-2] = stack[-2] == stack[-1]; stack.pop()
        elif op == NE:    stack[-2] = stack[-2] != stack[-1]; stack.pop()
        elif op == AND:   stack[-2] = stack[-2] and stack[-1]; stack.pop()
        elif op == OR:    stack[-2] = stack[-2] or  stack[-1]; stack.pop()
        elif op == NEG:   stack[-1] = -stack[-1]
        elif op == NOT:   stack[-1] = not stack[-1]
        elif op == JMP:   pc += bytes_to_int(code[pc:pc+word_size])[0]
        elif op == JZ:
            if stack.pop():
                pc += word_size
            else:
                pc += bytes_to_int(code[pc:pc+word_size])[0]
        elif op == PRTC:  print(""%c"" % (stack[-1]), end=''); stack.pop()
        elif op == PRTS:  print(""%s"" % (string_pool[stack[-1]]), end=''); stack.pop()
        elif op == PRTI:  print(""%d"" % (stack[-1]), end=''); stack.pop()
        elif op == HALT:  break
 
def str_trans(srce):
    dest = """"
    i = 0
    while i < len(srce):
        if srce[i] == '\\' and i + 1 < len(srce):
            if srce[i + 1] == 'n':
                dest += '\n'
                i += 2
            elif srce[i + 1] == '\\':
                dest += '\\'
                i += 2
        else:
            dest += srce[i]
            i += 1
 
    return dest
 
#***
def load_code():
    global string_pool
 
    line = input_file.readline()
    if len(line) == 0:
        error(""empty line"")
 
    line_list = line.split()
    data_size = int(line_list[1])
    n_strings = int(line_list[3])
 
    for i in range(n_strings):
        string_pool.append(str_trans(input_file.readline().strip('""\n')))
 
    while True:
        line = input_file.readline()
        if len(line) == 0:
            break
        line_list = line.split()
        offset = int(line_list[0])
        instr  = line_list[1]
        opcode = code_map.get(instr)
        if opcode == None:
            error(""Unknown instruction %s at %d"" % (instr, offset))
        emit_byte(opcode)
        if opcode in [JMP, JZ]:
            p = int(line_list[3])
            emit_word(p - (offset + 1))
        elif opcode == PUSH:
            value = int(line_list[2])
            emit_word(value)
        elif opcode in [FETCH, STORE]:
            value = int(line_list[2].strip('[]'))
            emit_word(value)
 
    return data_size
 
#*** main driver
input_file = sys.stdin
if len(sys.argv) > 1:
    try:
        input_file = open(sys.argv[1], ""r"", 4096)
    except IOError as e:
        error(0, 0, ""Can't open %s"" % sys.argv[1])
 
data_size = load_code()
run_vm(data_size)"
zn2a,python,Compound data type,Algorithms and Data Structures,Data Structures,"X, Y = 0, 1
p = (3, 4)
p = [3, 4]
 
print p[X]"
eghj,python,Concurrent computing,Concurrency and Parallelism,Multithreading and Thread Management,"import asyncio
 
 
async def print_(string: str) -> None:
    print(string)
 
 
async def main():
    strings = ['Enjoy', 'Rosetta', 'Code']
    coroutines = map(print_, strings)
    await asyncio.gather(*coroutines)
 
 
if __name__ == '__main__':
    asyncio.run(main())"
lgfd,python,Conditional structures,Programming Concepts,Fundamentals,"if x == 0:
    foo()
elif x == 1:
    bar()
elif x == 2:
    baz()
else:
    boz()"
z62p,python,Conjugate transpose,Mathematics,Linear Algebra,"def conjugate_transpose(m):
    return tuple(tuple(n.conjugate() for n in row) for row in zip(*m))
 
def mmul( ma, mb):
    return tuple(tuple(sum( ea*eb for ea,eb in zip(a,b)) for b in zip(*mb)) for a in ma)
 
def mi(size):
    'Complex Identity matrix'
    sz = range(size)
    m = [[0 + 0j for i in sz] for j in sz]
    for i in range(size):
        m[i][i] = 1 + 0j
    return tuple(tuple(row) for row in m)
 
def __allsame(vector):
    first, rest = vector[0], vector[1:]
    return all(i == first for i in rest)
 
def __allnearsame(vector, eps=1e-14):
    first, rest = vector[0], vector[1:]
    return all(abs(first.real - i.real) < eps and abs(first.imag - i.imag) < eps
               for i in rest)
 
def isequal(matrices, eps=1e-14):
    'Check any number of matrices for equality within eps'
    x = [len(m) for m in matrices]
    if not __allsame(x): return False
    y = [len(m[0]) for m in matrices]
    if not __allsame(y): return False
    for s in range(x[0]):
        for t in range(y[0]):
            if not __allnearsame([m[s][t] for m in matrices], eps): return False
    return True
 
 
def ishermitian(m, ct):
    return isequal([m, ct])
 
def isnormal(m, ct):
    return isequal([mmul(m, ct), mmul(ct, m)])
 
def isunitary(m, ct):
    mct, ctm = mmul(m, ct), mmul(ct, m)
    mctx, mcty, cmx, ctmy = len(mct), len(mct[0]), len(ctm), len(ctm[0])
    ident = mi(mctx)
    return isequal([mct, ctm, ident])
 
def printm(comment, m):
    print(comment)
    fields = [['%g%+gj' % (f.real, f.imag) for f in row] for row in m]
    width = max(max(len(f) for f in row) for row in fields)
    lines = (', '.join('%*s' % (width, f) for f in row) for row in fields)
    print('\n'.join(lines))
 
if __name__ == '__main__':
    for matrix in [
            ((( 3.000+0.000j), (+2.000+1.000j)), 
            (( 2.000-1.000j), (+1.000+0.000j))),
 
            ((( 1.000+0.000j), (+1.000+0.000j), (+0.000+0.000j)), 
            (( 0.000+0.000j), (+1.000+0.000j), (+1.000+0.000j)), 
            (( 1.000+0.000j), (+0.000+0.000j), (+1.000+0.000j))),
 
            ((( 2**0.5/2+0.000j), (+2**0.5/2+0.000j), (+0.000+0.000j)), 
            (( 0.000+2**0.5/2j), (+0.000-2**0.5/2j), (+0.000+0.000j)), 
            (( 0.000+0.000j), (+0.000+0.000j), (+0.000+1.000j)))]:
        printm('\nMatrix:', matrix)
        ct = conjugate_transpose(matrix)
        printm('Its conjugate transpose:', ct)
        print('Hermitian? %s.' % ishermitian(matrix, ct))
        print('Normal?    %s.' % isnormal(matrix, ct))
        print('Unitary?   %s.' % isunitary(matrix, ct))"
p5xj,python,Consecutive primes with ascending or descending differences,Mathematics,Number Theory," 
from sympy import sieve
 
primelist = list(sieve.primerange(2,1000000))
 
listlen = len(primelist)
 
# ascending
 
pindex = 1
old_diff = -1
curr_list=[primelist[0]]
longest_list=[]
 
while pindex < listlen:
 
    diff = primelist[pindex] - primelist[pindex-1]
    if diff > old_diff:
        curr_list.append(primelist[pindex])
        if len(curr_list) > len(longest_list):
            longest_list = curr_list
    else:
        curr_list = [primelist[pindex-1],primelist[pindex]]
 
    old_diff = diff
    pindex += 1
 
print(longest_list)
 
# descending
 
pindex = 1
old_diff = -1
curr_list=[primelist[0]]
longest_list=[]
 
while pindex < listlen:
 
    diff = primelist[pindex] - primelist[pindex-1]
    if diff < old_diff:
        curr_list.append(primelist[pindex])
        if len(curr_list) > len(longest_list):
            longest_list = curr_list
    else:
        curr_list = [primelist[pindex-1],primelist[pindex]]
 
    old_diff = diff
    pindex += 1
 
print(longest_list)
 "
0zj6,python,Constrained random points on a circle,Mathematics,Probability and Statistics,">>> from collections import defaultdict
>>> from random import choice
>>> world = defaultdict(int)
>>> possiblepoints = [(x,y) for x in range(-15,16)
		  for y in range(-15,16)
		  if 10 <= abs(x+y*1j) <= 15]
>>> for i in range(100): world[choice(possiblepoints)] += 1
 
>>> for x in range(-15,16):
	print(''.join(str(min([9, world[(x,y)]])) if world[(x,y)] else ' '
			  for y in range(-15,16)))
 
 
 
             1     1           
          1 1                  
      11 1     1  1     1      
     111  1     1211           
      1   2    1 1    11       
      1  11         21         
     1   1            11  1    
   1  2                1 1     
 
 1  2                          
   1 1                      1  
   1 1                         
   2                      11   
  1                         1  
                         1     
 
 
  1                          1 
                         1     
                         2     
                            1  
     1                  1 1    
      1                2   1   
   1   3            11  2      
    11   1    1      1   2     
            1   1    2         
        1  1                   
         1      1     1        
          2 2   1              
               1               "
i1eg,python,Continued fraction,Mathematics,Mathematical Sequences and Series,"from fractions import Fraction
import itertools
try: zip = itertools.izip
except: pass
 
# The Continued Fraction
def CF(a, b, t):
  terms = list(itertools.islice(zip(a, b), t))
  z = Fraction(1,1)
  for a, b in reversed(terms):
    z = a + b / z
  return z
 
# Approximates a fraction to a string
def pRes(x, d):
  q, x = divmod(x, 1)
  res = str(q)
  res += "".""
  for i in range(d):
    x *= 10
    q, x = divmod(x, 1)
    res += str(q)
  return res
 
# Test the Continued Fraction for sqrt2
def sqrt2_a():
  yield 1
  for x in itertools.repeat(2):
    yield x
 
def sqrt2_b():
  for x in itertools.repeat(1):
    yield x
 
cf = CF(sqrt2_a(), sqrt2_b(), 950)
print(pRes(cf, 200))
#1.41421356237309504880168872420969807856967187537694807317667973799073247846210703885038753432764157273501384623091229702492483605585073721264412149709993583141322266592750559275579995050115278206057147
 
 
# Test the Continued Fraction for Napier's Constant
def Napier_a():
  yield 2
  for x in itertools.count(1):
    yield x
 
def Napier_b():
  yield 1
  for x in itertools.count(1):
    yield x
 
cf = CF(Napier_a(), Napier_b(), 950)
print(pRes(cf, 200))
#2.71828182845904523536028747135266249775724709369995957496696762772407663035354759457138217852516642742746639193200305992181741359662904357290033429526059563073813232862794349076323382988075319525101901
 
# Test the Continued Fraction for Pi
def Pi_a():
  yield 3
  for x in itertools.repeat(6):
    yield x
 
def Pi_b():
  for x in itertools.count(1,2):
    yield x*x
 
cf = CF(Pi_a(), Pi_b(), 950)
print(pRes(cf, 10))
#3.1415926532"
fgpi,python,Continued fraction/Arithmetic/Construct from rational number,Mathematics,Number Theory,"def r2cf(n1,n2):
  while n2:
    n1, (t1, n2) = n2, divmod(n1, n2)
    yield t1
 
print(list(r2cf(1,2)))    # => [0, 2]
print(list(r2cf(3,1)))    # => [3]
print(list(r2cf(23,8)))    # => [2, 1, 7]
print(list(r2cf(13,11)))    # => [1, 5, 2]
print(list(r2cf(22,7)))    # => [3, 7]
print(list(r2cf(14142,10000)))    # => [1, 2, 2, 2, 2, 2, 1, 1, 29]
print(list(r2cf(141421,100000)))    # => [1, 2, 2, 2, 2, 2, 2, 3, 1, 1, 3, 1, 7, 2]
print(list(r2cf(1414214,1000000)))    # => [1, 2, 2, 2, 2, 2, 2, 2, 3, 6, 1, 2, 1, 12]
print(list(r2cf(14142136,10000000)))    # => [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 1, 2, 4, 1, 1, 2]"
s5uf,python,Convert decimal number to rational,Mathematics,Number Theory,">>> from fractions import Fraction
>>> for d in (0.9054054, 0.518518, 0.75): print(d, Fraction.from_float(d).limit_denominator(100))
 
0.9054054 67/74
0.518518 14/27
0.75 3/4
>>> for d in '0.9054054 0.518518 0.75'.split(): print(d, Fraction(d))
 
0.9054054 4527027/5000000
0.518518 259259/500000
0.75 3/4
>>> "
mde1,python,Convert seconds to compound duration,Mathematics,Algebra and Arithmetic,">>> def duration(seconds):
	t= []
	for dm in (60, 60, 24, 7):
		seconds, m = divmod(seconds, dm)
		t.append(m)
	t.append(seconds)
	return ', '.join('%d %s' % (num, unit)
			 for num, unit in zip(t[::-1], 'wk d hr min sec'.split())
			 if num)
 
>>> for seconds in [7259, 86400, 6000000]:
	print(""%7d sec = %s"" % (seconds, duration(seconds)))
 
 
   7259 sec = 2 hr, 59 sec
  86400 sec = 1 d
6000000 sec = 9 wk, 6 d, 10 hr, 40 min
>>> "
iqxk,python,Convex hull,Mathematics,Geometry and Trigonometry,"from __future__ import print_function
from shapely.geometry import MultiPoint
 
if __name__==""__main__"":
	pts = MultiPoint([(16,3), (12,17), (0,6), (-4,-6), (16,6), (16,-7), (16,-3), (17,-4), (5,19), (19,-8), (3,16), (12,13), (3,-4), (17,5), (-3,15), (-3,-9), (0,11), (-9,-3), (-4,-2), (12,10)])
	print (pts.convex_hull)"
v1tl,python,Conway's Game of Life,Puzzles and Games,Simulation and Modeling,"import random
from collections import defaultdict
 
printdead, printlive = '-#'
maxgenerations = 3
cellcount = 3,3
celltable = defaultdict(int, {
 (1, 2): 1,
 (1, 3): 1,
 (0, 3): 1,
 } ) # Only need to populate with the keys leading to life
 
##
## Start States
##
# blinker
u = universe = defaultdict(int)
u[(1,0)], u[(1,1)], u[(1,2)] = 1,1,1
 
## toad
#u = universe = defaultdict(int)
#u[(5,5)], u[(5,6)], u[(5,7)] = 1,1,1
#u[(6,6)], u[(6,7)], u[(6,8)] = 1,1,1
 
## glider
#u = universe = defaultdict(int)
#maxgenerations = 16
#u[(5,5)], u[(5,6)], u[(5,7)] = 1,1,1
#u[(6,5)] = 1
#u[(7,6)] = 1
 
## random start
#universe = defaultdict(int, 
#                       # array of random start values
#                       ( ((row, col), random.choice((0,1)))
#                         for col in range(cellcount[0])
#                         for row in range(cellcount[1])
#                       ) )  # returns 0 for out of bounds
 
for i in range(maxgenerations):
    print(""\nGeneration %3i:"" % ( i, ))
    for row in range(cellcount[1]):
        print(""  "", ''.join(str(universe[(row,col)])
                            for col in range(cellcount[0])).replace(
                                '0', printdead).replace('1', printlive))
    nextgeneration = defaultdict(int)
    for row in range(cellcount[1]):
        for col in range(cellcount[0]):
            nextgeneration[(row,col)] = celltable[
                ( universe[(row,col)],
                  -universe[(row,col)] + sum(universe[(r,c)]
                                             for r in range(row-1,row+2)
                                             for c in range(col-1, col+2) )
                ) ]
    universe = nextgeneration"
mq4h,python,Copy a string,Text Processing,String Manipulation,">>> src = ""hello""
>>> a = src
>>> b = src[:]
>>> import copy
>>> c = copy.copy(src)
>>> d = copy.deepcopy(src)
>>> src is a is b is c is d
True"
re5j,python,Copy stdin to stdout,Systems Programming and File I/O,File Operations,python -c 'import sys; sys.stdout.write(sys.stdin.read())'
w9y7,python,Count in factors,Mathematics,Number Theory,"from functools import lru_cache
 
primes = [2, 3, 5, 7, 11, 13, 17]    # Will be extended
 
@lru_cache(maxsize=2000)
def pfactor(n):
    if n == 1:
        return [1]
    n2 = n // 2 + 1
    for p in primes:
        if p <= n2:
            d, m = divmod(n, p)
            if m == 0:
                if d > 1:
                    return [p] + pfactor(d)
                else:
                    return [p]
        else:
            if n > primes[-1]:
                primes.append(n)
            return [n]
 
if __name__ == '__main__':
    mx = 5000
    for n in range(1, mx + 1):
        factors = pfactor(n)
        if n <= 10 or n >= mx - 20:
            print( '%4i %5s %s' % (n,
                                   '' if factors != [n] or n == 1 else 'prime',
                                   'x'.join(str(i) for i in factors)) )
        if n == 11:
            print('...')
 
    print('\nNumber of primes gathered up to', n, 'is', len(primes))
    print(pfactor.cache_info())"
efc6,python,Count in octal,Mathematics,Numerical Methods,"import sys
for n in xrange(sys.maxint):
    print oct(n)"
gl93,python,Count occurrences of a substring,Text Processing,String Manipulation,">>> ""the three truths"".count(""th"")
3
>>> ""ababababab"".count(""abab"")
2"
npb1,python,Count the coins,Algorithms and Data Structures,Algorithms,"def changes(amount, coins):
    ways = [0] * (amount + 1)
    ways[0] = 1
    for coin in coins:
        for j in xrange(coin, amount + 1):
            ways[j] += ways[j - coin]
    return ways[amount]
 
print changes(100, [1, 5, 10, 25])
print changes(100000, [1, 5, 10, 25, 50, 100])"
07ls,python,Cramer's rule,Mathematics,Algebra and Arithmetic," 
def det(m,n):
 if n==1: return m[0][0]
 z=0
 for r in range(n):
  k=m[:]
  del k[r]
  z+=m[r][0]*(-1)**r*det([p[1:]for p in k],n-1)
 return z
w=len(t)
d=det(h,w)
if d==0:r=[]
else:r=[det([r[0:i]+[s]+r[i+1:]for r,s in zip(h,t)],w)/d for i in range(w)]
print(r)
 "
g3s6,python,Create a file,Systems Programming and File I/O,File Operations,"import os
for directory in ['/', './']:
  open(directory + 'output.txt', 'w').close()  # create /output.txt, then ./output.txt
  os.mkdir(directory + 'docs')                 # create directory /docs, then ./docs"
mvf7,python,Create a file on magnetic tape,Systems Programming and File I/O,File Operations,">>> with open('/dev/tape', 'w') as t: t.write('Hi Tape!\n')
... 
>>> "
pr5a,python,Create a two-dimensional array at runtime,Algorithms and Data Structures,Data Structures,"width = int(raw_input(""Width of myarray: ""))
height = int(raw_input(""Height of Array: ""))
myarray = [[0] * width for i in range(height)]
myarray[0][0] = 3.5
print (myarray[0][0])"
ch2m,python,Create an HTML table,Networking and Web Development,Web Development," 
import random
 
def rand9999():
    return random.randint(1000, 9999)
 
def tag(attr='', **kwargs):
    for tag, txt in kwargs.items():
        return '<{tag}{attr}>{txt}</{tag}>'.format(**locals())
 
if __name__ == '__main__':
    header = tag(tr=''.join(tag(th=txt) for txt in ',X,Y,Z'.split(','))) + '\n'
    rows = '\n'.join(tag(tr=tag(' style=""font-weight: bold;""', td=i)
                                    + ''.join(tag(td=rand9999())
                                              for j in range(3)))
                     for i in range(1, 6))
    table = tag(table='\n' + header + rows + '\n')
    print(table)"
xdg7,python,Cuban primes,Mathematics,Number Theory," 
import datetime
import math
 
primes = [ 3, 5 ]
 
cutOff = 200
 
bigUn =  100_000
chunks = 50
little = bigUn / chunks
 
tn = "" cuban prime""
print (""The first {:,}{}s:"".format(cutOff, tn))
 
c = 0
showEach = True
u = 0
v = 1
st = datetime.datetime.now()
 
for i in range(1, int(math.pow(2,20))):
	found = False
	u += 6
	v += u
	mx = int(math.sqrt(v))
 
	for item in primes:
		if (item > mx):
			break
		if (v % item == 0):
			found = True
			break
 
	if (found == 0):
		c += 1
		if (showEach):
			z = primes[-1]
			while (z <= v - 2):
				z += 2
 
				fnd = False
				for item in primes:
					if (item > mx):
						break
					if (z % item == 0):
						fnd = True
						break
 
				if (not fnd):
					primes.append(z)
 
			primes.append(v)
			print(""{:>11,}"".format(v), end='')
 
			if (c % 10 == 0):
				print("""");
			if (c == cutOff):
				showEach = False
				print (""Progress to the {:,}th {}:"".format(bigUn, tn), end='')
		if (c % little == 0):
			print('.', end='')
		if (c == bigUn):
			break
 
print("""");
print (""The {:,}th{} is {:,}"".format(c, tn, v))
print(""Computation time was {} seconds"".format((datetime.datetime.now() - st).seconds))
 "
z5ke,python,Cullen and Woodall numbers,Mathematics,Number Theory," 
print(""working..."")
print(""First 20 Cullen numbers:"")
 
for n in range(1,20):
    num = n*pow(2,n)+1
    print(str(num),end= "" "")
 
print()
print(""First 20 Woodall numbers:"")
 
for n in range(1,20):
    num = n*pow(2,n)-1
    print(str(num),end="" "")
 
print()
print(""done..."")
 "
kxnt,python,Cumulative standard deviation,Mathematics,Probability and Statistics,">>> from math import sqrt
>>> def sd(x):
    sd.sum  += x
    sd.sum2 += x*x
    sd.n    += 1.0
    sum, sum2, n = sd.sum, sd.sum2, sd.n
    return sqrt(sum2/n - sum*sum/n/n)
 
>>> sd.sum = sd.sum2 = sd.n = 0
>>> for value in (2,4,4,4,5,5,7,9):
    print (value, sd(value))
 
 
(2, 0.0)
(4, 1.0)
(4, 0.94280904158206258)
(4, 0.8660254037844386)
(5, 0.97979589711327075)
(5, 1.0)
(7, 1.3997084244475311)
(9, 2.0)
>>>"
kals,python,Currency,Mathematics,Algebra and Arithmetic,"from decimal import Decimal as D
from collections import namedtuple
 
Item = namedtuple('Item', 'price, quant')
 
items = dict( hamburger=Item(D('5.50'), D('4000000000000000')),
              milkshake=Item(D('2.86'), D('2')) )
tax_rate = D('0.0765')
 
fmt = ""%-10s %8s %18s %22s""
print(fmt % tuple('Item Price Quantity Extension'.upper().split()))
 
total_before_tax = 0
for item, (price, quant) in sorted(items.items()):
    ext = price * quant
    print(fmt % (item, price, quant, ext))
    total_before_tax += ext
print(fmt % ('', '', '', '--------------------'))
print(fmt % ('', '', 'subtotal', total_before_tax))
 
tax = (tax_rate * total_before_tax).quantize(D('0.00'))
print(fmt % ('', '', 'Tax', tax))
 
total = total_before_tax + tax
print(fmt % ('', '', '', '--------------------'))
print(fmt % ('', '', 'Total', total))"
agg1,python,Currying,Programming Concepts,Advanced Concepts," def addN(n):
     def adder(x):
         return x + n
     return adder"
1tri,python,Cut a rectangle,Mathematics,Combinatorics,"def cut_it(h, w):
    dirs = ((1, 0), (-1, 0), (0, -1), (0, 1))
    if h % 2: h, w = w, h
    if h % 2: return 0
    if w == 1: return 1
    count = 0
 
    next = [w + 1, -w - 1, -1, 1]
    blen = (h + 1) * (w + 1) - 1
    grid = [False] * (blen + 1)
 
    def walk(y, x, count):
        if not y or y == h or not x or x == w:
            return count + 1
 
        t = y * (w + 1) + x
        grid[t] = grid[blen - t] = True
 
        if not grid[t + next[0]]:
            count = walk(y + dirs[0][0], x + dirs[0][1], count)
        if not grid[t + next[1]]:
            count = walk(y + dirs[1][0], x + dirs[1][1], count)
        if not grid[t + next[2]]:
            count = walk(y + dirs[2][0], x + dirs[2][1], count)
        if not grid[t + next[3]]:
            count = walk(y + dirs[3][0], x + dirs[3][1], count)
 
        grid[t] = grid[blen - t] = False
        return count
 
    t = h // 2 * (w + 1) + w // 2
    if w % 2:
        grid[t] = grid[t + 1] = True
        count = walk(h // 2, w // 2 - 1, count)
        res = count
        count = 0
        count = walk(h // 2 - 1, w // 2, count)
        return res + count * 2
    else:
        grid[t] = True
        count = walk(h // 2, w // 2 - 1, count)
        if h == w:
            return count * 2
        count = walk(h // 2 - 1, w // 2, count)
        return count
 
def main():
    for w in xrange(1, 10):
        for h in xrange(1, w + 1):
            if not((w * h) % 2):
                print ""%d x %d: %d"" % (w, h, cut_it(w, h))
 
main()"
hj3a,python,Cyclotomic polynomial,Mathematics,Algebra and Arithmetic,"from itertools import count, chain
from collections import deque
 
def primes(_cache=[2, 3]):
    yield from _cache
    for n in count(_cache[-1]+2, 2):
        if isprime(n):
            _cache.append(n)
            yield n
 
def isprime(n):
    for p in primes():
        if n%p == 0:
            return False
        if p*p > n:
            return True
 
def factors(n):
    for p in primes():
    # prime factoring is such a non-issue for small numbers that, for
    # this example, we might even just say
    # for p in count(2):
        if p*p > n:
            if n > 1:
                yield(n, 1, 1)
            break
 
        if n%p == 0:
            cnt = 0
            while True:
                n, cnt = n//p, cnt+1
                if n%p != 0: break
            yield p, cnt, n
# ^^ not the most sophisticated prime number routines, because no need
 
# Returns (list1, list2) representing the division between
# two polinomials. A list p of integers means the product
#   (x^p[0] - 1) * (x^p[1] - 1) * ...
def cyclotomic(n):
    def poly_div(num, den):
        return (num[0] + den[1], num[1] + den[0])
 
    def elevate(poly, n): # replace poly p(x) with p(x**n)
        powerup = lambda p, n: [a*n for a in p]
        return poly if n == 1 else (powerup(poly[0], n), powerup(poly[1], n))
 
 
    if n == 0:
        return ([], [])
    if n == 1:
        return ([1], [])
 
    p, m, r = next(factors(n))
    poly = cyclotomic(r)
    return elevate(poly_div(elevate(poly, p), poly), p**(m-1))
 
def to_text(poly):
    def getx(c, e):
        if e == 0:
            return '1'
        elif e == 1:
            return 'x'
        return 'x' + (''.join('⁰¹²³⁴⁵⁶⁷⁸⁹'[i] for i in map(int, str(e))))
 
    parts = []
    for (c,e) in (poly):
        if c < 0:
            coef = ' - ' if c == -1 else f' - {-c} '
        else:
            coef = (parts and ' + ' or '') if c == 1 else f' + {c}'
        parts.append(coef + getx(c,e))
    return ''.join(parts)
 
def terms(poly):
    # convert above representation of division to (coef, power) pairs
 
    def merge(a, b):
        # a, b should be deques. They may change during the course.
        while a or b:
            l = a[0] if a else (0, -1) # sentinel value
            r = b[0] if b else (0, -1)
            if l[1] > r[1]:
                a.popleft()
            elif l[1] < r[1]:
                b.popleft()
                l = r
            else:
                a.popleft()
                b.popleft()
                l = (l[0] + r[0], l[1])
            yield l
 
    def mul(poly, p): # p means polynomial x^p - 1
        poly = list(poly)
        return merge(deque((c, e+p) for c,e in poly),
                     deque((-c, e) for c,e in poly))
 
    def div(poly, p): # p means polynomial x^p - 1
        q = deque()
        for c,e in merge(deque(poly), q):
            if c:
                q.append((c, e - p))
                yield (c, e - p)
            if e == p: break
 
    p = [(1, 0)]  # 1*x^0, i.e. 1
 
    for x in poly[0]: # numerator
        p = mul(p, x)
    for x in sorted(poly[1], reverse=True): # denominator
        p = div(p, x)
    return p
 
for n in chain(range(11), [2]):
    print(f'{n}: {to_text(terms(cyclotomic(n)))}')
 
want = 1
for n in count():
    c = [c for c,_ in terms(cyclotomic(n))]
    while want in c or -want in c:
        print(f'C[{want}]: {n}')
        want += 1"
rnts,python,DNS query,Networking and Web Development,Networking,">>> import socket
>>> ips = set(i[4][0] for i in socket.getaddrinfo('www.kame.net', 80))
>>> for ip in ips: print ip
...
2001:200:dff:fff1:216:3eff:feb1:44d7
203.178.141.194"
bbzy,python,Damm algorithm,Security and Cryptography,Cryptographic Techniques,"def damm(num: int) -> bool:
    row = 0
    for digit in str(num):
        row = _matrix[row][int(digit)] 
    return row == 0
 
_matrix = (
    (0, 3, 1, 7, 5, 9, 8, 6, 4, 2),
    (7, 0, 9, 2, 1, 5, 4, 8, 6, 3),
    (4, 2, 0, 6, 8, 7, 1, 3, 5, 9),
    (1, 7, 5, 0, 9, 8, 3, 4, 2, 6),
    (6, 1, 2, 3, 0, 4, 5, 9, 7, 8),
    (3, 6, 7, 4, 2, 0, 9, 5, 8, 1),
    (5, 8, 6, 9, 7, 2, 0, 1, 3, 4),
    (8, 9, 4, 5, 3, 6, 2, 0, 1, 7),
    (9, 4, 3, 8, 6, 1, 7, 2, 0, 5),
    (2, 5, 8, 1, 4, 3, 6, 7, 9, 0)
)
 
if __name__ == '__main__':
    for test in [5724, 5727, 112946]:
        print(f'{test}\t Validates as: {damm(test)}')"
bli0,python,Date format,Miscellaneous Topics,Time and Date Manipulation,"import datetime
today = datetime.date.today()
# The first requested format is a method of datetime objects:
today.isoformat()
# For full flexibility, use the strftime formatting codes from the link above:
today.strftime(""%A, %B %d, %Y"")
# This mechanism is integrated into the general string formatting system.
# You can do this with positional arguments referenced by number
""The date is {0:%A, %B %d, %Y}"".format(d)
# Or keyword arguments referenced by name
""The date is {date:%A, %B %d, %Y}"".format(date=d)
# Since Python 3.6, f-strings allow the value to be inserted inline
f""The date is {d:%A, %B %d, %Y}""
 "
807i,python,Date manipulation,Miscellaneous Topics,Time and Date Manipulation,"import datetime
 
def mt():
	datime1=""March 7 2009 7:30pm EST""
	formatting = ""%B %d %Y %I:%M%p ""
	datime2 = datime1[:-3]  # format can't handle ""EST"" for some reason
	tdelta = datetime.timedelta(hours=12)		# twelve hours..
	s3 = datetime.datetime.strptime(datime2, formatting)
	datime2 = s3+tdelta
	print datime2.strftime(""%B %d %Y %I:%M%p %Z"") + datime1[-3:]
 
mt()"
g50e,python,Day of the week,Mathematics,Calendar and Date Calculations,"from calendar import weekday, SUNDAY
 
[year for year in range(2008, 2122) if weekday(year, 12, 25) == SUNDAY]"
i1ru,python,Deal cards for FreeCell,Puzzles and Games,Game Development," 
 
def randomGenerator(seed=1):
    max_int32 = (1 << 31) - 1
    seed = seed & max_int32
 
    while True:
        seed = (seed * 214013 + 2531011) & max_int32
        yield seed >> 16
 
def deal(seed):
    nc = 52
    cards = list(range(nc - 1, -1, -1))
    rnd = randomGenerator(seed)
    for i, r in zip(range(nc), rnd):
        j = (nc - 1) - r % (nc - i)
        cards[i], cards[j] = cards[j], cards[i]
    return cards
 
def show(cards):
    l = [""A23456789TJQK""[int(c/4)] + ""CDHS""[c%4] for c in cards]
    for i in range(0, len(cards), 8):
        print("" "".join(l[i : i+8]))
 
if __name__ == '__main__':
    from sys import argv
    seed = int(argv[1]) if len(argv) == 2 else 11982
    print(""Hand {}"".format(seed))
    deck = deal(seed)
    show(deck)"
ux9x,python,Death Star,Graphics and Visualization,Graphics Programming,"import sys, math, collections
 
Sphere = collections.namedtuple(""Sphere"", ""cx cy cz r"")
V3 = collections.namedtuple(""V3"", ""x y z"")
 
def normalize((x, y, z)):
    len = math.sqrt(x**2 + y**2 + z**2)
    return V3(x / len, y / len, z / len)
 
def dot(v1, v2):
    d = v1.x*v2.x + v1.y*v2.y + v1.z*v2.z
    return -d if d < 0 else 0.0
 
def hit_sphere(sph, x0, y0):
    x = x0 - sph.cx
    y = y0 - sph.cy
    zsq = sph.r ** 2 - (x ** 2 + y ** 2)
    if zsq < 0:
        return (False, 0, 0)
    szsq = math.sqrt(zsq)
    return (True, sph.cz - szsq, sph.cz + szsq)
 
def draw_sphere(k, ambient, light):
    shades = "".:!*oe&#%@""
    pos = Sphere(20.0, 20.0, 0.0, 20.0)
    neg = Sphere(1.0, 1.0, -6.0, 20.0)
 
    for i in xrange(int(math.floor(pos.cy - pos.r)),
                    int(math.ceil(pos.cy + pos.r) + 1)):
        y = i + 0.5
        for j in xrange(int(math.floor(pos.cx - 2 * pos.r)),
                        int(math.ceil(pos.cx + 2 * pos.r) + 1)):
            x = (j - pos.cx) / 2.0 + 0.5 + pos.cx
 
            (h, zb1, zb2) = hit_sphere(pos, x, y)
            if not h:
                hit_result = 0
            else:
                (h, zs1, zs2) = hit_sphere(neg, x, y)
                if not h:
                    hit_result = 1
                elif zs1 > zb1:
                    hit_result = 1
                elif zs2 > zb2:
                    hit_result = 0
                elif zs2 > zb1:
                    hit_result = 2
                else:
                    hit_result = 1
 
            if hit_result == 0:
                sys.stdout.write(' ')
                continue
            elif hit_result == 1:
                vec = V3(x - pos.cx, y - pos.cy, zb1 - pos.cz)
            elif hit_result == 2:
                vec = V3(neg.cx-x, neg.cy-y, neg.cz-zs2)
            vec = normalize(vec)
 
            b = dot(light, vec) ** k + ambient
            intensity = int((1 - b) * len(shades))
            intensity = min(len(shades), max(0, intensity))
            sys.stdout.write(shades[intensity])
        print
 
light = normalize(V3(-50, 30, 50))
draw_sphere(2, 0.5, light)"
10i0,python,Deconvolution/1D,Mathematics,Numerical Methods,"def ToReducedRowEchelonForm( M ):
    if not M: return
    lead = 0
    rowCount = len(M)
    columnCount = len(M[0])
    for r in range(rowCount):
        if lead >= columnCount:
            return
        i = r
        while M[i][lead] == 0:
            i += 1
            if i == rowCount:
                i = r
                lead += 1
                if columnCount == lead:
                    return
        M[i],M[r] = M[r],M[i]
        lv = M[r][lead]
        M[r] = [ mrx / lv for mrx in M[r]]
        for i in range(rowCount):
            if i != r:
                lv = M[i][lead]
                M[i] = [ iv - lv*rv for rv,iv in zip(M[r],M[i])]
        lead += 1
    return M
 
def pmtx(mtx):
    print ('\n'.join(''.join(' %4s' % col for col in row) for row in mtx))
 
def convolve(f, h):
    g = [0] * (len(f) + len(h) - 1)
    for hindex, hval in enumerate(h):
        for findex, fval in enumerate(f):
            g[hindex + findex] += fval * hval
    return g
 
def deconvolve(g, f):
    lenh = len(g) - len(f) + 1
    mtx = [[0 for x in range(lenh+1)] for y in g]
    for hindex in range(lenh):
        for findex, fval in enumerate(f):
            gindex = hindex + findex
            mtx[gindex][hindex] = fval
    for gindex, gval in enumerate(g):        
        mtx[gindex][lenh] = gval
    ToReducedRowEchelonForm( mtx )
    return [mtx[i][lenh] for i in range(lenh)]  # h
 
if __name__ == '__main__':
    h = [-8,-9,-3,-1,-6,7]
    f = [-3,-6,-1,8,-6,3,-1,-9,-9,3,-2,5,2,-2,-7,-1]
    g = [24,75,71,-34,3,22,-45,23,245,25,52,25,-67,-96,96,31,55,36,29,-43,-7]
    assert convolve(f,h) == g
    assert deconvolve(g, f) == h"
5obo,python,Deconvolution/2D+,Mathematics,Numerical Methods," 
""""""
 
https://rosettacode.org/wiki/Deconvolution/2D%2B
 
Working on 3 dimensional example using test data from the
RC task.
 
Python fft:
 
https://docs.scipy.org/doc/numpy/reference/routines.fft.html
 
""""""
 
import numpy
import pprint
 
h =  [
      [[-6, -8, -5, 9], [-7, 9, -6, -8], [2, -7, 9, 8]], 
      [[7, 4, 4, -6], [9, 9, 4, -4], [-3, 7, -2, -3]]]
f =  [
      [[-9, 5, -8], [3, 5, 1]], 
      [[-1, -7, 2], [-5, -6, 6]], 
      [[8, 5, 8],[-2, -6, -4]]]
g =  [
      [
         [54, 42, 53, -42, 85, -72], 
         [45, -170, 94, -36, 48, 73], 
         [-39, 65, -112, -16, -78, -72], 
         [6, -11, -6, 62, 49, 8]], 
      [
         [-57, 49, -23, 52, -135, 66], 
         [-23, 127, -58, -5, -118, 64], 
         [87, -16, 121, 23, -41, -12], 
         [-19, 29, 35, -148, -11, 45]], 
      [
         [-55, -147, -146, -31, 55, 60], 
         [-88, -45, -28, 46, -26, -144], 
         [-12, -107, -34, 150, 249, 66], 
         [11, -15, -34, 27, -78, -50]], 
      [
         [56, 67, 108, 4, 2, -48], 
         [58, 67, 89, 32, 32, -8], 
         [-42, -31, -103, -30, -23, -8],
         [6, 4, -26, -10, 26, 12]]]
 
def trim_zero_empty(x):
    """"""
 
    Takes a structure that represents an n dimensional example. 
    For a 2 dimensional example it will be a list of lists.
    For a 3 dimensional one it will be a list of list of lists.
    etc.
 
    Actually these are multidimensional numpy arrays but I was thinking
    in terms of lists.
 
    Returns the same structure without trailing zeros in the inner
    lists and leaves out inner lists with all zeros.
 
    """"""
 
    if len(x) > 0:
        if type(x[0]) != numpy.ndarray:
            # x is 1d array
            return list(numpy.trim_zeros(x))
        else:
            # x is a multidimentional array
            new_x = []
            for l in x:
               tl = trim_zero_empty(l)
               if len(tl) > 0:
                   new_x.append(tl)
            return new_x
    else:
        # x is empty list
        return x
 
def deconv(a, b):
    """"""
 
    Returns function c such that b * c = a.
 
    https://en.wikipedia.org/wiki/Deconvolution
 
    """"""
 
    # Convert larger polynomial using fft
 
    ffta = numpy.fft.fftn(a)
 
    # Get it's shape so fftn will expand
    # smaller polynomial to fit.
 
    ashape = numpy.shape(a)
 
    # Convert smaller polynomial with fft
    # using the shape of the larger one
 
    fftb = numpy.fft.fftn(b,ashape)
 
    # Divide the two in frequency domain
 
    fftquotient = ffta / fftb
 
    # Convert back to polynomial coefficients using ifft
    # Should give c but with some small extra components
 
    c = numpy.fft.ifftn(fftquotient)
 
    # Get rid of imaginary part and round up to 6 decimals
    # to get rid of small real components
 
    trimmedc = numpy.around(numpy.real(c),decimals=6)
 
    # Trim zeros and eliminate
    # empty rows of coefficients
 
    cleanc = trim_zero_empty(trimmedc)
 
    return cleanc
 
print(""deconv(g,h)="")
 
pprint.pprint(deconv(g,h))
 
print("" "")
 
print(""deconv(g,f)="")
 
pprint.pprint(deconv(g,f))
 "
1uob,python,Deepcopy,Algorithms and Data Structures,Data Structures,"import copy
deepcopy_of_obj = copy.deepcopy(obj)"
js0u,python,Define a primitive data type,Programming Concepts,Fundamentals,">>> class num(int):
    def __init__(self, b):
        if 1 <= b <= 10:
            return int.__init__(self+0)
        else:
            raise ValueError,""Value %s should be >=0 and <= 10"" % b
 
 
>>> x = num(3)
>>> x = num(11)
 
Traceback (most recent call last):
  File ""<pyshell#394>"", line 1, in <module>
    x = num(11)
  File ""<pyshell#392>"", line 6, in __init__
    raise ValueError,""Value %s should be >=0 and <= 10"" % b
ValueError: Value 11 should be >=0 and <= 10
>>> x
3
>>> type(x)
<class '__main__.num'>
>>>"
rthc,python,Delegates,Programming Concepts,Advanced Concepts,"class Delegator:
   def __init__(self):
      self.delegate = None
   def operation(self):
       if hasattr(self.delegate, 'thing') and callable(self.delegate.thing):
          return self.delegate.thing()
       return 'default implementation'
 
class Delegate:
   def thing(self):
      return 'delegate implementation'
 
if __name__ == '__main__':
 
   # No delegate
   a = Delegator()
   assert a.operation() == 'default implementation'
 
   # With a delegate that does not implement ""thing""
   a.delegate = 'A delegate may be any object'
   assert a.operation() == 'default implementation'
 
   # With delegate that implements ""thing""
   a.delegate = Delegate()
   assert a.operation() == 'delegate implementation'"
8r66,python,Delete a file,Systems Programming and File I/O,File Operations,"import os
# current directory
os.remove(""output.txt"")
os.rmdir(""docs"")
# root directory
os.remove(""/output.txt"")
os.rmdir(""/docs"")"
bnd1,python,Deming's Funnel,Mathematics,Probability and Statistics,"import math 
 
dxs = [-0.533, 0.27, 0.859, -0.043, -0.205, -0.127, -0.071, 0.275, 1.251,
       -0.231, -0.401, 0.269, 0.491, 0.951, 1.15, 0.001, -0.382, 0.161, 0.915,
       2.08, -2.337, 0.034, -0.126, 0.014, 0.709, 0.129, -1.093, -0.483, -1.193, 
       0.02, -0.051, 0.047, -0.095, 0.695, 0.34, -0.182, 0.287, 0.213, -0.423,
       -0.021, -0.134, 1.798, 0.021, -1.099, -0.361, 1.636, -1.134, 1.315, 0.201, 
       0.034, 0.097, -0.17, 0.054, -0.553, -0.024, -0.181, -0.7, -0.361, -0.789,
       0.279, -0.174, -0.009, -0.323, -0.658, 0.348, -0.528, 0.881, 0.021, -0.853,
       0.157, 0.648, 1.774, -1.043, 0.051, 0.021, 0.247, -0.31, 0.171, 0.0, 0.106,
       0.024, -0.386, 0.962, 0.765, -0.125, -0.289, 0.521, 0.017, 0.281, -0.749,
       -0.149, -2.436, -0.909, 0.394, -0.113, -0.598, 0.443, -0.521, -0.799, 
       0.087]
 
dys = [0.136, 0.717, 0.459, -0.225, 1.392, 0.385, 0.121, -0.395, 0.49, -0.682,
       -0.065, 0.242, -0.288, 0.658, 0.459, 0.0, 0.426, 0.205, -0.765, -2.188, 
       -0.742, -0.01, 0.089, 0.208, 0.585, 0.633, -0.444, -0.351, -1.087, 0.199,
       0.701, 0.096, -0.025, -0.868, 1.051, 0.157, 0.216, 0.162, 0.249, -0.007, 
       0.009, 0.508, -0.79, 0.723, 0.881, -0.508, 0.393, -0.226, 0.71, 0.038, 
       -0.217, 0.831, 0.48, 0.407, 0.447, -0.295, 1.126, 0.38, 0.549, -0.445, 
       -0.046, 0.428, -0.074, 0.217, -0.822, 0.491, 1.347, -0.141, 1.23, -0.044, 
       0.079, 0.219, 0.698, 0.275, 0.056, 0.031, 0.421, 0.064, 0.721, 0.104, 
       -0.729, 0.65, -1.103, 0.154, -1.72, 0.051, -0.385, 0.477, 1.537, -0.901, 
       0.939, -0.411, 0.341, -0.411, 0.106, 0.224, -0.947, -1.424, -0.542, -1.032]
 
def funnel(dxs, rule):
    x, rxs = 0, []
    for dx in dxs:
        rxs.append(x + dx)
        x = rule(x, dx)
    return rxs
 
def mean(xs): return sum(xs) / len(xs)
 
def stddev(xs):
    m = mean(xs)
    return math.sqrt(sum((x-m)**2 for x in xs) / len(xs))
 
def experiment(label, rule):
    rxs, rys = funnel(dxs, rule), funnel(dys, rule)
    print label
    print 'Mean x, y    : %.4f, %.4f' % (mean(rxs), mean(rys))
    print 'Std dev x, y : %.4f, %.4f' % (stddev(rxs), stddev(rys))
    print
 
 
experiment('Rule 1:', lambda z, dz: 0)
experiment('Rule 2:', lambda z, dz: -dz)
experiment('Rule 3:', lambda z, dz: -(z+dz))
experiment('Rule 4:', lambda z, dz: z+dz)"
6mz1,python,Department numbers,Puzzles and Games,Logic and Mathematical Puzzles,"from itertools import permutations
 
def solve():
    c, p, f, s = ""\\,Police,Fire,Sanitation"".split(',')
    print(f""{c:>3}  {p:^6} {f:^4} {s:^10}"")
    c = 1
    for p, f, s in permutations(range(1, 8), r=3):
        if p + s + f == 12 and p % 2 == 0:
            print(f""{c:>3}: {p:^6} {f:^4} {s:^10}"")
            c += 1
 
if __name__ == '__main__':
    solve()"
ie13,python,Descending primes,Mathematics,Number Theory,"from sympy import isprime
 
def descending(xs=range(10)):
    for x in xs:
        yield x
        yield from descending(x*10 + d for d in range(x%10))
 
for i, p in enumerate(sorted(filter(isprime, descending()))):
    print(f'{p:9d}', end=' ' if (1 + i)%8 else '\n')
 
print()"
5mm7,python,Detect division by zero,Programming Concepts,Fundamentals,"def div_check(x, y):
  try:
    x / y
  except ZeroDivisionError:
    return True
  else:
    return False"
bncn,python,Determinant and permanent,Mathematics,Algebra and Arithmetic,"from itertools import permutations
from operator import mul
from math import fsum
from spermutations import spermutations
 
def prod(lst):
    return reduce(mul, lst, 1)
 
def perm(a):
    n = len(a)
    r = range(n)
    s = permutations(r)
    return fsum(prod(a[i][sigma[i]] for i in r) for sigma in s)
 
def det(a):
    n = len(a)
    r = range(n)
    s = spermutations(n)
    return fsum(sign * prod(a[i][sigma[i]] for i in r)
                for sigma, sign in s)
 
if __name__ == '__main__':
    from pprint import pprint as pp
 
    for a in ( 
            [
             [1, 2], 
             [3, 4]], 
 
            [
             [1, 2, 3, 4],
             [4, 5, 6, 7],
             [7, 8, 9, 10],
             [10, 11, 12, 13]],        
 
            [
             [ 0,  1,  2,  3,  4],
             [ 5,  6,  7,  8,  9],
             [10, 11, 12, 13, 14],
             [15, 16, 17, 18, 19],
             [20, 21, 22, 23, 24]],
        ):
        print('')
        pp(a)
        print('Perm: %s Det: %s' % (perm(a), det(a)))"
4yoz,python,Determine if a string has all the same characters,Puzzles and Games,Logic and Mathematical Puzzles,"'''Determine if a string has all the same characters'''
 
from itertools import groupby
 
 
# firstDifferingCharLR :: String -> Either String Dict
def firstDifferingCharLR(s):
    '''Either a message reporting that no character changes were
       seen, or a dictionary with details of the  first character
       (if any) that differs from that at the head of the string.
    '''
    def details(xs):
        c = xs[1][0]
        return {
            'char': repr(c),
            'hex': hex(ord(c)),
            'index': s.index(c),
            'total': len(s)
        }
    xs = list(groupby(s))
    return Right(details(xs)) if 1 < len(xs) else (
        Left('Total length ' + str(len(s)) + ' - No character changes.')
    )
 
 
# TEST ----------------------------------------------------
# main :: IO ()
def main():
    '''Test of 7 strings'''
 
    print(fTable('First, if any, points of difference:\n')(repr)(
        either(identity)(
            lambda dct: dct['char'] + ' (' + dct['hex'] +
            ') at character ' + str(1 + dct['index']) +
            ' of ' + str(dct['total']) + '.'
        )
    )(firstDifferingCharLR)([
        '',
        '   ',
        '2',
        '333',
        '.55',
        'tttTTT',
        '4444 444'
    ]))
 
 
# GENERIC -------------------------------------------------
 
# either :: (a -> c) -> (b -> c) -> Either a b -> c
def either(fl):
    '''The application of fl to e if e is a Left value,
       or the application of fr to e if e is a Right value.
    '''
    return lambda fr: lambda e: fl(e['Left']) if (
        None is e['Right']
    ) else fr(e['Right'])
 
 
# identity :: a -> a
def identity(x):
    '''The identity function.'''
    return x
 
 
# fTable :: String -> (a -> String) ->
# (b -> String) -> (a -> b) -> [a] -> String
def fTable(s):
    '''Heading -> x display function -> fx display function ->
       f -> xs -> tabular string.
    '''
    def go(xShow, fxShow, f, xs):
        ys = [xShow(x) for x in xs]
        w = max(map(len, ys))
        return s + '\n' + '\n'.join(map(
            lambda x, y: y.rjust(w, ' ') + ' -> ' + fxShow(f(x)),
            xs, ys
        ))
    return lambda xShow: lambda fxShow: lambda f: lambda xs: go(
        xShow, fxShow, f, xs
    )
 
 
# Left :: a -> Either a b
def Left(x):
    '''Constructor for an empty Either (option type) value
       with an associated string.
    '''
    return {'type': 'Either', 'Right': None, 'Left': x}
 
 
# Right :: b -> Either a b
def Right(x):
    '''Constructor for a populated Either (option type) value'''
    return {'type': 'Either', 'Left': None, 'Right': x}
 
 
# MAIN ---
if __name__ == '__main__':
    main()"
gh5x,python,Determine if a string has all unique characters,Puzzles and Games,Logic and Mathematical Puzzles,"'''Determine if a string has all unique characters'''
 
from itertools import groupby
 
 
# duplicatedCharIndices :: String -> Maybe (Char, [Int])
def duplicatedCharIndices(s):
    '''Just the first duplicated character, and
       the indices of its occurrence, or
       Nothing if there are no duplications.
    '''
    def go(xs):
        if 1 < len(xs):
            duplicates = list(filter(lambda kv: 1 < len(kv[1]), [
                (k, list(v)) for k, v in groupby(
                    sorted(xs, key=swap),
                    key=snd
                )
            ]))
            return Just(second(fmap(fst))(
                sorted(
                    duplicates,
                    key=lambda kv: kv[1][0]
                )[0]
            )) if duplicates else Nothing()
        else:
            return Nothing()
    return go(list(enumerate(s)))
 
 
# TEST ----------------------------------------------------
# main :: IO ()
def main():
    '''Test over various strings.'''
 
    def showSample(s):
        return repr(s) + ' (' + str(len(s)) + ')'
 
    def showDuplicate(cix):
        c, ix = cix
        return repr(c) + (
            ' (' + hex(ord(c)) + ') at ' + repr(ix)
        )
 
    print(
        fTable('First duplicated character, if any:')(
            showSample
        )(maybe('None')(showDuplicate))(duplicatedCharIndices)([
            '', '.', 'abcABC', 'XYZ ZYX',
            '1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ'
        ])
    )
 
 
# FORMATTING ----------------------------------------------
 
# fTable :: String -> (a -> String) ->
# (b -> String) -> (a -> b) -> [a] -> String
def fTable(s):
    '''Heading -> x display function -> fx display function ->
       f -> xs -> tabular string.
    '''
    def go(xShow, fxShow, f, xs):
        ys = [xShow(x) for x in xs]
        w = max(map(len, ys))
        return s + '\n' + '\n'.join(map(
            lambda x, y: y.rjust(w, ' ') + ' -> ' + fxShow(f(x)),
            xs, ys
        ))
    return lambda xShow: lambda fxShow: lambda f: lambda xs: go(
        xShow, fxShow, f, xs
    )
 
 
# GENERIC -------------------------------------------------
 
# Just :: a -> Maybe a
def Just(x):
    '''Constructor for an inhabited Maybe (option type) value.
       Wrapper containing the result of a computation.
    '''
    return {'type': 'Maybe', 'Nothing': False, 'Just': x}
 
 
# Nothing :: Maybe a
def Nothing():
    '''Constructor for an empty Maybe (option type) value.
       Empty wrapper returned where a computation is not possible.
    '''
    return {'type': 'Maybe', 'Nothing': True}
 
 
# fmap :: (a -> b) -> [a] -> [b]
def fmap(f):
    '''fmap over a list.
       f lifted to a function over a list.
    '''
    return lambda xs: [f(x) for x in xs]
 
 
# fst :: (a, b) -> a
def fst(tpl):
    '''First member of a pair.'''
    return tpl[0]
 
 
# head :: [a] -> a
def head(xs):
    '''The first element of a non-empty list.'''
    return xs[0] if isinstance(xs, list) else next(xs)
 
 
# maybe :: b -> (a -> b) -> Maybe a -> b
def maybe(v):
    '''Either the default value v, if m is Nothing,
       or the application of f to x,
       where m is Just(x).
    '''
    return lambda f: lambda m: v if (
        None is m or m.get('Nothing')
    ) else f(m.get('Just'))
 
 
# second :: (a -> b) -> ((c, a) -> (c, b))
def second(f):
    '''A simple function lifted to a function over a tuple,
       with f applied only to the second of two values.
    '''
    return lambda xy: (xy[0], f(xy[1]))
 
 
# snd :: (a, b) -> b
def snd(tpl):
    '''Second member of a pair.'''
    return tpl[1]
 
 
# swap :: (a, b) -> (b, a)
def swap(tpl):
    '''The swapped components of a pair.'''
    return (tpl[1], tpl[0])
 
 
# MAIN ---
if __name__ == '__main__':
    main()"
0v2n,python,Determine if a string is collapsible,Text Processing,String Manipulation,"from itertools import groupby
 
def collapser(txt):
    return ''.join(item for item, grp in groupby(txt))
 
if __name__ == '__main__':
    strings = [
            """",
            '""If I were two-faced, would I be wearing this one?"" --- Abraham Lincoln ',
            ""..1111111111111111111111111111111111111111111111111111111111111117777888"",
            ""I never give 'em hell, I just tell the truth, and they think it's hell. "",
            ""                                                   ---  Harry S Truman  "",
            ""The better the 4-wheel drive, the further you'll be from help when ya get stuck!"",
            ""headmistressship"",
            ""aardvark"",
            ""😍😀🙌💃😍😍😍🙌"",
            ]
    for txt in strings:
        this = ""Original""
        print(f""\n{this:14} Size: {len(txt)} «««{txt}»»»"" )
        this = ""Collapsed""
        sqz = collapser(txt)
        print(f""{this:>14} Size: {len(sqz)} «««{sqz}»»»"" )"
rsnj,python,Determine if a string is numeric,Text Processing,String Manipulation,"def is_numeric(s):
    try:
        float(s)
        return True
    except (ValueError, TypeError):
        return False
 
is_numeric('123.0')"
kmw2,python,Determine if a string is squeezable,Text Processing,String Manipulation,"from itertools import groupby
 
def squeezer(s, txt):
    return ''.join(item if item == s else ''.join(grp)
                   for item, grp in groupby(txt))
 
if __name__ == '__main__':
    strings = [
            """",
            '""If I were two-faced, would I be wearing this one?"" --- Abraham Lincoln ',
            ""..1111111111111111111111111111111111111111111111111111111111111117777888"",
            ""I never give 'em hell, I just tell the truth, and they think it's hell. "",
            ""                                                   ---  Harry S Truman  "",
            ""The better the 4-wheel drive, the further you'll be from help when ya get stuck!"",
            ""headmistressship"",
            ""aardvark"",
            ""😍😀🙌💃😍😍😍🙌"",
            ]
    squeezers = ' ,-,7,., -r,e,s,a,😍'.split(',')
    for txt, chars in zip(strings, squeezers):
        this = ""Original""
        print(f""\n{this:14} Size: {len(txt)} «««{txt}»»»"" )
        for ch in chars:
            this = f""Squeezer '{ch}'""
            sqz = squeezer(ch, txt)
            print(f""{this:>14} Size: {len(sqz)} «««{sqz}»»»"" )"
9hpn,python,Determine if only one instance is running,Operating Systems and Shell Programming,Operating System Concepts,"import __main__, os
 
def isOnlyInstance():
    # Determine if there are more than the current instance of the application
    # running at the current time.
    return os.system(""(( $(ps -ef | grep python | grep '["" +
                     __main__.__file__[0] + ""]"" + __main__.__file__[1:] +
                     ""' | wc -l) > 1 ))"") != 0"
gm8i,python,Determine if two triangles overlap,Puzzles and Games,Logic and Mathematical Puzzles,"from __future__ import print_function
import numpy as np
 
def CheckTriWinding(tri, allowReversed):
	trisq = np.ones((3,3))
	trisq[:,0:2] = np.array(tri)
	detTri = np.linalg.det(trisq)
	if detTri < 0.0:
		if allowReversed:
			a = trisq[2,:].copy()
			trisq[2,:] = trisq[1,:]
			trisq[1,:] = a
		else: raise ValueError(""triangle has wrong winding direction"")
	return trisq
 
def TriTri2D(t1, t2, eps = 0.0, allowReversed = False, onBoundary = True):
	#Trangles must be expressed anti-clockwise
	t1s = CheckTriWinding(t1, allowReversed)
	t2s = CheckTriWinding(t2, allowReversed)
 
	if onBoundary:
		#Points on the boundary are considered as colliding
		chkEdge = lambda x: np.linalg.det(x) < eps
	else:
		#Points on the boundary are not considered as colliding
		chkEdge = lambda x: np.linalg.det(x) <= eps
 
	#For edge E of trangle 1,
	for i in range(3):
		edge = np.roll(t1s, i, axis=0)[:2,:]
 
		#Check all points of trangle 2 lay on the external side of the edge E. If
		#they do, the triangles do not collide.
		if (chkEdge(np.vstack((edge, t2s[0]))) and
			chkEdge(np.vstack((edge, t2s[1]))) and  
			chkEdge(np.vstack((edge, t2s[2])))):
			return False
 
	#For edge E of trangle 2,
	for i in range(3):
		edge = np.roll(t2s, i, axis=0)[:2,:]
 
		#Check all points of trangle 1 lay on the external side of the edge E. If
		#they do, the triangles do not collide.
		if (chkEdge(np.vstack((edge, t1s[0]))) and
			chkEdge(np.vstack((edge, t1s[1]))) and  
			chkEdge(np.vstack((edge, t1s[2])))):
			return False
 
	#The triangles collide
	return True
 
if __name__==""__main__"":
	t1 = [[0,0],[5,0],[0,5]]
	t2 = [[0,0],[5,0],[0,6]]
	print (TriTri2D(t1, t2), True)
 
	t1 = [[0,0],[0,5],[5,0]]
	t2 = [[0,0],[0,6],[5,0]]
	print (TriTri2D(t1, t2, allowReversed = True), True)
 
	t1 = [[0,0],[5,0],[0,5]]
	t2 = [[-10,0],[-5,0],[-1,6]]
	print (TriTri2D(t1, t2), False)
 
	t1 = [[0,0],[5,0],[2.5,5]]
	t2 = [[0,4],[2.5,-1],[5,4]]
	print (TriTri2D(t1, t2), True)
 
	t1 = [[0,0],[1,1],[0,2]]
	t2 = [[2,1],[3,0],[3,2]]
	print (TriTri2D(t1, t2), False)
 
	t1 = [[0,0],[1,1],[0,2]]
	t2 = [[2,1],[3,-2],[3,4]]
	print (TriTri2D(t1, t2), False)
 
	#Barely touching
	t1 = [[0,0],[1,0],[0,1]]
	t2 = [[1,0],[2,0],[1,1]]
	print (TriTri2D(t1, t2, onBoundary = True), True)
 
	#Barely touching
	t1 = [[0,0],[1,0],[0,1]]
	t2 = [[1,0],[2,0],[1,1]]
	print (TriTri2D(t1, t2, onBoundary = False), False)"
don9,python,Determine sentence type,Text Processing,String Manipulation,"import re
 
txt = """"""
Hi there, how are you today? I'd like to present to you the washing machine 9001.
You have been nominated to win one of these! Just make sure you don't break it""""""
 
def haspunctotype(s):
    return 'S' if '.' in s else 'E' if '!' in s else 'Q' if '?' in s else 'N'
 
txt = re.sub('\n', '', txt)
pars = [s.strip() for s in re.split(""(?:(?:(?<=[\?\!\.])(?:))|(?:(?:)(?=[\?\!\.])))"", txt)]
if len(pars) % 2:
    pars.append('')  # if ends without punctuation
for i in range(0, len(pars)-1, 2):
    print((pars[i] + pars[i + 1]).ljust(54), ""==>"", haspunctotype(pars[i + 1]))
 "
febv,python,Dice game probabilities,Mathematics,Probability and Statistics,"from itertools import product
 
def gen_dict(n_faces, n_dice):
    counts = [0] * ((n_faces + 1) * n_dice)
    for t in product(range(1, n_faces + 1), repeat=n_dice):
        counts[sum(t)] += 1
    return counts, n_faces ** n_dice
 
def beating_probability(n_sides1, n_dice1, n_sides2, n_dice2):
    c1, p1 = gen_dict(n_sides1, n_dice1)
    c2, p2 = gen_dict(n_sides2, n_dice2)
    p12 = float(p1 * p2)
 
    return sum(p[1] * q[1] / p12
               for p, q in product(enumerate(c1), enumerate(c2))
               if p[0] > q[0])
 
print beating_probability(4, 9, 6, 6)
print beating_probability(10, 5, 7, 6)"
0jwi,python,Digital root,Mathematics,Number Theory,"def digital_root (n):
    ap = 0
    n = abs(int(n))
    while n >= 10:
        n = sum(int(digit) for digit in str(n))
        ap += 1
    return ap, n
 
if __name__ == '__main__':
    for n in [627615, 39390, 588225, 393900588225, 55]:
        persistance, root = digital_root(n)
        print(""%12i has additive persistance %2i and digital root %i."" 
              % (n, persistance, root))"
ep39,python,Digital root/Multiplicative digital root,Mathematics,Number Theory,"try:
    from functools import reduce
except:
    pass
 
def mdroot(n):
    'Multiplicative digital root'
    mdr = [n]
    while mdr[-1] > 9:
        mdr.append(reduce(int.__mul__, (int(dig) for dig in str(mdr[-1])), 1))
    return len(mdr) - 1, mdr[-1]
 
if __name__ == '__main__':
    print('Number: (MP, MDR)\n======  =========')
    for n in (123321, 7739, 893, 899998):
        print('%6i: %r' % (n, mdroot(n)))
 
    table, n = {i: [] for i in range(10)}, 0
    while min(len(row) for row in table.values()) < 5:
        mpersistence, mdr = mdroot(n)
        table[mdr].append(n)
        n += 1
    print('\nMP: [n0..n4]\n==  ========')
    for mp, val in sorted(table.items()):
        print('%2i: %r' % (mp, val[:5]))"
hvxk,python,Dijkstra's algorithm,Algorithms and Data Structures,Algorithms,"from collections import namedtuple, deque
from pprint import pprint as pp
 
 
inf = float('inf')
Edge = namedtuple('Edge', ['start', 'end', 'cost'])
 
class Graph():
    def __init__(self, edges):
        self.edges = [Edge(*edge) for edge in edges]
        # print(dir(self.edges[0]))
        self.vertices = {e.start for e in self.edges} | {e.end for e in self.edges}
 
    def dijkstra(self, source, dest):
        assert source in self.vertices
        dist = {vertex: inf for vertex in self.vertices}
        previous = {vertex: None for vertex in self.vertices}
        dist[source] = 0
        q = self.vertices.copy()
        neighbours = {vertex: set() for vertex in self.vertices}
        for start, end, cost in self.edges:
            neighbours[start].add((end, cost))
            neighbours[end].add((start, cost))
 
        #pp(neighbours)
 
        while q:
            # pp(q)
            u = min(q, key=lambda vertex: dist[vertex])
            q.remove(u)
            if dist[u] == inf or u == dest:
                break
            for v, cost in neighbours[u]:
                alt = dist[u] + cost
                if alt < dist[v]:                                  # Relax (u,v,a)
                    dist[v] = alt
                    previous[v] = u
        #pp(previous)
        s, u = deque(), dest
        while previous[u]:
            s.appendleft(u)
            u = previous[u]
        s.appendleft(u)
        return s
 
 
graph = Graph([(""a"", ""b"", 7),  (""a"", ""c"", 9),  (""a"", ""f"", 14), (""b"", ""c"", 10),
               (""b"", ""d"", 15), (""c"", ""d"", 11), (""c"", ""f"", 2),  (""d"", ""e"", 6),
               (""e"", ""f"", 9)])
pp(graph.dijkstra(""a"", ""e""))"
h8uz,python,Dinesman's multiple-dwelling problem,Puzzles and Games,Logic and Mathematical Puzzles,"import re
from itertools import product
 
problem_re = re.compile(r""""""(?msx)(?:
 
# Multiple names of form n1, n2, n3, ... , and nK
(?P<namelist> [a-zA-Z]+ (?: , \s+ [a-zA-Z]+)* (?: ,? \s+ and) \s+ [a-zA-Z]+ )
 
# Flexible floor count (2 to 10 floors)
| (?:  .* house \s+ that \s+ contains \s+ only \s+
  (?P<floorcount> two|three|four|five|six|seven|eight|nine|ten ) \s+ floors \s* \.)
 
# Constraint: ""does not live on the n'th floor"" 
|(?: (?P<not_live>  \b [a-zA-Z]+ \s+ does \s+ not \s+ live \s+ on \s+ the \s+
  (?: top|bottom|first|second|third|fourth|fifth|sixth|seventh|eighth|ninth|tenth) \s+ floor \s* \. ))
 
# Constraint: ""does not live on either the I'th or the J'th [ or the K'th ...] floor
|(?P<not_either> \b [a-zA-Z]+ \s+ does \s+ not \s+ live \s+ on \s+ either
  (?: \s+ (?: or \s+)? the \s+       
    (?: top|bottom|first|second|third|fourth|fifth|sixth|seventh|eighth|ninth|tenth))+ \s+ floor \s* \. )
 
# Constraint: ""P1 lives on a higher/lower floor than P2 does""
|(?P<hi_lower> \b  [a-zA-Z]+ \s+ lives \s+ on \s+ a \s (?: higher|lower)
   \s+ floor \s+ than (?: \s+ does)  \s+  [a-zA-Z]+ \s* \. )
 
# Constraint: ""P1 does/does not live on a floor adjacent to P2's""
|(?P<adjacency>  \b [a-zA-Z]+ \s+ does (?:\s+ not)? \s+ live \s+ on \s+ a \s+
   floor \s+ adjacent \s+ to \s+  [a-zA-Z]+ (?: 's )? \s* \. )
 
# Ask for the solution
|(?P<question> Where \s+ does \s+ everyone \s+ live \s* \?)
 
)
"""""")
 
names, lennames = None, None
floors = None
constraint_expr = 'len(set(alloc)) == lennames' # Start with all people on different floors
 
def do_namelist(txt):
    "" E.g. 'Baker, Cooper, Fletcher, Miller, and Smith'""
    global names, lennames
    names = txt.replace(' and ', ' ').split(', ')
    lennames = len(names)
 
def do_floorcount(txt):
    "" E.g. 'five'""
    global floors
    floors = '||two|three|four|five|six|seven|eight|nine|ten'.split('|').index(txt)
 
def do_not_live(txt):
    "" E.g. 'Baker does not live on the top floor.'""
    global constraint_expr
    t = txt.strip().split()
    who, floor = t[0], t[-2]
    w, f = (names.index(who),
            ('|first|second|third|fourth|fifth|sixth|' +
             'seventh|eighth|ninth|tenth|top|bottom|').split('|').index(floor)
            )
    if f == 11: f = floors
    if f == 12: f = 1
    constraint_expr += ' and alloc[%i] != %i' % (w, f)
 
def do_not_either(txt):
    "" E.g. 'Fletcher does not live on either the top or the bottom floor.'""
    global constraint_expr
    t = txt.replace(' or ', ' ').replace(' the ', ' ').strip().split()
    who, floor = t[0], t[6:-1]
    w, fl = (names.index(who),
             [('|first|second|third|fourth|fifth|sixth|' +
               'seventh|eighth|ninth|tenth|top|bottom|').split('|').index(f)
              for f in floor]
             )
    for f in fl:
        if f == 11: f = floors
        if f == 12: f = 1
        constraint_expr += ' and alloc[%i] != %i' % (w, f)
 
 
def do_hi_lower(txt):
    "" E.g. 'Miller lives on a higher floor than does Cooper.'""
    global constraint_expr
    t = txt.replace('.', '').strip().split()
    name_indices = [names.index(who) for who in (t[0], t[-1])]
    if 'lower' in t:
        name_indices = name_indices[::-1]
    constraint_expr += ' and alloc[%i] > alloc[%i]' % tuple(name_indices)
 
def do_adjacency(txt):
    ''' E.g. ""Smith does not live on a floor adjacent to Fletcher's.""'''
    global constraint_expr
    t = txt.replace('.', '').replace(""'s"", '').strip().split()
    name_indices = [names.index(who) for who in (t[0], t[-1])]
    constraint_expr += ' and abs(alloc[%i] - alloc[%i]) > 1' % tuple(name_indices)
 
def do_question(txt):
    global constraint_expr, names, lennames
 
    exec_txt = '''
for alloc in product(range(1,floors+1), repeat=len(names)):
    if %s:
        break
else:
    alloc = None
''' % constraint_expr
    exec(exec_txt, globals(), locals())
    a = locals()['alloc']
    if a:
        output= ['Floors are numbered from 1 to %i inclusive.' % floors]
        for a2n in zip(a, names):
            output += ['  Floor %i is occupied by %s' % a2n]
        output.sort(reverse=True)
        print('\n'.join(output))
    else:
        print('No solution found.')
    print()
 
handler = {
    'namelist': do_namelist,
    'floorcount': do_floorcount,
    'not_live': do_not_live,
    'not_either': do_not_either,
    'hi_lower': do_hi_lower,
    'adjacency': do_adjacency,
    'question': do_question,
    }
def parse_and_solve(problem):
    p = re.sub(r'\s+', ' ', problem).strip()
    for x in problem_re.finditer(p):
        groupname, txt = [(k,v) for k,v in x.groupdict().items() if v][0]
        #print (""%r, %r"" % (groupname, txt))
        handler[groupname](txt)"
djpl,python,Dining philosophers,Concurrency and Parallelism,Multithreading and Thread Management,"import threading
import random
import time
 
# Dining philosophers, 5 Phillies with 5 forks. Must have two forks to eat.
#
# Deadlock is avoided by never waiting for a fork while holding a fork (locked)
# Procedure is to do block while waiting to get first fork, and a nonblocking
# acquire of second fork.  If failed to get second fork, release first fork,
# swap which fork is first and which is second and retry until getting both.
#  
# See discussion page note about 'live lock'.
 
class Philosopher(threading.Thread):
 
    running = True
 
    def __init__(self, xname, forkOnLeft, forkOnRight):
        threading.Thread.__init__(self)
        self.name = xname
        self.forkOnLeft = forkOnLeft
        self.forkOnRight = forkOnRight
 
    def run(self):
        while(self.running):
            #  Philosopher is thinking (but really is sleeping).
            time.sleep( random.uniform(3,13))
            print '%s is hungry.' % self.name
            self.dine()
 
    def dine(self):
        fork1, fork2 = self.forkOnLeft, self.forkOnRight
 
        while self.running:
            fork1.acquire(True)
            locked = fork2.acquire(False)
            if locked: break
            fork1.release()
            print '%s swaps forks' % self.name
            fork1, fork2 = fork2, fork1
        else:
            return
 
        self.dining()
        fork2.release()
        fork1.release()
 
    def dining(self):			
        print '%s starts eating '% self.name
        time.sleep(random.uniform(1,10))
        print '%s finishes eating and leaves to think.' % self.name
 
def DiningPhilosophers():
    forks = [threading.Lock() for n in range(5)]
    philosopherNames = ('Aristotle','Kant','Spinoza','Marx', 'Russel')
 
    philosophers= [Philosopher(philosopherNames[i], forks[i%5], forks[(i+1)%5]) \
            for i in range(5)]
 
    random.seed(507129)
    Philosopher.running = True
    for p in philosophers: p.start()
    time.sleep(100)
    Philosopher.running = False
    print (""Now we're finishing."")
 
DiningPhilosophers()"
6gxp,python,Disarium numbers,Mathematics,Number Theory,"#!/usr/bin/python
 
def isDisarium(n):
    digitos = len(str(n))
    suma = 0
    x = n
    while x != 0:
        suma += (x % 10) ** digitos
        digitos -= 1
        x //= 10
    if suma == n:
        return True
    else:
        return False
 
if __name__ == '__main__':
    limite = 19
    cont = 0
    n = 0
    print(""The first"",limite,""Disarium numbers are:"")
    while cont < limite:
        if isDisarium(n):
            print(n, end = "" "")
            cont += 1
        n += 1"
thny,python,Discordian date,Mathematics,Calendar Systems,"import datetime, calendar
 
DISCORDIAN_SEASONS = [""Chaos"", ""Discord"", ""Confusion"", ""Bureaucracy"", ""The Aftermath""]
 
def ddate(year, month, day):
    today = datetime.date(year, month, day)
    is_leap_year = calendar.isleap(year)
    if is_leap_year and month == 2 and day == 29:
        return ""St. Tib's Day, YOLD "" + (year + 1166)
 
    day_of_year = today.timetuple().tm_yday - 1
 
    if is_leap_year and day_of_year >= 60:
        day_of_year -= 1 # Compensate for St. Tib's Day
 
    season, dday = divmod(day_of_year, 73)
    return ""%s %d, YOLD %d"" % (DISCORDIAN_SEASONS[season], dday + 1, year + 1166)
 "
fq0p,python,Display a linear combination,Mathematics,Algebra and Arithmetic," 
def linear(x):
    return ' + '.join(['{}e({})'.format('-' if v == -1 else '' if v == 1 else str(v) + '*', i + 1)
        for i, v in enumerate(x) if v] or ['0']).replace(' + -', ' - ')
 
list(map(lambda x: print(linear(x)), [[1, 2, 3], [0, 1, 2, 3], [1, 0, 3, 4], [1, 2, 0],
        [0, 0, 0], [0], [1, 1, 1], [-1, -1, -1], [-1, -2, 0, 3], [-1]]))
 "
fh0x,python,Display an outline as a nested table,Puzzles and Games,Puzzle Solving Algorithms,"""""""Display an outline as a nested table. Requires Python >=3.6.""""""
 
import itertools
import re
import sys
 
from collections import deque
from typing import NamedTuple
 
 
RE_OUTLINE = re.compile(r""^((?: |\t)*)(.+)$"", re.M)
 
COLORS = itertools.cycle(
    [
        ""#ffffe6"",
        ""#ffebd2"",
        ""#f0fff0"",
        ""#e6ffff"",
        ""#ffeeff"",
    ]
)
 
 
class Node:
    def __init__(self, indent, value, parent, children=None):
        self.indent = indent
        self.value = value
        self.parent = parent
        self.children = children or []
 
        self.color = None
 
    def depth(self):
        if self.parent:
            return self.parent.depth() + 1
        return -1
 
    def height(self):
        """"""Height of the subtree rooted at this node.""""""
        if not self.children:
            return 0
        return max(child.height() for child in self.children) + 1
 
    def colspan(self):
        if self.leaf:
            return 1
        return sum(child.colspan() for child in self.children)
 
    @property
    def leaf(self):
        return not bool(self.children)
 
    def __iter__(self):
        # Level order tree traversal.
        q = deque()
        q.append(self)
        while q:
            node = q.popleft()
            yield node
            q.extend(node.children)
 
 
class Token(NamedTuple):
    indent: int
    value: str
 
 
def tokenize(outline):
    """"""Generate ``Token``s from the given outline.""""""
    for match in RE_OUTLINE.finditer(outline):
        indent, value = match.groups()
        yield Token(len(indent), value)
 
 
def parse(outline):
    """"""Return the given outline as a tree of ``Node``s.""""""
    # Split the outline into lines and count the level of indentation.
    tokens = list(tokenize(outline))
 
    # Parse the tokens into a tree of nodes.
    temp_root = Node(-1, """", None)
    _parse(tokens, 0, temp_root)
 
    # Pad the tree so that all branches have the same depth.
    root = temp_root.children[0]
    pad_tree(root, root.height())
 
    return root
 
 
def _parse(tokens, index, node):
    """"""Recursively build a tree of nodes.
 
    Args:
        tokens (list): A collection of ``Token``s.
        index (int): Index of the current token.
        node (Node): Potential parent or sibling node.
    """"""
    # Base case. No more lines.
    if index >= len(tokens):
        return
 
    token = tokens[index]
 
    if token.indent == node.indent:
        # A sibling of node
        current = Node(token.indent, token.value, node.parent)
        node.parent.children.append(current)
        _parse(tokens, index + 1, current)
 
    elif token.indent > node.indent:
        # A child of node
        current = Node(token.indent, token.value, node)
        node.children.append(current)
        _parse(tokens, index + 1, current)
 
    elif token.indent < node.indent:
        # Try the node's parent until we find a sibling.
        _parse(tokens, index, node.parent)
 
 
def pad_tree(node, height):
    """"""Pad the tree with blank nodes so all branches have the same depth.""""""
    if node.leaf and node.depth() < height:
        pad_node = Node(node.indent + 1, """", node)
        node.children.append(pad_node)
 
    for child in node.children:
        pad_tree(child, height)
 
 
def color_tree(node):
    """"""Walk the tree and color each node as we go.""""""
    if not node.value:
        node.color = ""#F9F9F9""
    elif node.depth() <= 1:
        node.color = next(COLORS)
    else:
        node.color = node.parent.color
 
    for child in node.children:
        color_tree(child)
 
 
def table_data(node):
    """"""Return an HTML table data element for the given node.""""""
    indent = ""    ""
 
    if node.colspan() > 1:
        colspan = f'colspan=""{node.colspan()}""'
    else:
        colspan = """"
 
    if node.color:
        style = f'style=""background-color: {node.color};""'
    else:
        style = """"
 
    attrs = "" "".join([colspan, style])
    return f""{indent}<td{attrs}>{node.value}</td>""
 
 
def html_table(tree):
    """"""Return the tree as an HTML table.""""""
    # Number of columns in the table.
    table_cols = tree.colspan()
 
    # Running count of columns in the current row.
    row_cols = 0
 
    # HTML buffer
    buf = [""<table style='text-align: center;'>""]
 
    # Breadth first iteration.
    for node in tree:
        if row_cols == 0:
            buf.append(""  <tr>"")
 
        buf.append(table_data(node))
        row_cols += node.colspan()
 
        if row_cols == table_cols:
            buf.append(""  </tr>"")
            row_cols = 0
 
    buf.append(""</table>"")
    return ""\n"".join(buf)
 
 
def wiki_table_data(node):
    """"""Return an wiki table data string for the given node.""""""
    if not node.value:
        return ""|  |""
 
    if node.colspan() > 1:
        colspan = f""colspan={node.colspan()}""
    else:
        colspan = """"
 
    if node.color:
        style = f'style=""background: {node.color};""'
    else:
        style = """"
 
    attrs = "" "".join([colspan, style])
    return f""| {attrs} | {node.value}""
 
 
def wiki_table(tree):
    """"""Return the tree as a wiki table.""""""
    # Number of columns in the table.
    table_cols = tree.colspan()
 
    # Running count of columns in the current row.
    row_cols = 0
 
    # HTML buffer
    buf = ['{| class=""wikitable"" style=""text-align: center;""']
 
    for node in tree:
        if row_cols == 0:
            buf.append(""|-"")
 
        buf.append(wiki_table_data(node))
        row_cols += node.colspan()
 
        if row_cols == table_cols:
            row_cols = 0
 
    buf.append(""|}"")
    return ""\n"".join(buf)
 
 
def example(table_format=""wiki""):
    """"""Write an example table to stdout in either HTML or Wiki format.""""""
 
    outline = (
        ""Display an outline as a nested table.\n""
        ""    Parse the outline to a tree,\n""
        ""        measuring the indent of each line,\n""
        ""        translating the indentation to a nested structure,\n""
        ""        and padding the tree to even depth.\n""
        ""    count the leaves descending from each node,\n""
        ""        defining the width of a leaf as 1,\n""
        ""        and the width of a parent node as a sum.\n""
        ""            (The sum of the widths of its children)\n""
        ""    and write out a table with 'colspan' values\n""
        ""        either as a wiki table,\n""
        ""        or as HTML.""
    )
 
    tree = parse(outline)
    color_tree(tree)
 
    if table_format == ""wiki"":
        print(wiki_table(tree))
    else:
        print(html_table(tree))
 
 
if __name__ == ""__main__"":
    args = sys.argv[1:]
 
    if len(args) == 1:
        table_format = args[0]
    else:
        table_format = ""wiki""
 
    example(table_format)"
3ti0,python,Distributed programming,Networking and Web Development,Networking,"#!/usr/bin/env python
# -*- coding: utf-8 -*-
 
import SimpleXMLRPCServer
 
class MyHandlerInstance:
    def echo(self, data):
        '''Method for returning data got from client'''
        return 'Server responded: %s' % data
 
    def div(self, num1, num2):
        '''Method for divide 2 numbers'''
        return num1/num2
 
def foo_function():
    '''A function (not an instance method)'''
    return True
 
HOST = ""localhost""
PORT = 8000
 
server = SimpleXMLRPCServer.SimpleXMLRPCServer((HOST, PORT))
 
# register built-in system.* functions.
server.register_introspection_functions()
 
# register our instance
server.register_instance(MyHandlerInstance())
 
# register our function as well
server.register_function(foo_function)
 
try:
    # serve forever
    server.serve_forever()
except KeyboardInterrupt:
    print 'Exiting...'
    server.server_close()"
5irf,python,Diversity prediction theorem,Mathematics,Probability and Statistics,"'''Diversity prediction theorem'''
 
from itertools import chain
from functools import reduce
 
 
#  diversityValues :: Num a => a -> [a] ->
#  { mean-Error :: a, crowd-error :: a, diversity :: a }
def diversityValues(x):
    '''The mean error, crowd error and
       diversity, for a given observation x
       and a non-empty list of predictions ps.
    '''
    def go(ps):
        mp = mean(ps)
        return {
            'mean-error': meanErrorSquared(x)(ps),
            'crowd-error': pow(x - mp, 2),
            'diversity': meanErrorSquared(mp)(ps)
        }
    return go
 
 
# meanErrorSquared :: Num -> [Num] -> Num
def meanErrorSquared(x):
    '''The mean of the squared differences
       between the observed value x and
       a non-empty list of predictions ps.
    '''
    def go(ps):
        return mean([
            pow(p - x, 2) for p in ps
        ])
    return go
 
 
# ------------------------- TEST -------------------------
# main :: IO ()
def main():
    '''Observed value: 49,
       prediction lists: various.
    '''
 
    print(unlines(map(
        showDiversityValues(49),
        [
            [48, 47, 51],
            [48, 47, 51, 42],
            [50, '?', 50, {}, 50],  # Non-numeric values.
            []                      # Missing predictions.
        ]
    )))
    print(unlines(map(
        showDiversityValues('49'),  # String in place of number.
        [
            [50, 50, 50],
            [40, 35, 40],
        ]
    )))
 
 
# ---------------------- FORMATTING ----------------------
 
# showDiversityValues :: Num -> [Num] -> Either String String
def showDiversityValues(x):
    '''Formatted string representation
       of diversity values for a given
       observation x and a non-empty
       list of predictions p.
    '''
    def go(ps):
        def showDict(dct):
            w = 4 + max(map(len, dct.keys()))
 
            def showKV(a, kv):
                k, v = kv
                return a + k.rjust(w, ' ') + (
                    ' : ' + showPrecision(3)(v) + '\n'
                )
            return 'Predictions: ' + showList(ps) + ' ->\n' + (
                reduce(showKV, dct.items(), '')
            )
 
        def showProblem(e):
            return (
                unlines(map(indented(1), e)) if (
                    isinstance(e, list)
                ) else indented(1)(repr(e))
            ) + '\n'
 
        return 'Observation:  ' + repr(x) + '\n' + (
            either(showProblem)(showDict)(
                bindLR(numLR(x))(
                    lambda n: bindLR(numsLR(ps))(
                        compose(Right, diversityValues(n))
                    )
                )
            )
        )
    return go
 
 
# ------------------ GENERIC FUNCTIONS -------------------
 
# Left :: a -> Either a b
def Left(x):
    '''Constructor for an empty Either (option type) value
       with an associated string.
    '''
    return {'type': 'Either', 'Right': None, 'Left': x}
 
 
# Right :: b -> Either a b
def Right(x):
    '''Constructor for a populated Either (option type) value'''
    return {'type': 'Either', 'Left': None, 'Right': x}
 
 
# bindLR (>>=) :: Either a -> (a -> Either b) -> Either b
def bindLR(m):
    '''Either monad injection operator.
       Two computations sequentially composed,
       with any value produced by the first
       passed as an argument to the second.
    '''
    def go(mf):
        return (
            mf(m.get('Right')) if None is m.get('Left') else m
        )
    return go
 
 
# compose :: ((a -> a), ...) -> (a -> a)
def compose(*fs):
    '''Composition, from right to left,
       of a series of functions.
    '''
    def go(f, g):
        def fg(x):
            return f(g(x))
        return fg
    return reduce(go, fs, identity)
 
 
# concatMap :: (a -> [b]) -> [a] -> [b]
def concatMap(f):
    '''A concatenated list over which a function has been mapped.
       The list monad can be derived by using a function f which
       wraps its output in a list,
       (using an empty list to represent computational failure).
    '''
    def go(xs):
        return chain.from_iterable(map(f, xs))
    return go
 
 
# either :: (a -> c) -> (b -> c) -> Either a b -> c
def either(fl):
    '''The application of fl to e if e is a Left value,
       or the application of fr to e if e is a Right value.
    '''
    return lambda fr: lambda e: fl(e['Left']) if (
        None is e['Right']
    ) else fr(e['Right'])
 
 
# identity :: a -> a
def identity(x):
    '''The identity function.'''
    return x
 
 
# indented :: Int -> String -> String
def indented(n):
    '''String indented by n multiples
       of four spaces.
    '''
    return lambda s: (4 * ' ' * n) + s
 
# mean :: [Num] -> Float
def mean(xs):
    '''Arithmetic mean of a list
       of numeric values.
    '''
    return sum(xs) / float(len(xs))
 
 
# numLR :: a -> Either String Num
def numLR(x):
    '''Either Right x if x is a float or int,
       or a Left explanatory message.'''
    return Right(x) if (
        isinstance(x, (float, int))
    ) else Left(
        'Expected number, saw: ' + (
            str(type(x)) + ' ' + repr(x)
        )
    )
 
 
# numsLR :: [a] -> Either String [Num]
def numsLR(xs):
    '''Either Right xs if all xs are float or int,
       or a Left explanatory message.'''
    def go(ns):
        ls, rs = partitionEithers(map(numLR, ns))
        return Left(ls) if ls else Right(rs)
    return bindLR(
        Right(xs) if (
            bool(xs) and isinstance(xs, list)
        ) else Left(
            'Expected a non-empty list, saw: ' + (
                str(type(xs)) + ' ' + repr(xs)
            )
        )
    )(go)
 
 
# partitionEithers :: [Either a b] -> ([a],[b])
def partitionEithers(lrs):
    '''A list of Either values partitioned into a tuple
       of two lists, with all Left elements extracted
       into the first list, and Right elements
       extracted into the second list.
    '''
    def go(a, x):
        ls, rs = a
        r = x.get('Right')
        return (ls + [x.get('Left')], rs) if None is r else (
            ls, rs + [r]
        )
    return reduce(go, lrs, ([], []))
 
 
# showList :: [a] -> String
def showList(xs):
    '''Compact string representation of a list'''
    return '[' + ','.join(str(x) for x in xs) + ']'
 
 
# showPrecision :: Int -> Float -> String
def showPrecision(n):
    '''A string showing a floating point number
       at a given degree of precision.'''
    def go(x):
        return str(round(x, n))
    return go
 
 
# unlines :: [String] -> String
def unlines(xs):
    '''A single string derived by the intercalation
       of a list of strings with the newline character.'''
    return '\n'.join(xs)
 
 
# MAIN ---
if __name__ == '__main__':
    main()"
q49y,python,Documentation,Software Engineering,Documentation Practices,"class Doc(object):
   """"""
   This is a class docstring. Traditionally triple-quoted strings are used because
   they can span multiple lines and you can include quotation marks without escaping.
   """"""
   def method(self, num):
      """"""This is a method docstring.""""""
      pass"
lys2,python,Dot product,Mathematics,Algebra and Arithmetic,"def dotp(a,b):
    assert len(a) == len(b), 'Vector sizes must match'
    return sum(aterm * bterm for aterm,bterm in zip(a, b))
 
if __name__ == '__main__':
    a, b = [1, 3, -5], [4, -2, -1]
    assert dotp(a,b) == 3"
z4dn,python,Doubly-linked list/Definition,Algorithms and Data Structures,Data Structures," 
from collections import deque
 
some_list = deque([""a"", ""b"", ""c""])
print(some_list)
 
some_list.appendleft(""Z"")
print(some_list)
 
for value in reversed(some_list):
    print(value)
 "
zp8m,python,Doubly-linked list/Element definition,Algorithms and Data Structures,Data Structures,"class Node(object):
     def __init__(self, data = None, prev = None, next = None):
         self.prev = prev
         self.next = next
         self.data = data
     def __str__(self):
         return str(self.data)
     def __repr__(self):
         return repr(self.data)
     def iter_forward(self):
         c = self
         while c != None:
             yield c
             c = c.next
     def iter_backward(self):
         c = self
         while c != None:
             yield c
             c = c.prev"
jjd3,python,Doubly-linked list/Element insertion,Algorithms and Data Structures,Data Structures,"def insert(anchor, new):
    new.next = anchor.next
    new.prev = anchor
    anchor.next.prev = new
    anchor.next = new"
c6w6,python,Doubly-linked list/Traversal,Algorithms and Data Structures,Data Structures,"class List:
    def __init__(self, data, next=None, prev=None):
        self.data = data
        self.next = next
        self.prev = prev
 
    def append(self, data):
        if self.next == None:
            self.next = List(data, None, self)
            return self.next
        else:
            return self.next.append(data)
 
# Build the list
tail = head = List(10)
for i in [ 20, 30, 40 ]:
    tail = tail.append(i)
 
# Traverse forwards
node = head
while node != None:
    print(node.data)
    node = node.next
 
# Traverse Backwards
node = tail
while node != None:
    print(node.data)
    node = node.prev"
enc2,python,Dragon curve,Puzzles and Games,Simulation and Modeling,"from turtle import *
 
def dragon(step, length):
    dcr(step, length)
 
def dcr(step, length):
    step -= 1
    length /= 1.41421
    if step > 0:
        right(45)
        dcr(step, length)
        left(90)
        dcl(step, length)
        right(45)
    else:
        right(45)
        forward(length)
        left(90)
        forward(length)
        right(45)
 
def dcl(step, length):
    step -= 1
    length /= 1.41421
 
    if step > 0:
        left(45)
        dcr(step, length)
        right(90)
        dcl(step, length)
        left(45)
    else:
        left(45)
        forward(length)
        right(90)
        forward(length)
        left(45)"
dmj4,python,Draw a clock,Graphics and Visualization,Graphics Programming,"import time
 
def chunks(l, n=5):
    return [l[i:i+n] for i in range(0, len(l), n)]
 
def binary(n, digits=8):
    n=int(n)
    return '{0:0{1}b}'.format(n, digits)
 
def secs(n):
    n=int(n)
    h='x' * n
    return ""|"".join(chunks(h))
 
def bin_bit(h):
    h=h.replace(""1"",""x"")
    h=h.replace(""0"","" "")
    return ""|"".join(list(h))
 
 
x=str(time.ctime()).split()
y=x[3].split("":"")
 
s=y[-1]
y=map(binary,y[:-1])
 
print bin_bit(y[0])
print
print bin_bit(y[1])
print
print secs(s)"
ffk8,python,Draw a cuboid,Graphics and Visualization,Graphics Programming,"def _pr(t, x, y, z):
    txt = '\n'.join(''.join(t[(n,m)] for n in range(3+x+z)).rstrip()
                    for m in reversed(range(3+y+z)))
    return txt
 
def cuboid(x,y,z):
    t = {(n,m):' ' for n in range(3+x+z) for m in range(3+y+z)}
    xrow = ['+'] + ['%i' % (i % 10) for i in range(x)] + ['+']
    for i,ch in enumerate(xrow):
        t[(i,0)] = t[(i,1+y)] = t[(1+z+i,2+y+z)] = ch
    if _debug: print(_pr(t, x, y, z))
    ycol = ['+'] + ['%i' % (j % 10) for j in range(y)] + ['+']
    for j,ch in enumerate(ycol):
        t[(0,j)] = t[(x+1,j)] = t[(2+x+z,1+z+j)] = ch
    zdepth = ['+'] + ['%i' % (k % 10) for k in range(z)] + ['+']
    if _debug: print(_pr(t, x, y, z))
    for k,ch in enumerate(zdepth):
        t[(k,1+y+k)] = t[(1+x+k,1+y+k)] = t[(1+x+k,k)] = ch
 
    return _pr(t, x, y, z)
 
 
_debug = False
if __name__ == '__main__':
    for dim in ((2,3,4), (3,4,2), (4,2,3)):
        print(""CUBOID%r"" % (dim,), cuboid(*dim), sep='\n')"
13cy,python,Draw a pixel,Graphics and Visualization,Graphics Programming,"from PIL import Image
 
img = Image.new('RGB', (320, 240))
pixels = img.load()
pixels[100,100] = (255,0,0)
img.show()
 "
07b9,python,Draw a rotating cube,Graphics and Visualization,Graphics Programming,"from visual import *
scene.title = ""VPython: Draw a rotating cube""
 
scene.range = 2
scene.autocenter = True
 
print ""Drag with right mousebutton to rotate view.""
print ""Drag up+down with middle mousebutton to zoom.""
 
deg45 = math.radians(45.0)  # 0.785398163397
 
cube = box()    # using defaults, see http://www.vpython.org/contents/docs/defaults.html 
cube.rotate( angle=deg45, axis=(1,0,0) )
cube.rotate( angle=deg45, axis=(0,0,1) )
 
while True:                 # Animation-loop
    rate(50)
    cube.rotate( angle=0.005, axis=(0,1,0) )
 "
j0iy,python,Draw a sphere,Graphics and Visualization,Graphics Programming,"import math
 
shades = ('.',':','!','*','o','e','&','#','%','@')
 
def normalize(v):
	len = math.sqrt(v[0]**2 + v[1]**2 + v[2]**2)
	return (v[0]/len, v[1]/len, v[2]/len)
 
def dot(x,y):
	d = x[0]*y[0] + x[1]*y[1] + x[2]*y[2]
	return -d if d < 0 else 0
 
def draw_sphere(r, k, ambient, light):
	for i in range(int(math.floor(-r)),int(math.ceil(r)+1)):
		x = i + 0.5
		line = ''
 
		for j in range(int(math.floor(-2*r)),int(math.ceil(2*r)+1)):
			y = j/2 + 0.5
			if x*x + y*y <= r*r:
				vec = normalize((x,y,math.sqrt(r*r - x*x - y*y)))
				b = dot(light,vec)**k + ambient
				intensity = int((1-b)*(len(shades)-1))
				line += shades[intensity] if 0 <= intensity < len(shades) else shades[0]
			else:
				line += ' '
 
		print(line)
 
light = normalize((30,30,-50))
draw_sphere(20,4,0.1, light)
draw_sphere(10,2,0.4, light)"
z9cc,python,Dutch national flag problem,Algorithms and Data Structures,Algorithms,"import random
 
colours_in_order = 'Red White Blue'.split()
 
def dutch_flag_sort(items, order=colours_in_order):
    'return sort of items using the given order'
    reverse_index = dict((x,i) for i,x in enumerate(order))
    return sorted(items, key=lambda x: reverse_index[x])
 
def dutch_flag_check(items, order=colours_in_order):
    'Return True if each item of items is in the given order'
    reverse_index = dict((x,i) for i,x in enumerate(order))
    order_of_items = [reverse_index[item] for item in items]
    return all(x <= y for x, y in zip(order_of_items, order_of_items[1:]))
 
def random_balls(mx=5):
    'Select from 1 to mx balls of each colour, randomly'
    balls = sum([[colour] * random.randint(1, mx)
                 for colour in colours_in_order], [])
    random.shuffle(balls)
    return balls
 
def main():
    # Ensure we start unsorted
    while True:
        balls = random_balls()
        if not dutch_flag_check(balls):
            break
    print(""Original Ball order:"", balls)
    sorted_balls = dutch_flag_sort(balls)
    print(""Sorted Ball Order:"", sorted_balls)
    assert dutch_flag_check(sorted_balls), 'Whoops. Not sorted!'
 
if __name__ == '__main__':
    main()"
qisl,python,Dynamic variable names,Programming Concepts,Fundamentals,">>> name = raw_input(""Enter a variable name: "")
Enter a variable name: X
>>> globals()[name] = 42
>>> X
42"
fk70,python,EKG sequence convergence,Mathematics,Number Theory,"from itertools import count, islice, takewhile
from math import gcd
 
def EKG_gen(start=2):
    """"""\
    Generate the next term of the EKG together with the minimum cache of 
    numbers left in its production; (the ""state"" of the generator).
    Using math.gcd
    """"""
    c = count(start + 1)
    last, so_far = start, list(range(2, start))
    yield 1, []
    yield last, []
    while True:
        for index, sf in enumerate(so_far):
            if gcd(last, sf) > 1:
                last = so_far.pop(index)
                yield last, so_far[::]
                break
        else:
            so_far.append(next(c))
 
def find_convergence(ekgs=(5,7)):
    ""Returns the convergence point or zero if not found within the limit""
    ekg = [EKG_gen(n) for n in ekgs]
    for e in ekg:
        next(e)    # skip initial 1 in each sequence
    return 2 + len(list(takewhile(lambda state: not all(state[0] == s for  s in state[1:]),
                                  zip(*ekg))))
 
if __name__ == '__main__':
    for start in 2, 5, 7, 9, 10:
        print(f""EKG({start}):"", str([n[0] for n in islice(EKG_gen(start), 10)])[1: -1])
    print(f""\nEKG(5) and EKG(7) converge at term {find_convergence(ekgs=(5,7))}!"")"
qrcl,python,Earliest difference between prime gaps,Mathematics,Number Theory,""""""" https://rosettacode.org/wiki/Earliest_difference_between_prime_gaps """"""
 
from primesieve import primes
 
LIMIT = 10**9
pri = primes(LIMIT * 5)
gapstarts = {}
for i in range(1, len(pri)):
    if pri[i] - pri[i - 1] not in gapstarts:
        gapstarts[pri[i] - pri[i - 1]] = pri[i - 1]
 
PM, GAP1, = 10, 2
while True:
    while GAP1 not in gapstarts:
        GAP1 += 2
    start1 = gapstarts[GAP1]
    GAP2 = GAP1 + 2
    if GAP2 not in gapstarts:
        GAP1 = GAP2 + 2
        continue
    start2 = gapstarts[GAP2]
    diff = abs(start2 - start1)
    if diff > PM:
        print(f""Earliest difference >{PM: ,} between adjacent prime gap starting primes:"")
        print(f""Gap {GAP1} starts at{start1: ,}, gap {GAP2} starts at{start2: ,}, difference is{diff: ,}.\n"")
        if PM == LIMIT:
            break
        PM *= 10
    else:
        GAP1 = GAP2
 "
tngf,python,Eban numbers,Mathematics,Combinatorics," 
# Use inflect
 
""""""
 
  show all eban numbers <= 1,000 (in a horizontal format), and a count
  show all eban numbers between 1,000 and 4,000 (inclusive), and a count
  show a count of all eban numbers up and including 10,000
  show a count of all eban numbers up and including 100,000
  show a count of all eban numbers up and including 1,000,000
  show a count of all eban numbers up and including 10,000,000
 
""""""
 
import inflect
import time
 
before = time.perf_counter()
 
p = inflect.engine()
 
# eban numbers <= 1000
 
print(' ')
print('eban numbers up to and including 1000:')
print(' ')
 
count = 0
 
for i in range(1,1001):
    if not 'e' in p.number_to_words(i):
        print(str(i)+' ',end='')
        count += 1
 
print(' ')
print(' ')
print('count = '+str(count))
print(' ')
 
# eban numbers 1000 to 4000
 
print(' ')
print('eban numbers between 1000 and 4000 (inclusive):')
print(' ')
 
count = 0
 
for i in range(1000,4001):
    if not 'e' in p.number_to_words(i):
        print(str(i)+' ',end='')
        count += 1
 
print(' ')
print(' ')
print('count = '+str(count))
print(' ')
 
# eban numbers up to 10000
 
print(' ')
print('eban numbers up to and including 10000:')
print(' ')
 
count = 0
 
for i in range(1,10001):
    if not 'e' in p.number_to_words(i):
        count += 1
 
print(' ')
print('count = '+str(count))
print(' ')
 
# eban numbers up to 100000
 
print(' ')
print('eban numbers up to and including 100000:')
print(' ')
 
count = 0
 
for i in range(1,100001):
    if not 'e' in p.number_to_words(i):
        count += 1
 
print(' ')
print('count = '+str(count))
print(' ')
 
# eban numbers up to 1000000
 
print(' ')
print('eban numbers up to and including 1000000:')
print(' ')
 
count = 0
 
for i in range(1,1000001):
    if not 'e' in p.number_to_words(i):
        count += 1
 
print(' ')
print('count = '+str(count))
print(' ')
 
# eban numbers up to 10000000
 
print(' ')
print('eban numbers up to and including 10000000:')
print(' ')
 
count = 0
 
for i in range(1,10000001):
    if not 'e' in p.number_to_words(i):
        count += 1
 
print(' ')
print('count = '+str(count))
print(' ')
 
after = time.perf_counter()
 
print("" "")
print(""Run time in seconds: ""+str(after - before))
 "
ie9v,python,Echo server,Networking and Web Development,Networking,"import SocketServer
 
HOST = ""localhost""
PORT = 12321
 
# this server uses ThreadingMixIn - one thread per connection
# replace with ForkMixIn to spawn a new process per connection
 
class EchoServer(SocketServer.ThreadingMixIn, SocketServer.TCPServer):
    # no need to override anything - default behavior is just fine
    pass
 
class EchoRequestHandler(SocketServer.StreamRequestHandler):
    """"""
    Handles one connection to the client.
    """"""
    def handle(self):
        print ""connection from %s"" % self.client_address[0]
        while True:
            line = self.rfile.readline()
            if not line: break
            print ""%s wrote: %s"" % (self.client_address[0], line.rstrip())
            self.wfile.write(line)
        print ""%s disconnected"" % self.client_address[0]
 
 
# Create the server
server = EchoServer((HOST, PORT), EchoRequestHandler)
 
# Activate the server; this will keep running until you
# interrupt the program with Ctrl-C
print ""server listening on %s:%s"" % server.server_address
server.serve_forever()"
dbl0,python,Eertree,Algorithms and Data Structures,Data Structures,"#!/bin/python
from __future__ import print_function
 
class Node(object):
	def __init__(self):
		self.edges = {} # edges (or forward links)
		self.link = None # suffix link (backward links)
		self.len = 0 # the length of the node
 
class Eertree(object):
	def __init__(self):
		self.nodes = []
		# two initial root nodes
		self.rto = Node() #odd length root node, or node -1
		self.rte = Node() #even length root node, or node 0
 
		# Initialize empty tree
		self.rto.link = self.rte.link = self.rto;
		self.rto.len = -1
		self.rte.len = 0
		self.S = [0] # accumulated input string, T=S[1..i]
		self.maxSufT = self.rte # maximum suffix of tree T
 
	def get_max_suffix_pal(self, startNode, a):
		# We traverse the suffix-palindromes of T in the order of decreasing length.
		# For each palindrome we read its length k and compare T[i-k] against a
		# until we get an equality or arrive at the -1 node.
		u = startNode
		i = len(self.S)
		k = u.len
		while id(u) != id(self.rto) and self.S[i - k - 1] != a:
			assert id(u) != id(u.link) #Prevent infinte loop
			u = u.link
			k = u.len
 
		return u
 
	def add(self, a):
 
		# We need to find the maximum suffix-palindrome P of Ta
		# Start by finding maximum suffix-palindrome Q of T.
		# To do this, we traverse the suffix-palindromes of T
		# in the order of decreasing length, starting with maxSuf(T)
		Q = self.get_max_suffix_pal(self.maxSufT, a)
 
		# We check Q to see whether it has an outgoing edge labeled by a.
		createANewNode = not a in Q.edges
 
		if createANewNode:
			# We create the node P of length Q+2
			P = Node()
			self.nodes.append(P)
			P.len = Q.len + 2
			if P.len == 1:
				# if P = a, create the suffix link (P,0)
				P.link = self.rte
			else:
				# It remains to create the suffix link from P if |P|>1. Just
				# continue traversing suffix-palindromes of T starting with the suffix 
				# link of Q.
				P.link = self.get_max_suffix_pal(Q.link, a).edges[a]
 
			# create the edge (Q,P)
			Q.edges[a] = P
 
		#P becomes the new maxSufT
		self.maxSufT = Q.edges[a]
 
		#Store accumulated input string
		self.S.append(a)
 
		return createANewNode
 
	def get_sub_palindromes(self, nd, nodesToHere, charsToHere, result):
		#Each node represents a palindrome, which can be reconstructed
		#by the path from the root node to each non-root node.
 
		#Traverse all edges, since they represent other palindromes
		for lnkName in nd.edges:
			nd2 = nd.edges[lnkName] #The lnkName is the character used for this edge
			self.get_sub_palindromes(nd2, nodesToHere+[nd2], charsToHere+[lnkName], result)
 
		#Reconstruct based on charsToHere characters.
		if id(nd) != id(self.rto) and id(nd) != id(self.rte): #Don't print for root nodes
			tmp = """".join(charsToHere)
			if id(nodesToHere[0]) == id(self.rte): #Even string
				assembled = tmp[::-1] + tmp
			else: #Odd string
				assembled = tmp[::-1] + tmp[1:]
			result.append(assembled)
 
if __name__==""__main__"":
	st = ""eertree""
	print (""Processing string"", st)
	eertree = Eertree()
	for ch in st:
		eertree.add(ch)
 
	print (""Number of sub-palindromes:"", len(eertree.nodes))
 
	#Traverse tree to find sub-palindromes
	result = []
	eertree.get_sub_palindromes(eertree.rto, [eertree.rto], [], result) #Odd length words
	eertree.get_sub_palindromes(eertree.rte, [eertree.rte], [], result) #Even length words
	print (""Sub-palindromes:"", result)"
rfkk,python,Egyptian division,Mathematics,Algebra and Arithmetic,"from itertools import product
 
def egyptian_divmod(dividend, divisor):
    assert divisor != 0
    pwrs, dbls = [1], [divisor]
    while dbls[-1] <= dividend:
        pwrs.append(pwrs[-1] * 2)
        dbls.append(pwrs[-1] * divisor)
    ans, accum = 0, 0
    for pwr, dbl in zip(pwrs[-2::-1], dbls[-2::-1]):
        if accum + dbl <= dividend:
            accum += dbl
            ans += pwr
    return ans, abs(accum - dividend)
 
if __name__ == ""__main__"":
    # Test it gives the same results as the divmod built-in
    for i, j in product(range(13), range(1, 13)):
            assert egyptian_divmod(i, j) == divmod(i, j)
    # Mandated result
    i, j = 580, 34
    print(f'{i} divided by {j} using the Egyption method is %i remainder %i'
          % egyptian_divmod(i, j))"
axp9,python,Egyptian fractions,Mathematics,Number Theory,"from fractions import Fraction
from math import ceil
 
class Fr(Fraction):
    def __repr__(self):
        return '%s/%s' % (self.numerator, self.denominator)
 
def ef(fr):
    ans = []
    if fr >= 1:
        if fr.denominator == 1:
            return [[int(fr)], Fr(0, 1)]
        intfr = int(fr)
        ans, fr = [[intfr]], fr - intfr
    x, y = fr.numerator, fr.denominator
    while x != 1:
        ans.append(Fr(1, ceil(1/fr)))
        fr = Fr(-y % x, y* ceil(1/fr))
        x, y = fr.numerator, fr.denominator
    ans.append(fr)
    return ans
 
if __name__ == '__main__':
    for fr in [Fr(43, 48), Fr(5, 121), Fr(2014, 59)]:
        print('%r ─► %s' % (fr, ' '.join(str(x) for x in ef(fr))))
    lenmax = denommax = (0, None) 
    for fr in set(Fr(a, b) for a in range(1,100) for b in range(1, 100)):
        e = ef(fr)
        #assert sum((f[0] if type(f) is list else f) for f in e) == fr, 'Whoops!'
        elen, edenom = len(e), e[-1].denominator
        if elen > lenmax[0]:
            lenmax = (elen, fr, e)
        if edenom > denommax[0]:
            denommax = (edenom, fr, e)
    print('Term max is %r with %i terms' % (lenmax[1], lenmax[0]))
    dstr = str(denommax[0])
    print('Denominator max is %r with %i digits %s...%s' %
          (denommax[1], len(dstr), dstr[:5], dstr[-5:]))"
c1l5,python,Element-wise operations,Algorithms and Data Structures,Algorithms,">>> import random
>>> from operator import add, sub, mul, floordiv
>>> from pprint import pprint as pp
>>> 
>>> def ewise(matrix1, matrix2, op):
	return [[op(e1,e2) for e1,e2 in zip(row1, row2)] for row1,row2 in zip(matrix1, matrix2)]
 
>>> m,n = 3,4 	# array dimensions
>>> a0 = [[random.randint(1,9) for y in range(n)] for x in range(m)]
>>> a1 = [[random.randint(1,9) for y in range(n)] for x in range(m)]
>>> pp(a0); pp(a1)
[[7, 8, 7, 4], [4, 9, 4, 1], [2, 3, 6, 4]]
[[4, 5, 1, 6], [6, 8, 3, 4], [2, 2, 6, 3]]
>>> pp(ewise(a0, a1, add))
[[11, 13, 8, 10], [10, 17, 7, 5], [4, 5, 12, 7]]
>>> pp(ewise(a0, a1, sub))
[[3, 3, 6, -2], [-2, 1, 1, -3], [0, 1, 0, 1]]
>>> pp(ewise(a0, a1, mul))
[[28, 40, 7, 24], [24, 72, 12, 4], [4, 6, 36, 12]]
>>> pp(ewise(a0, a1, floordiv))
[[1, 1, 7, 0], [0, 1, 1, 0], [1, 1, 1, 1]]
>>> pp(ewise(a0, a1, pow))
[[2401, 32768, 7, 4096], [4096, 43046721, 64, 1], [4, 9, 46656, 64]]
>>> pp(ewise(a0, a1, lambda x, y:2*x - y))
[[10, 11, 13, 2], [2, 10, 5, -2], [2, 4, 6, 5]]
>>> 
>>> def s_ewise(scalar1, matrix1, op):
	return [[op(scalar1, e1) for e1 in row1] for row1 in matrix1]
 
>>> scalar = 10
>>> a0
[[7, 8, 7, 4], [4, 9, 4, 1], [2, 3, 6, 4]]
>>> for op in ( add, sub, mul, floordiv, pow, lambda x, y:2*x - y ):
	print(""%10s :"" % op.__name__, s_ewise(scalar, a0, op))
 
 
       add : [[17, 18, 17, 14], [14, 19, 14, 11], [12, 13, 16, 14]]
       sub : [[3, 2, 3, 6], [6, 1, 6, 9], [8, 7, 4, 6]]
       mul : [[70, 80, 70, 40], [40, 90, 40, 10], [20, 30, 60, 40]]
  floordiv : [[1, 1, 1, 2], [2, 1, 2, 10], [5, 3, 1, 2]]
       pow : [[10000000, 100000000, 10000000, 10000], [10000, 1000000000, 10000, 10], [100, 1000, 1000000, 10000]]
  <lambda> : [[13, 12, 13, 16], [16, 11, 16, 19], [18, 17, 14, 16]]
>>> "
ltin,python,Elementary cellular automaton,Puzzles and Games,Simulation and Modeling,"def eca(cells, rule):
    lencells = len(cells)
    c = ""0"" + cells + ""0""    # Zero pad the ends
    rulebits = '{0:08b}'.format(rule)
    neighbours2next = {'{0:03b}'.format(n):rulebits[::-1][n] for n in range(8)}
    yield c[1:-1]
    while True:
        c = ''.join(['0',
                     ''.join(neighbours2next[c[i-1:i+2]]
                             for i in range(1,lencells+1)),
                     '0'])
        yield c[1:-1]
 
if __name__ == '__main__':
    lines, start, rules = 50, '0000000001000000000', (90, 30, 122)
    zipped = [range(lines)] + [eca(start, rule) for rule in rules]
    print('\n   Rules: %r' % (rules,))
    for data in zip(*zipped):
        i = data[0]
        cells = data[1:]
        print('%2i: %s' % (i, '    '.join(cells).replace('0', '.').replace('1', '#')))"
x09n,python,Elementary cellular automaton/Infinite length,Artificial Intelligence and Machine Learning,Basic AI Concepts,"def _notcell(c):
    return '0' if c == '1' else '1'
 
def eca_infinite(cells, rule):
    lencells = len(cells)
    rulebits = '{0:08b}'.format(rule)
    neighbours2next = {'{0:03b}'.format(n):rulebits[::-1][n] for n in range(8)}
    c = cells
    while True:
        yield c
        c = _notcell(c[0])*2 + c + _notcell(c[-1])*2    # Extend and pad the ends
 
        c = ''.join(neighbours2next[c[i-1:i+2]] for i in range(1,len(c) - 1))
        #yield c[1:-1]
 
if __name__ == '__main__':
    lines = 25
    for rule in (90, 30):
        print('\nRule: %i' % rule)
        for i, c in zip(range(lines), eca_infinite('1', rule)):
            print('%2i: %s%s' % (i, ' '*(lines - i), c.replace('0', '.').replace('1', '#')))"
al59,python,Elementary cellular automaton/Random Number Generator,Puzzles and Games,Simulation and Modeling,"from elementary_cellular_automaton import eca, eca_wrap
 
def rule30bytes(lencells=100):
    cells = '1' + '0' * (lencells - 1)
    gen = eca(cells, 30)
    while True:
        yield int(''.join(next(gen)[0] for i in range(8)), 2)
 
if __name__ == '__main__':
    print([b for i,b in zip(range(10), rule30bytes())])"
18p9,python,Elliptic Curve Digital Signature Algorithm,Security and Cryptography,Cryptographic Techniques," 
from collections import namedtuple
from hashlib import sha256
from math import ceil, log
from random import randint
from typing import NamedTuple
 
# Bitcoin ECDSA curve
secp256k1_data = dict(
    p=0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F,  # Field characteristic
    a=0x0,  # Curve param a
    b=0x7,  # Curve param b
    r=0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141,  # Order n of basepoint G. Cofactor is 1 so it's ommited.
    Gx=0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798,  # Base point x
    Gy=0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8,  # Base point y
)
secp256k1 = namedtuple(""secp256k1"", secp256k1_data)(**secp256k1_data)
assert (secp256k1.Gy ** 2 - secp256k1.Gx ** 3 - 7) % secp256k1.p == 0
 
 
class CurveFP(NamedTuple):
    p: int  # Field characteristic
    a: int  # Curve param a
    b: int  # Curve param b
 
 
def extended_gcd(aa, bb):
    # https://rosettacode.org/wiki/Modular_inverse#Iteration_and_error-handling
    lastremainder, remainder = abs(aa), abs(bb)
    x, lastx, y, lasty = 0, 1, 1, 0
    while remainder:
        lastremainder, (quotient, remainder) = remainder, divmod(
            lastremainder, remainder
        )
        x, lastx = lastx - quotient * x, x
        y, lasty = lasty - quotient * y, y
    return lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1)
 
 
def modinv(a, m):
    # https://rosettacode.org/wiki/Modular_inverse#Iteration_and_error-handling
    g, x, _ = extended_gcd(a, m)
    if g != 1:
        raise ValueError
    return x % m
 
 
class PointEC(NamedTuple):
    curve: CurveFP
    x: int
    y: int
 
    @classmethod
    def build(cls, curve, x, y):
        x = x % curve.p
        y = y % curve.p
        rv = cls(curve, x, y)
        if not rv.is_identity():
            assert rv.in_curve()
        return rv
 
    def get_identity(self):
        return PointEC.build(self.curve, 0, 0)
 
    def copy(self):
        return PointEC.build(self.curve, self.x, self.y)
 
    def __neg__(self):
        return PointEC.build(self.curve, self.x, -self.y)
 
    def __sub__(self, Q):
        return self + (-Q)
 
    def __equals__(self, Q):
        # TODO: Assert same curve or implement logic for that.
        return self.x == Q.x and self.y == Q.y
 
    def is_identity(self):
        return self.x == 0 and self.y == 0
 
    def __add__(self, Q):
        # TODO: Assert same curve or implement logic for that.
        p = self.curve.p
        if self.is_identity():
            return Q.copy()
        if Q.is_identity():
            return self.copy()
        if Q.x == self.x and (Q.y == (-self.y % p)):
            return self.get_identity()
 
        if self != Q:
            l = ((Q.y - self.y) * modinv(Q.x - self.x, p)) % p
        else:
            # Point doubling.
            l = ((3 * self.x ** 2 + self.curve.a) * modinv(2 * self.y, p)) % p
        l = int(l)
 
        Rx = (l ** 2 - self.x - Q.x) % p
        Ry = (l * (self.x - Rx) - self.y) % p
        rv = PointEC.build(self.curve, Rx, Ry)
        return rv
 
    def in_curve(self):
        return ((self.y ** 2) % self.curve.p) == (
            (self.x ** 3 + self.curve.a * self.x + self.curve.b) % self.curve.p
        )
 
    def __mul__(self, s):
        # Naive method is exponential (due to invmod right?) so we use an alternative method:
        # https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication#Montgomery_ladder
        r0 = self.get_identity()
        r1 = self.copy()
        # pdbsas
        for i in range(ceil(log(s + 1, 2)) - 1, -1, -1):
            if ((s & (1 << i)) >> i) == 0:
                r1 = r0 + r1
                r0 = r0 + r0
            else:
                r0 = r0 + r1
                r1 = r1 + r1
        return r0
 
    def __rmul__(self, other):
        return self.__mul__(other)
 
 
class ECCSetup(NamedTuple):
    E: CurveFP
    G: PointEC
    r: int
 
 
secp256k1_curve = CurveFP(secp256k1.p, secp256k1.a, secp256k1.b)
secp256k1_basepoint = PointEC(secp256k1_curve, secp256k1.Gx, secp256k1.Gy)
 
 
class ECDSAPrivKey(NamedTuple):
    ecc_setup: ECCSetup
    secret: int
 
    def get_pubkey(self):
        # Compute W = sG to get the pubkey
        W = self.secret * self.ecc_setup.G
        pub = ECDSAPubKey(self.ecc_setup, W)
        return pub
 
 
class ECDSAPubKey(NamedTuple):
    ecc_setup: ECCSetup
    W: PointEC
 
 
class ECDSASignature(NamedTuple):
    c: int
    d: int
 
 
def generate_keypair(ecc_setup, s=None):
    # Select a random integer s in the interval [1, r - 1] for the secret.
    if s is None:
        s = randint(1, ecc_setup.r - 1)
    priv = ECDSAPrivKey(ecc_setup, s)
    pub = priv.get_pubkey()
    return priv, pub
 
 
def get_msg_hash(msg):
    return int.from_bytes(sha256(msg).digest(), ""big"")
 
 
def sign(priv, msg, u=None):
    G = priv.ecc_setup.G
    r = priv.ecc_setup.r
 
    # 1. Compute message representative f = H(m), using a cryptographic hash function.
    #    Note that f can be greater than r but not longer (measuring bits).
    msg_hash = get_msg_hash(msg)
 
    while True:
        # 2. Select a random integer u in the interval [1, r - 1].
        if u is None:
            u = randint(1, r - 1)
 
        # 3. Compute V = uG = (xV, yV) and c ≡ xV mod r  (goto (2) if c = 0).
        V = u * G
        c = V.x % r
        if c == 0:
            print(f""c={c}"")
            continue
        d = (modinv(u, r) * (msg_hash + priv.secret * c)) % r
        if d == 0:
            print(f""d={d}"")
            continue
        break
 
    signature = ECDSASignature(c, d)
    return signature
 
 
def verify_signature(pub, msg, signature):
    r = pub.ecc_setup.r
    G = pub.ecc_setup.G
    c = signature.c
    d = signature.d
 
    # Verify that c and d are integers in the interval [1, r - 1].
    def num_ok(n):
        return 1 < n < (r - 1)
 
    if not num_ok(c):
        raise ValueError(f""Invalid signature value: c={c}"")
    if not num_ok(d):
        raise ValueError(f""Invalid signature value: d={d}"")
 
    # Compute f = H(m) and h ≡ d^-1 mod r.
    msg_hash = get_msg_hash(msg)
    h = modinv(d, r)
 
    # Compute h1 ≡ f·h mod r and h2 ≡ c·h mod r.
    h1 = (msg_hash * h) % r
    h2 = (c * h) % r
 
    # Compute h1G + h2W = (x1, y1) and c1 ≡ x1 mod r.
    # Accept the signature if and only if c1 = c.
    P = h1 * G + h2 * pub.W
    c1 = P.x % r
    rv = c1 == c
    return rv
 
 
def get_ecc_setup(curve=None, basepoint=None, r=None):
    if curve is None:
        curve = secp256k1_curve
    if basepoint is None:
        basepoint = secp256k1_basepoint
    if r is None:
        r = secp256k1.r
 
    # 1. Select an elliptic curve E defined over ℤp.
    #    The number of points in E(ℤp) should be divisible by a large prime r.
    E = CurveFP(curve.p, curve.a, curve.b)
 
    # 2. Select a base point G ∈ E(ℤp) of order r (which means that rG = 𝒪).
    G = PointEC(E, basepoint.x, basepoint.y)
    assert (G * r) == G.get_identity()
 
    ecc_setup = ECCSetup(E, G, r)
    return ecc_setup
 
 
def main():
    ecc_setup = get_ecc_setup()
    print(f""E: y^2 = x^3 + {ecc_setup.E.a}x + {ecc_setup.E.b} (mod {ecc_setup.E.p})"")
    print(f""base point G({ecc_setup.G.x}, {ecc_setup.G.y})"")
    print(f""order(G, E) = {ecc_setup.r}"")
 
    print(""Generating keys"")
    priv, pub = generate_keypair(ecc_setup)
    print(f""private key s = {priv.secret}"")
    print(f""public key W = sG ({pub.W.x}, {pub.W.y})"")
 
    msg_orig = b""hello world""
    signature = sign(priv, msg_orig)
    print(f""signature ({msg_orig}, priv) = (c,d) = {signature.c}, {signature.d}"")
 
    validation = verify_signature(pub, msg_orig, signature)
    print(f""verify_signature(pub, {msg_orig}, signature) = {validation}"")
 
    msg_bad = b""hello planet""
    validation = verify_signature(pub, msg_bad, signature)
    print(f""verify_signature(pub, {msg_bad}, signature) = {validation}"")
 
 
if __name__ == ""__main__"":
    main()
 "
tv0a,python,Elliptic curve arithmetic,Security and Cryptography,Cryptographic Techniques,"#!/usr/bin/env python3
 
class Point:
    b = 7
    def __init__(self, x=float('inf'), y=float('inf')):
        self.x = x
        self.y = y
 
    def copy(self):
        return Point(self.x, self.y)
 
    def is_zero(self):
        return self.x > 1e20 or self.x < -1e20
 
    def neg(self):
        return Point(self.x, -self.y)
 
    def dbl(self):
        if self.is_zero():
            return self.copy()
        try:
            L = (3 * self.x * self.x) / (2 * self.y)
        except ZeroDivisionError:
            return Point()
        x = L * L - 2 * self.x
        return Point(x, L * (self.x - x) - self.y)
 
    def add(self, q):
        if self.x == q.x and self.y == q.y:
            return self.dbl()
        if self.is_zero():
            return q.copy()
        if q.is_zero():
            return self.copy()
        try:
            L = (q.y - self.y) / (q.x - self.x)
        except ZeroDivisionError:
            return Point()
        x = L * L - self.x - q.x
        return Point(x, L * (self.x - x) - self.y)
 
    def mul(self, n):
        p = self.copy()
        r = Point()
        i = 1
        while i <= n:
            if i&n:
                r = r.add(p)
            p = p.dbl()
            i <<= 1
        return r
 
    def __str__(self):
        return ""({:.3f}, {:.3f})"".format(self.x, self.y)
 
def show(s, p):
    print(s, ""Zero"" if p.is_zero() else p)
 
def from_y(y):
    n = y * y - Point.b
    x = n**(1./3) if n>=0 else -((-n)**(1./3))
    return Point(x, y)
 
# demonstrate
a = from_y(1)
b = from_y(2)
show(""a ="", a)
show(""b ="", b)
c = a.add(b)
show(""c = a + b ="", c)
d = c.neg()
show(""d = -c ="", d)
show(""c + d ="", c.add(d))
show(""a + b + d ="", a.add(b.add(d)))
show(""a * 12345 ="", a.mul(12345))"
hoxo,python,Emirp primes,Mathematics,Number Theory,"from __future__ import print_function
from prime_decomposition import primes, is_prime
from heapq import *
from itertools import islice
 
def emirp():
    largest = set()
    emirps = []
    heapify(emirps)
    for pr in primes():
        while emirps and pr > emirps[0]:
            yield heappop(emirps)
        if pr in largest:
            yield pr
        else:
            rp = int(str(pr)[::-1])
            if rp > pr and is_prime(rp):
                heappush(emirps, pr)
                largest.add(rp)
 
print('First 20:\n  ', list(islice(emirp(), 20)))
print('Between 7700 and 8000:\n  [', end='')
for pr in emirp():
    if pr >= 8000: break
    if pr >= 7700: print(pr, end=', ')
print(']')
print('10000th:\n  ', list(islice(emirp(), 10000-1, 10000)))"
x0f2,python,Empty directory,Systems Programming and File I/O,File Operations,"import os;
if os.listdir(raw_input(""directory"")):
    print ""not empty""
else:
    print ""empty""
 "
28td,python,Empty string,Text Processing,String Manipulation," 
s = ''
# or:
s = str()
 
if not s or s == '':
   print(""String is empty"")
 
if len(s) == 0:
    print(""String is empty"")
else:
    print(""String not empty"")
 
 
# boolean test function for python2 and python3
# test for regular (non-unicode) strings
# unicode strings
# None 
def emptystring(s):
   if isinstance(s, (''.__class__ , u''.__class__) ):
      if len(s) == 0: 
         return True
      else 
         return False
 
   elif s is None:
        return True
 "
nrxw,python,Enforced immutability,Programming Concepts,Fundamentals,">>> s = ""Hello""
>>> s[0] = ""h""
 
Traceback (most recent call last):
  File ""<pyshell#1>"", line 1, in <module>
    s[0] = ""h""
TypeError: 'str' object does not support item assignment"
a5t3,python,Entropy,Mathematics,Probability and Statistics,"from __future__ import division
import math
 
def hist(source):
    hist = {}; l = 0;
    for e in source:
        l += 1
        if e not in hist:
            hist[e] = 0
        hist[e] += 1
    return (l,hist)
 
def entropy(hist,l):
    elist = []
    for v in hist.values():
        c = v / l
        elist.append(-c * math.log(c ,2))
    return sum(elist)
 
def printHist(h):
    flip = lambda (k,v) : (v,k)
    h = sorted(h.iteritems(), key = flip)
    print 'Sym\thi\tfi\tInf'
    for (k,v) in h:
        print '%s\t%f\t%f\t%f'%(k,v,v/l,-math.log(v/l, 2))
 
 
 
source = ""1223334444""
(l,h) = hist(source);
print '.[Results].'
print 'Length',l
print 'Entropy:', entropy(h, l)
printHist(h)"
0shb,python,Entropy/Narcissist,Mathematics,Probability and Statistics,"import math
from collections import Counter
 
def entropy(s):
    p, lns = Counter(s), float(len(s))
    return -sum( count/lns * math.log(count/lns, 2) for count in p.values())
 
with open(__file__) as f:
    b=f.read()
 
print(entropy(b))"
rf2d,python,Enumerations,Programming Concepts,Fundamentals,">>> from enum import Enum
>>> Contact = Enum('Contact', 'FIRST_NAME, LAST_NAME, PHONE')
>>> Contact.__members__
mappingproxy(OrderedDict([('FIRST_NAME', <Contact.FIRST_NAME: 1>), ('LAST_NAME', <Contact.LAST_NAME: 2>), ('PHONE', <Contact.PHONE: 3>)]))
>>> 
>>> # Explicit
>>> class Contact2(Enum):
	FIRST_NAME = 1
	LAST_NAME = 2
	PHONE = 3
 
 
>>> Contact2.__members__
mappingproxy(OrderedDict([('FIRST_NAME', <Contact2.FIRST_NAME: 1>), ('LAST_NAME', <Contact2.LAST_NAME: 2>), ('PHONE', <Contact2.PHONE: 3>)]))
>>> "
lt4v,python,Environment variables,Systems Programming and File I/O,File Operations,"import os
os.environ['HOME']"
rhej,python,Equilibrium index,Algorithms and Data Structures,Algorithms,"def eqindex2Pass(data):
    ""Two pass""
    suml, sumr, ddelayed = 0, sum(data), 0
    for i, d in enumerate(data):
        suml += ddelayed
        sumr -= d
        ddelayed = d
        if suml == sumr:
            yield i"
o0a5,python,Esthetic numbers,Mathematics,Combinatorics,"from collections import deque
from itertools import dropwhile, islice, takewhile
from textwrap import wrap
from typing import Iterable, Iterator
 
 
Digits = str  # Alias for the return type of to_digits()
 
 
def esthetic_nums(base: int) -> Iterator[int]:
    """"""Generate the esthetic number sequence for a given base
 
    >>> list(islice(esthetic_nums(base=10), 20))
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21, 23, 32, 34, 43, 45, 54, 56, 65]
    """"""
    queue: deque[tuple[int, int]] = deque()
    queue.extendleft((d, d) for d in range(1, base))
    while True:
        num, lsd = queue.pop()
        yield num
        new_lsds = (d for d in (lsd - 1, lsd + 1) if 0 <= d < base)
        num *= base  # Shift num left one digit
        queue.extendleft((num + d, d) for d in new_lsds)
 
 
def to_digits(num: int, base: int) -> Digits:
    """"""Return a representation of an integer as digits in a given base
 
    >>> to_digits(0x3def84f0ce, base=16)
    '3def84f0ce'
    """"""
    digits: list[str] = []
    while num:
        num, d = divmod(num, base)
        digits.append(""0123456789abcdef""[d])
    return """".join(reversed(digits)) if digits else ""0""
 
 
def pprint_it(it: Iterable[str], indent: int = 4, width: int = 80) -> None:
    """"""Pretty print an iterable which returns strings
 
    >>> pprint_it(map(str, range(20)), indent=0, width=40)
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
    12, 13, 14, 15, 16, 17, 18, 19
    <BLANKLINE>
    """"""
    joined = "", "".join(it)
    lines = wrap(joined, width=width - indent)
    for line in lines:
        print(f""{indent*' '}{line}"")
    print()
 
 
def task_2() -> None:
    nums: Iterator[int]
    for base in range(2, 16 + 1):
        start, stop = 4 * base, 6 * base
        nums = esthetic_nums(base)
        nums = islice(nums, start - 1, stop)  # start and stop are 1-based indices
        print(
            f""Base-{base} esthetic numbers from ""
            f""index {start} through index {stop} inclusive:\n""
        )
        pprint_it(to_digits(num, base) for num in nums)
 
 
def task_3(lower: int, upper: int, base: int = 10) -> None:
    nums: Iterator[int] = esthetic_nums(base)
    nums = dropwhile(lambda num: num < lower, nums)
    nums = takewhile(lambda num: num <= upper, nums)
    print(
        f""Base-{base} esthetic numbers with ""
        f""magnitude between {lower:,} and {upper:,}:\n""
    )
    pprint_it(to_digits(num, base) for num in nums)
 
 
if __name__ == ""__main__"":
    print(""======\nTask 2\n======\n"")
    task_2()
 
    print(""======\nTask 3\n======\n"")
    task_3(1_000, 9_999)
 
    print(""======\nTask 4\n======\n"")
    task_3(100_000_000, 130_000_000)
 
 "
6ban,python,Ethiopian multiplication,Mathematics,Algebra and Arithmetic,"tutor = True
 
def halve(x):
    return x // 2
 
def double(x):
    return x * 2
 
def even(x):
    return not x % 2
 
def ethiopian(multiplier, multiplicand):
    if tutor:
        print(""Ethiopian multiplication of %i and %i"" %
              (multiplier, multiplicand))
    result = 0
    while multiplier >= 1:
        if even(multiplier):
            if tutor:
                print(""%4i %6i STRUCK"" %
                      (multiplier, multiplicand))
        else:
            if tutor:
                print(""%4i %6i KEPT"" %
                      (multiplier, multiplicand))
            result += multiplicand
        multiplier   = halve(multiplier)
        multiplicand = double(multiplicand)
    if tutor:
        print()
    return result"
55x0,python,Euler method,Mathematics,Numerical Methods,"def euler(f,y0,a,b,h):
	t,y = a,y0
	while t <= b:
		print ""%6.3f %6.3f"" % (t,y)
		t += h
		y += h * f(t,y)
 
def newtoncooling(time, temp):
	return -0.07 * (temp - 20)
 
euler(newtoncooling,100,0,100,10)
 "
zb08,python,Euler's identity,Mathematics,Algebra and Arithmetic,">>> import math
>>> math.e ** (math.pi * 1j) + 1
1.2246467991473532e-16j"
xtug,python,Euler's sum of powers conjecture,Mathematics,Number Theory,"def eulers_sum_of_powers():
    max_n = 250
    pow_5 = [n**5 for n in range(max_n)]
    pow5_to_n = {n**5: n for n in range(max_n)}
    for x0 in range(1, max_n):
        for x1 in range(1, x0):
            for x2 in range(1, x1):
                for x3 in range(1, x2):
                    pow_5_sum = sum(pow_5[i] for i in (x0, x1, x2, x3))
                    if pow_5_sum in pow5_to_n:
                        y = pow5_to_n[pow_5_sum]
                        return (x0, x1, x2, x3, y)
 
print(""%i**5 + %i**5 + %i**5 + %i**5 == %i**5"" % eulers_sum_of_powers())"
o189,python,Evaluate binomial coefficients,Mathematics,Combinatorics,"def binomialCoeff(n, k):
    result = 1
    for i in range(1, k+1):
        result = result * (n-i+1) / i
    return result
 
if __name__ == ""__main__"":
    print(binomialCoeff(5, 3))"
mf70,python,Even or odd,Mathematics,Algebra and Arithmetic,">>> def is_odd(i): return bool(i & 1)
 
>>> def is_even(i): return not is_odd(i)
 
>>> [(j, is_odd(j)) for j in range(10)]
[(0, False), (1, True), (2, False), (3, True), (4, False), (5, True), (6, False), (7, True), (8, False), (9, True)]
>>> [(j, is_even(j)) for j in range(10)]
[(0, True), (1, False), (2, True), (3, False), (4, True), (5, False), (6, True), (7, False), (8, True), (9, False)]
>>> "
6ed9,python,Evolutionary algorithm,Artificial Intelligence and Machine Learning,Heuristics and Optimization,"from string import letters
from random import choice, random
 
target  = list(""METHINKS IT IS LIKE A WEASEL"")
charset = letters + ' '
parent  = [choice(charset) for _ in range(len(target))]
minmutaterate  = .09
C = range(100)
 
perfectfitness = float(len(target))
 
def fitness(trial):
    'Sum of matching chars by position'
    return sum(t==h for t,h in zip(trial, target))
 
def mutaterate():
    'Less mutation the closer the fit of the parent'
    return 1-((perfectfitness - fitness(parent)) / perfectfitness * (1 - minmutaterate))
 
def mutate(parent, rate):
    return [(ch if random() <= rate else choice(charset)) for ch in parent]
 
def que():
    '(from the favourite saying of Manuel in Fawlty Towers)'
    print (""#%-4i, fitness: %4.1f%%, '%s'"" %
           (iterations, fitness(parent)*100./perfectfitness, ''.join(parent)))
 
def mate(a, b):
    place = 0
    if choice(xrange(10)) < 7:
        place = choice(xrange(len(target)))
    else:
        return a, b
 
    return a, b, a[:place] + b[place:], b[:place] + a[place:]
 
iterations = 0
center = len(C)/2
while parent != target:
    rate = mutaterate()
    iterations += 1
    if iterations % 100 == 0: que()
    copies = [ mutate(parent, rate) for _ in C ]  + [parent]
    parent1 = max(copies[:center], key=fitness)
    parent2 = max(copies[center:], key=fitness)
    parent = max(mate(parent1, parent2), key=fitness)
que()"
uizp,python,Exceptions,Programming Concepts,Advanced Concepts,"import exceptions
class SillyError(exceptions.Exception):
    def __init__(self,args=None):
         self.args=args"
odwl,python,Exceptions/Catch an exception thrown in a nested call,Programming Concepts,Fundamentals,"class U0(Exception): pass
class U1(Exception): pass
 
def foo():
    for i in range(2):
        try:
            bar(i)
        except U0:
            print(""Function foo caught exception U0"")
 
def bar(i):
    baz(i) # Nest those calls
 
def baz(i):
    raise U1 if i else U0
 
foo()"
vzvl,python,Executable library,Programming Concepts,Fundamentals,"def hailstone(n):
    seq = [n]
    while n>1:
        n = 3*n + 1 if n & 1 else n//2
        seq.append(n)
    return seq
 
if __name__ == '__main__':
    h = hailstone(27)
    assert len(h)==112 and h[:4]==[27, 82, 41, 124] and h[-4:]==[8, 4, 2, 1]
    print(""Maximum length %i was found for hailstone(%i) for numbers <100,000"" %
          max((len(hailstone(i)), i) for i in range(1,100000)))"
sw5q,python,Execute Brain****,Programming Concepts,Fundamentals,"  [ stack ]                                        is switch.arg (       --> [     )
 
  [ switch.arg put ]                               is switch     (     x -->       )
 
  [ switch.arg release ]                           is otherwise  (       -->       )
 
  [ switch.arg share != iff ]else[ done  
    otherwise  ]'[ do ]done[ ]                     is case       (     x -->       )
 
  [ dip tuck unrot poke swap ]                     is poketape   ( [ n n --> [ n   )
 
  [ 1+ over size over = if [ dip [ 0 join ] ] ]    is stepright  (   [ n --> [ n   )
 
  [ dup 0 = iff [ 0 rot join swap ] else [ 1 - ] ] is stepleft   (   [ n --> [ n   )
 
  [ 2dup peek 1 + poketape ]                       is increment  (   [ n --> [ n   )
 
  [ 2dup peek 1 - poketape ]                       is decrement  (   [ n --> [ n   )
 
  [ 2dup peek emit ]                               is print      (   [ n --> [ n   )
 
  [ temp take dup $ """" = iff 0 else behead
    swap temp put poketape ]                       is getchar    (   [ n --> [ n   )
 
  [ 2dup peek 0 = ]                                is zero       (   [ n --> [ n b )
 
  [ temp put $ """" swap witheach
      [ switch
        [ char > case [ $ ""stepright ""      join ]
          char < case [ $ ""stepleft ""       join ] 
          char + case [ $ ""increment ""      join ]
          char - case [ $ ""decrement ""      join ]
          char . case [ $ ""print ""          join ] 
          char , case [ $ ""getchar ""        join ]
          char [ case [ $ ""[ zero if done "" join ] 
          char ] case [ $ ""zero until ] ""   join ] 
          otherwise ( ignore ) ] ]
    0 nested 0 rot quackery temp release 2drop ]   is brainf***  (   $ $ -->       )"
9m1t,python,Execute Computer/Zero,Programming Concepts,Fundamentals,"""""""Computer/zero Assembly emulator. Requires Python >= 3.7""""""
 
import re
 
from typing import Dict
from typing import Iterable
from typing import List
from typing import NamedTuple
from typing import Optional
from typing import Tuple
 
 
NOP = 0b000
LDA = 0b001
STA = 0b010
ADD = 0b011
SUB = 0b100
BRZ = 0b101
JMP = 0b110
STP = 0b111
 
OPCODES = {
    ""NOP"": NOP,
    ""LDA"": LDA,
    ""STA"": STA,
    ""ADD"": ADD,
    ""SUB"": SUB,
    ""BRZ"": BRZ,
    ""JMP"": JMP,
    ""STP"": STP,
}
 
RE_INSTRUCTION = re.compile(
    r""\s*""
    r""(?:(?P<label>\w+):)?""
    r""\s*""
    rf""(?P<opcode>{'|'.join(OPCODES)})?""
    r""\s*""
    r""(?P<argument>\w+)?""
    r""\s*""
    r""(?:;(?P<comment>[\w\s]+))?""
)
 
 
class AssemblySyntaxError(Exception):
    pass
 
 
class Instruction(NamedTuple):
    label: Optional[str]
    opcode: Optional[str]
    argument: Optional[str]
    comment: Optional[str]
 
 
def parse(assembly: str) -> Tuple[List[Instruction], Dict[str, int]]:
    instructions: List[Instruction] = []
    labels: Dict[str, int] = {}
    linenum: int = 0
 
    for line in assembly.split(""\n""):
        match = RE_INSTRUCTION.match(line)
 
        if not match:
            raise AssemblySyntaxError(f""{line}: {linenum}"")
 
        instructions.append(Instruction(**match.groupdict()))
        label = match.group(1)
        if label:
            labels[label] = linenum
 
        linenum += 1
 
    return instructions, labels
 
 
def compile(instructions: List[Instruction], labels: Dict[str, int]) -> Iterable[int]:
    for instruction in instructions:
        if instruction.argument is None:
            argument = 0
        elif instruction.argument.isnumeric():
            argument = int(instruction.argument)
        else:
            argument = labels[instruction.argument]
 
        if instruction.opcode:
            yield OPCODES[instruction.opcode] << 5 | argument
        else:
            yield argument
 
 
def run(bytecode: bytes) -> int:
    accumulator = 0
    program_counter = 0
    memory = list(bytecode)[:32] + [0 for _ in range(32 - len(bytecode))]
 
    while program_counter < 32:
        operation = memory[program_counter] >> 5
        argument = memory[program_counter] & 0b11111
        program_counter += 1
 
        if operation == NOP:
            continue
        elif operation == LDA:
            accumulator = memory[argument]
        elif operation == STA:
            memory[argument] = accumulator
        elif operation == ADD:
            accumulator = (accumulator + memory[argument]) % 256
        elif operation == SUB:
            accumulator = (accumulator - memory[argument]) % 256
        elif operation == BRZ:
            if accumulator == 0:
                program_counter = argument
        elif operation == JMP:
            program_counter = argument
        elif operation == STP:
            break
        else:
            raise Exception(f""error: {operation} {argument}"")
 
    return accumulator
 
 
SAMPLES = [
    """"""\
            LDA   x
            ADD   y       ; accumulator = x + y
            STP
    x:            2
    y:            2
    """""",
    """"""\
    loop:   LDA   prodt
            ADD   x
            STA   prodt
            LDA   y
            SUB   one
            STA   y
            BRZ   done
            JMP   loop
    done:   LDA   prodt   ; to display it
            STP
    x:            8
    y:            7
    prodt:        0
    one:          1
    """""",
    """"""\
    loop:   LDA   n
            STA   temp
            ADD   m
            STA   n
            LDA   temp
            STA   m
            LDA   count
            SUB   one
            BRZ   done
            STA   count
            JMP   loop
    done:   LDA   n       ; to display it
            STP
    m:            1
    n:            1
    temp:         0
    count:        8       ; valid range: 1-11
    one:          1
    """""",
    """"""\
    start:  LDA   load
            ADD   car     ; head of list
            STA   ldcar
            ADD   one
            STA   ldcdr   ; next CONS cell
    ldcar:  NOP
            STA   value
    ldcdr:  NOP
            BRZ   done    ; 0 stands for NIL
            STA   car
            JMP   start
    done:   LDA   value   ; CAR of last CONS
            STP
    load:   LDA   0
    value:        0
    car:          28
    one:          1
                        ; order of CONS cells
                        ; in memory
                        ; does not matter
                6
                0       ; 0 stands for NIL
                2       ; (CADR ls)
                26      ; (CDDR ls) -- etc.
                5
                20
                3
                30
                1       ; value of (CAR ls)
                22      ; points to (CDR ls)
                4
                24
    """""",
    """"""\
    p:            0       ; NOP in first round
    c:            0
    start:  STP           ; wait for p's move
    pmove:  NOP
            LDA   pmove
            SUB   cmove
            BRZ   same
            LDA   pmove
            STA   cmove   ; tit for tat
            BRZ   cdeft
            LDA   c       ; p defected, c did not
            ADD   three
            STA   c
            JMP   start
    cdeft:  LDA   p
            ADD   three
            STA   p
            JMP   start
    same:   LDA   pmove
            STA   cmove   ; tit for tat
            LDA   p
            ADD   one
            ADD   pmove
            STA   p
            LDA   c
            ADD   one
            ADD   pmove
            STA   c
            JMP   start
    cmove:        0       ; co-operate initially
    one:          1
    three:        3
    """""",
    """"""\
    LDA  3
    SUB  4
    STP  0
         0
         255
    """""",
    """"""\
    LDA  3
    SUB  4
    STP  0
         0
         1
    """""",
    """"""\
    LDA  3
    ADD  4
    STP  0
         1
         255
    """""",
]
 
 
def main() -> None:
    for sample in SAMPLES:
        instructions, labels = parse(sample)
        bytecode = bytes(compile(instructions, labels))
        result = run(bytecode)
        print(result)
 
 
if __name__ == ""__main__"":
    main()
 "
3ib6,python,Execute HQ9+,Puzzles and Games,Puzzle Solving Algorithms,"$ ""bottles.qky"" loadfile ( if required, the source code for this can be found at 
                           http://rosettacode.org/wiki/99_bottles_of_beer#Quackery )
 
[ stack ]                  is accumulator (   --> s ) 
 
[ stack ]                  is sourcecode  (   --> s ) 
 
[ say ""Hello, world!"" cr ] is H.HQ9+      (   -->   )
 
[ sourcecode share 
  echo$ cr ]               is Q.HQ9+      (   -->   )
 
[ 99 song echo$ ]          is 9.HQ9+      (   -->   )
 
[ 1 accumulator tally ]    is +.HQ9+      (   -->   )
 
[ dup sourcecode put
  0 accumulator put
  witheach
    [ $ "".HQ9+"" join
      quackery ]
  sourcecode release
  cr say ""Accumulator = ""
  accumulator take echo ]  is HQ9+        ( $ -->   )
 
$ ""HH+QQQQ+"" HQ9+"
35ui,python,Execute SNUSP,Puzzles and Games,Puzzle Solving Algorithms,"#!/usr/bin/env python3
 
HW = r'''
/++++!/===========?\>++.>+.+++++++..+++\
\+++\ | /+>+++++++>/ /++++++++++<<.++>./
$+++/ | \+++++++++>\ \+++++.>.+++.-----\
      \==-<<<<+>+++/ /=.>.+>.--------.-/'''
 
def snusp(store, code):
    ds = bytearray(store)  # data store
    dp = 0                 # data pointer
    cs = code.splitlines() # 2 dimensional code store
    ipr, ipc = 0, 0        # instruction pointers in row and column
    for r, row in enumerate(cs):
        try:
            ipc = row.index('$')
            ipr = r
            break
        except ValueError:
            pass
    rt, dn, lt, up = range(4)
    id = rt  # instruction direction.  starting direction is always rt
    def step():
        nonlocal ipr, ipc
        if id&1:
            ipr += 1 - (id&2)
        else:
            ipc += 1 - (id&2)
    while ipr >= 0 and ipr < len(cs) and ipc >= 0 and ipc < len(cs[ipr]):
        op = cs[ipr][ipc]
        if op == '>':
            dp += 1
        elif op == '<':
            dp -= 1
        elif op == '+':
            ds[dp] += 1
        elif op == '-':
            ds[dp] -= 1
        elif op == '.':
            print(chr(ds[dp]), end='')
        elif op == ',':
            ds[dp] = input()
        elif op == '/':
            id = ~id
        elif op == '\\':
            id ^= 1
        elif op == '!':
            step()
        elif op == '?':
            if not ds[dp]:
                step()
        step()
 
if __name__ == '__main__':
    snusp(5, HW)"
7d4m,python,Execute a Markov algorithm,Algorithms and Data Structures,Algorithms,"import re
 
def extractreplacements(grammar):
    return [ (matchobj.group('pat'), matchobj.group('repl'), bool(matchobj.group('term')))
                for matchobj in re.finditer(syntaxre, grammar)
                if matchobj.group('rule')]
 
def replace(text, replacements):
    while True:
        for pat, repl, term in replacements:
            if pat in text:
                text = text.replace(pat, repl, 1)
                if term:
                    return text
                break
        else:
            return text
 
syntaxre = r""""""(?mx)
^(?: 
  (?: (?P<comment> \# .* ) ) |
  (?: (?P<blank>   \s*  ) (?: \n | $ )  ) |
  (?: (?P<rule>    (?P<pat> .+? ) \s+ -> \s+ (?P<term> \.)? (?P<repl> .+) ) )
)$
""""""
 
grammar1 = """"""\
# This rules file is extracted from Wikipedia:
# http://en.wikipedia.org/wiki/Markov_Algorithm
A -> apple
B -> bag
S -> shop
T -> the
the shop -> my brother
a never used -> .terminating rule
""""""
 
grammar2 = '''\
# Slightly modified from the rules on Wikipedia
A -> apple
B -> bag
S -> .shop
T -> the
the shop -> my brother
a never used -> .terminating rule
'''
 
grammar3 = '''\
# BNF Syntax testing rules
A -> apple
WWWW -> with
Bgage -> ->.*
B -> bag
->.* -> money
W -> WW
S -> .shop
T -> the
the shop -> my brother
a never used -> .terminating rule
'''
 
grammar4 = '''\
### Unary Multiplication Engine, for testing Markov Algorithm implementations
### By Donal Fellows.
# Unary addition engine
_+1 -> _1+
1+1 -> 11+
# Pass for converting from the splitting of multiplication into ordinary
# addition
1! -> !1
,! -> !+
_! -> _
# Unary multiplication by duplicating left side, right side times
1*1 -> x,@y
1x -> xX
X, -> 1,1
X1 -> 1X
_x -> _X
,x -> ,X
y1 -> 1y
y_ -> _
# Next phase of applying
1@1 -> x,@y
1@_ -> @_
,@_ -> !_
++ -> +
# Termination cleanup for addition
_1 -> 1
1+_ -> 1
_+_ -> 
'''
 
grammar5 = '''\
# Turing machine: three-state busy beaver
#
# state A, symbol 0 => write 1, move right, new state B
A0 -> 1B
# state A, symbol 1 => write 1, move left, new state C
0A1 -> C01
1A1 -> C11
# state B, symbol 0 => write 1, move left, new state A
0B0 -> A01
1B0 -> A11
# state B, symbol 1 => write 1, move right, new state B
B1 -> 1B
# state C, symbol 0 => write 1, move left, new state B
0C0 -> B01
1C0 -> B11
# state C, symbol 1 => write 1, move left, halt
0C1 -> H01
1C1 -> H11
'''
 
text1 = ""I bought a B of As from T S.""
 
text2 = ""I bought a B of As W my Bgage from T S.""
 
text3 = '_1111*11111_'
 
text4 = '000000A000000'
 
 
if __name__ == '__main__':
    assert replace(text1, extractreplacements(grammar1)) \
           == 'I bought a bag of apples from my brother.'
    assert replace(text1, extractreplacements(grammar2)) \
           == 'I bought a bag of apples from T shop.'
    # Stretch goals
    assert replace(text2, extractreplacements(grammar3)) \
           == 'I bought a bag of apples with my money from T shop.'
    assert replace(text3, extractreplacements(grammar4)) \
           == '11111111111111111111'
    assert replace(text4, extractreplacements(grammar5)) \
           == '00011H1111000'"
0f2q,python,Execute a system command,Systems Programming and File I/O,File Operations,"import os
exit_code = os.system('ls')       # Just execute the command, return a success/fail code
output    = os.popen('ls').read() # If you want to get the output data. Deprecated."
dl9h,python,Exponentiation operator,Mathematics,Algebra and Arithmetic,"MULTIPLY = lambda x, y: x*y
 
class num(float):
    # the following method has complexity O(b)
    # rather than O(log b) via the rapid exponentiation
    def __pow__(self, b):
        return reduce(MULTIPLY, [self]*b, 1)
 
# works with ints as function or operator
print num(2).__pow__(3)
print num(2) ** 3
 
# works with floats as function or operator
print num(2.3).__pow__(8)
print num(2.3) ** 8"
604d,python,Exponentiation order,Mathematics,Algebra and Arithmetic,">>> 5**3**2
1953125
>>> (5**3)**2
15625
>>> 5**(3**2)
1953125
>>> # The following is not normally done
>>> try: from functools import reduce # Py3K
except: pass
 
>>> reduce(pow, (5, 3, 2))
15625
>>> "
6tuj,python,Exponentiation with infix operators in (or operating on) the base,Mathematics,Algebra and Arithmetic,"from itertools import product
 
xx = '-5 +5'.split()
pp = '2 3'.split()
texts = '-x**p -(x)**p (-x)**p -(x**p)'.split()
 
print('Integer variable exponentiation')
for x, p in product(xx, pp):
    print(f'  x,p = {x:2},{p}; ', end=' ')
    x, p = int(x), int(p)
    print('; '.join(f""{t} =={eval(t):4}"" for t in texts))
 
print('\nBonus integer literal exponentiation')
X, P = 'xp'
xx.insert(0, ' 5')
texts.insert(0, 'x**p')
for x, p in product(xx, pp):
    texts2 = [t.replace(X, x).replace(P, p) for t in texts]
    print(' ', '; '.join(f""{t2} =={eval(t2):4}"" for t2 in texts2))"
e5v2,python,Extend your language,Programming Concepts,Advanced Concepts,"a, b = 1, 0
 
if (c1 := a == 1) and (c2 := b == 3):
  print('a = 1 and b = 3')
elif c1:
  print('a = 1 and b <> 3')
elif c2:
  print('a <> 1 and b = 3')
else:
  print('a <> 1 and b <> 3')"
mgq5,python,Extensible prime generator,Mathematics,Number Theory,"islice(count(7), 0, None, 2)"
pwir,python,Extreme floating point values,Mathematics,Numerical Methods,">>> # Extreme values from expressions
>>> inf = 1e234 * 1e234
>>> _inf = 1e234 * -1e234
>>> _zero = 1 / _inf
>>> nan = inf + _inf
>>> inf, _inf, _zero, nan
(inf, -inf, -0.0, nan)
>>> # Print
>>> for value in (inf, _inf, _zero, nan): print (value)
 
inf
-inf
-0.0
nan
>>> # Extreme values from other means
>>> float('nan')
nan
>>> float('inf')
inf
>>> float('-inf')
-inf
>>> -0.
-0.0
>>> # Some arithmetic
>>> nan == nan
False
>>> nan is nan
True
>>> 0. == -0.
True
>>> 0. is -0.
False
>>> inf + _inf
nan
>>> 0.0 * nan
nan
>>> nan * 0.0
nan
>>> 0.0 * inf
nan
>>> inf * 0.0
nan"
sktf,python,FASTA format,Text Processing,Parsing and Tokenization,"import io
 
FASTA='''\
>Rosetta_Example_1
THERECANBENOSPACE
>Rosetta_Example_2
THERECANBESEVERAL
LINESBUTTHEYALLMUST
BECONCATENATED'''
 
infile = io.StringIO(FASTA)
 
def fasta_parse(infile):
    key = ''
    for line in infile:
        if line.startswith('>'):
            if key:
                yield key, val
            key, val = line[1:].rstrip().split()[0], ''
        elif key:
            val += line.rstrip()
    if key:
        yield key, val
 
print('\n'.join('%s: %s' % keyval for keyval in fasta_parse(infile)))"
m41x,python,FTP,Networking and Web Development,Networking," 
from ftplib import FTP
ftp = FTP('kernel.org')
ftp.login()
ftp.cwd('/pub/linux/kernel')
ftp.set_pasv(True) # Default since Python 2.1
print ftp.retrlines('LIST')
print ftp.retrbinary('RETR README', open('README', 'wb').write)
ftp.quit()
 "
bbm4,python,Faces from a mesh,Algorithms and Data Structures,Algorithms,"def perim_equal(p1, p2):
    # Cheap tests first
    if len(p1) != len(p2) or set(p1) != set(p2):
        return False
    if any(p2 == (p1[n:] + p1[:n]) for n in range(len(p1))):
        return True
    p2 = p2[::-1] # not inplace
    return any(p2 == (p1[n:] + p1[:n]) for n in range(len(p1)))
 
def edge_to_periphery(e):
    edges = sorted(e)
    p = list(edges.pop(0)) if edges else []
    last = p[-1] if p else None
    while edges:
        for n, (i, j) in enumerate(edges):
            if i == last:
                p.append(j)
                last = j
                edges.pop(n)
                break
            elif j == last:
                p.append(i)
                last = i
                edges.pop(n)
                break
        else:
            #raise ValueError(f'Invalid edge format: {e}')
            return "">>>Error! Invalid edge format<<<""
    return p[:-1]
 
if __name__ == '__main__':
    print('Perimeter format equality checks:')
    for eq_check in [
            { 'Q': (8, 1, 3),
              'R': (1, 3, 8)},
            { 'U': (18, 8, 14, 10, 12, 17, 19),
              'V': (8, 14, 10, 12, 17, 19, 18)} ]:
        (n1, p1), (n2, p2) = eq_check.items()
        eq = '==' if perim_equal(p1, p2) else '!='
        print(' ', n1, eq, n2)
 
    print('\nEdge to perimeter format translations:')
    edge_d = {
     'E': {(1, 11), (7, 11), (1, 7)},
     'F': {(11, 23), (1, 17), (17, 23), (1, 11)},
     'G': {(8, 14), (17, 19), (10, 12), (10, 14), (12, 17), (8, 18), (18, 19)},
     'H': {(1, 3), (9, 11), (3, 11), (1, 11)}
            }
    for name, edges in edge_d.items():
        print(f""  {name}: {edges}\n     -> {edge_to_periphery(edges)}"")"
yu0q,python,Factorial,Mathematics,Algebra and Arithmetic,"import math
math.factorial(n)"
hxo1,python,Factorial base numbers indexing permutations of a collection,Puzzles and Games,Puzzle Solving Algorithms," 
""""""
 
http://rosettacode.org/wiki/Factorial_base_numbers_indexing_permutations_of_a_collection
 
https://en.wikipedia.org/wiki/Factorial_number_system
 
""""""
 
import math
 
def apply_perm(omega,fbn):
    """"""
 
    omega contains a list which will be permuted (scrambled)
    based on fbm.
 
    fbm is a list which represents a factorial base number.
 
    This function just translates the pseudo code in the 
    Rosetta Code task.
 
    """"""
    for m in range(len(fbn)):
        g = fbn[m]
        if g > 0:
            # do rotation
            # save last number
            new_first = omega[m+g]
            # move numbers right
            omega[m+1:m+g+1] = omega[m:m+g]
            # put last number first
            omega[m] = new_first
 
    return omega
 
def int_to_fbn(i):
    """"""
 
    convert integer i to factorial based number
 
    """"""
    current = i
    divisor = 2
    new_fbn = []
    while current > 0:
        remainder = current % divisor
        current = current // divisor
        new_fbn.append(remainder)
        divisor += 1
 
    return list(reversed(new_fbn))
 
def leading_zeros(l,n):
   """"""
 
   If list l has less than n elements returns l with enough 0 elements
   in front of the list to make it length n.
 
   """"""
   if len(l) < n:
       return(([0] * (n - len(l))) + l)
   else:
       return l
 
def get_fbn(n):
    """"""
 
    Return the n! + 1 first Factorial Based Numbers starting with zero.
 
    """"""
    max = math.factorial(n)
 
    for i in range(max):
        # from Wikipedia article
        current = i
        divisor = 1
        new_fbn = int_to_fbn(i)
        yield leading_zeros(new_fbn,n-1)
 
def print_write(f, line):
    """"""
 
    prints to console and
    output file f
 
    """"""
    print(line)
    f.write(str(line)+'\n')     
 
def dot_format(l):
    """"""
    Take a list l that is a factorial based number
    and returns it in dot format.
 
    i.e. [0, 2, 1] becomes 0.2.1
    """"""
    # empty list
    if len(l) < 1:
        return """"
    # start with just first element no dot
    dot_string = str(l[0])
    # add rest if any with dots
    for e in l[1:]:
        dot_string += "".""+str(e)
 
    return dot_string
 
def str_format(l):
    """"""
    Take a list l and returns a string
    of those elements converted to strings.
    """"""
    if len(l) < 1:
        return """"
 
    new_string = """"
 
    for e in l:
        new_string += str(e)
 
    return new_string 
 
with open(""output.html"", ""w"", encoding=""utf-8"") as f:
    f.write(""<pre>\n"")
 
    # first print list
 
    omega=[0,1,2,3]
 
    four_list = get_fbn(4)
 
    for l in four_list:
        print_write(f,dot_format(l)+' -> '+str_format(apply_perm(omega[:],l)))
 
    print_write(f,"" "")
 
    # now generate this output:
    #
    # Permutations generated = 39916800
    # compared to 11! which  = 39916800
 
 
    num_permutations = 0
 
    for p in get_fbn(11):
        num_permutations += 1
        if num_permutations % 1000000 == 0:
            print_write(f,""permutations so far = ""+str(num_permutations))
 
    print_write(f,"" "")
    print_write(f,""Permutations generated = ""+str(num_permutations))
    print_write(f,""compared to 11! which  = ""+str(math.factorial(11)))
 
    print_write(f,"" "")
 
 
 
    """"""
 
    u""\u2660"" - spade
 
    u""\u2665"" - heart
 
    u""\u2666"" - diamond
 
    u""\u2663"" - club
 
    """"""
 
    shoe = []
 
    for suit in [u""\u2660"",u""\u2665"",u""\u2666"",u""\u2663""]:
        for value in ['A','K','Q','J','10','9','8','7','6','5','4','3','2']:
            shoe.append(value+suit)
 
    print_write(f,str_format(shoe))
 
    p1 = [39,49,7,47,29,30,2,12,10,3,29,37,33,17,12,31,29,34,17,25,2,4,25,4,1,14,20,6,21,18,1,1,1,4,0,5,15,12,4,3,10,10,9,1,6,5,5,3,0,0,0]
 
    p2 = [51,48,16,22,3,0,19,34,29,1,36,30,12,32,12,29,30,26,14,21,8,12,1,3,10,4,7,17,6,21,8,12,15,15,13,15,7,3,12,11,9,5,5,6,6,3,4,0,3,2,1]
 
    print_write(f,"" "")
    print_write(f,dot_format(p1))
    print_write(f,"" "")
    print_write(f,str_format(apply_perm(shoe[:],p1)))
 
    print_write(f,"" "")
    print_write(f,dot_format(p2))
    print_write(f,"" "")
    print_write(f,str_format(apply_perm(shoe[:],p2)))
 
    # generate random 51 digit factorial based number
 
    import random
 
    max = math.factorial(52)
 
    random_int = random.randint(0, max-1)
 
    myperm = leading_zeros(int_to_fbn(random_int),51)
 
    print(len(myperm))
 
    print_write(f,"" "")
    print_write(f,dot_format(myperm))
    print_write(f,"" "")
    print_write(f,str_format(apply_perm(shoe[:],myperm)))
 
    f.write(""</pre>\n"")
 
 "
53vt,python,Factorions,Mathematics,Combinatorics,"fact = [1] # cache factorials from 0 to 11
for n in range(1, 12):
    fact.append(fact[n-1] * n)
 
for b in range(9, 12+1):
    print(f""The factorions for base {b} are:"")
    for i in range(1, 1500000):
        fact_sum = 0
        j = i
        while j > 0:
            d = j % b
            fact_sum += fact[d]
            j = j//b
        if fact_sum == i:
            print(i, end="" "")
    print(""\n"")
 "
teu7,python,Factors of a Mersenne number,Mathematics,Number Theory,"def is_prime(number):
    return True # code omitted - see Primality by Trial Division
 
def m_factor(p):
    max_k = 16384 / p # arbitrary limit; since Python automatically uses long's, it doesn't overflow
    for k in xrange(max_k):
        q = 2*p*k + 1
        if not is_prime(q):
            continue
        elif q % 8 != 1 and q % 8 != 7:
            continue
        elif pow(2, p, q) == 1:
            return q
    return None
 
if __name__ == '__main__':
    exponent = int(raw_input(""Enter exponent of Mersenne number: ""))
    if not is_prime(exponent):
        print ""Exponent is not prime: %d"" % exponent
    else:
        factor = m_factor(exponent)
        if not factor:
            print ""No factor found for M%d"" % exponent
        else:
            print ""M%d has a factor: %d"" % (exponent, factor)"
hq8t,python,Factors of an integer,Mathematics,Number Theory,">>> def factors(n):
      return [i for i in range(1, n + 1) if not n%i]"
09hz,python,Fairshare between two and more,Mathematics,Combinatorics,"from itertools import count, islice
 
def _basechange_int(num, b):
    """"""
    Return list of ints representing positive num in base b
 
    >>> b = 3
    >>> print(b, [_basechange_int(num, b) for num in range(11)])
    3 [[0], [1], [2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2], [1, 0, 0], [1, 0, 1]]
    >>>
    """"""
    if num == 0:
        return [0]
    result = []
    while num != 0:
        num, d = divmod(num, b)
        result.append(d)
    return result[::-1]
 
def fairshare(b=2):
    for i in count():
        yield sum(_basechange_int(i, b)) % b
 
if __name__ == '__main__':
    for b in (2, 3, 5, 11):
        print(f""{b:>2}: {str(list(islice(fairshare(b), 25)))[1:-1]}"")"
5ts6,python,Farey sequence,Mathematics,Number Theory,"from fractions import Fraction
 
 
class Fr(Fraction):
    def __repr__(self):
        return '(%s/%s)' % (self.numerator, self.denominator)
 
 
def farey(n, length=False):
    if not length:
        return [Fr(0, 1)] + sorted({Fr(m, k) for k in range(1, n+1) for m in range(1, k+1)})
    else:
        #return 1         +    len({Fr(m, k) for k in range(1, n+1) for m in range(1, k+1)})
        return  (n*(n+3))//2 - sum(farey(n//k, True) for k in range(2, n+1))
 
if __name__ == '__main__':
    print('Farey sequence for order 1 through 11 (inclusive):')
    for n in range(1, 12): 
        print(farey(n))
    print('Number of fractions in the Farey sequence for order 100 through 1,000 (inclusive) by hundreds:')
    print([farey(i, length=True) for i in range(100, 1001, 100)])"
jcny,python,Fast Fourier transform,Mathematics,Numerical Methods,"from cmath import exp, pi
 
def fft(x):
    N = len(x)
    if N <= 1: return x
    even = fft(x[0::2])
    odd =  fft(x[1::2])
    T= [exp(-2j*pi*k/N)*odd[k] for k in range(N//2)]
    return [even[k] + T[k] for k in range(N//2)] + \
           [even[k] - T[k] for k in range(N//2)]
 
print( ' '.join(""%5.3f"" % abs(f) 
                for f in fft([1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0])) )"
aq13,python,Faulhaber's formula,Mathematics,Algebra and Arithmetic,"from fractions import Fraction
 
def nextu(a):
    n = len(a)
    a.append(1)
    for i in range(n - 1, 0, -1):
        a[i] = i * a[i] + a[i - 1]
    return a
 
def nextv(a):
    n = len(a) - 1
    b = [(1 - n) * x for x in a]
    b.append(1)
    for i in range(n):
        b[i + 1] += a[i]
    return b
 
def sumpol(n):
    u = [0, 1]
    v = [[1], [1, 1]]
    yield [Fraction(0), Fraction(1)]
    for i in range(1, n):
        v.append(nextv(v[-1]))
        t = [0] * (i + 2)
        p = 1
        for j, r in enumerate(u):
            r = Fraction(r, j + 1)
            for k, s in enumerate(v[j + 1]):
                t[k] += r * s
        yield t
        u = nextu(u)
 
def polstr(a):
    s = """"
    q = False
    n = len(a) - 1
    for i, x in enumerate(reversed(a)):
        i = n - i
        if i < 2:
            m = ""n"" if i == 1 else """"
        else:
            m = ""n^%d"" % i
        c = str(abs(x))
        if i > 0:
            if c == ""1"":
                c = """"
            else:
                m = "" "" + m
        if x != 0:
            if q:
                t = "" + "" if x > 0 else "" - ""
                s += ""%s%s%s"" % (t, c, m)
            else:
                t = """" if x > 0 else ""-""
                s = ""%s%s%s"" % (t, c, m)
                q = True
    if q:
        return s
    else:
        return ""0""
 
for i, p in enumerate(sumpol(10)):
    print(i, "":"", polstr(p))"
eclp,python,Faulhaber's triangle,Mathematics,Combinatorics,"'''Faulhaber's triangle'''
 
from itertools import accumulate, chain, count, islice
from fractions import Fraction
 
 
# faulhaberTriangle :: Int -> [[Fraction]]
def faulhaberTriangle(m):
    '''List of rows of Faulhaber fractions.'''
    def go(rs, n):
        def f(x, y):
            return Fraction(n, x) * y
        xs = list(map(f, islice(count(2), m), rs))
        return [Fraction(1 - sum(xs), 1)] + xs
 
    return list(accumulate(
        [[]] + list(islice(count(0), 1 + m)),
        go
    ))[1:]
 
 
# faulhaberSum :: Integer -> Integer -> Integer
def faulhaberSum(p, n):
    '''Sum of the p-th powers of the first n
       positive integers.
    '''
    def go(x, y):
        return y * (n ** x)
 
    return sum(
        map(go, count(1), faulhaberTriangle(p)[-1])
    )
 
 
# ------------------------- TEST -------------------------
def main():
    '''Tests'''
 
    fs = faulhaberTriangle(9)
    print(
        fTable(__doc__ + ':\n')(str)(
            compose(concat)(
                fmap(showRatio(3)(3))
            )
        )(
            index(fs)
        )(range(0, len(fs)))
    )
    print('')
    print(
        faulhaberSum(17, 1000)
    )
 
 
# ----------------------- DISPLAY ------------------------
 
# fTable :: String -> (a -> String) ->
# (b -> String) -> (a -> b) -> [a] -> String
def fTable(s):
    '''Heading -> x display function ->
       fx display function -> f -> xs -> tabular string.
    '''
    def gox(xShow):
        def gofx(fxShow):
            def gof(f):
                def goxs(xs):
                    ys = [xShow(x) for x in xs]
                    w = max(map(len, ys))
 
                    def arrowed(x, y):
                        return y.rjust(w, ' ') + ' -> ' + (
                            fxShow(f(x))
                        )
                    return s + '\n' + '\n'.join(
                        map(arrowed, xs, ys)
                    )
                return goxs
            return gof
        return gofx
    return gox
 
 
# ----------------------- GENERIC ------------------------
 
# compose (<<<) :: (b -> c) -> (a -> b) -> a -> c
def compose(g):
    '''Right to left function composition.'''
    return lambda f: lambda x: g(f(x))
 
 
# concat :: [[a]] -> [a]
# concat :: [String] -> String
def concat(xs):
    '''The concatenation of all the elements
       in a list or iterable.
    '''
    def f(ys):
        zs = list(chain(*ys))
        return ''.join(zs) if isinstance(ys[0], str) else zs
 
    return (
        f(xs) if isinstance(xs, list) else (
            chain.from_iterable(xs)
        )
    ) if xs else []
 
 
# fmap :: (a -> b) -> [a] -> [b]
def fmap(f):
    '''fmap over a list.
       f lifted to a function over a list.
    '''
    def go(xs):
        return list(map(f, xs))
 
    return go
 
 
# index (!!) :: [a] -> Int -> a
def index(xs):
    '''Item at given (zero-based) index.'''
    return lambda n: None if 0 > n else (
        xs[n] if (
            hasattr(xs, ""__getitem__"")
        ) else next(islice(xs, n, None))
    )
 
 
# showRatio :: Int -> Int -> Ratio -> String
def showRatio(m):
    '''Left and right aligned string
       representation of the ratio r.
    '''
    def go(n):
        def f(r):
            d = r.denominator
            return str(r.numerator).rjust(m, ' ') + (
                ('/' + str(d).ljust(n, ' ')) if 1 != d else (
                    ' ' * (1 + n)
                )
            )
        return f
    return go
 
 
# MAIN ---
if __name__ == '__main__':
    main()"
22vg,python,Feigenbaum constant calculation,Mathematics,Numerical Methods,"max_it = 13
max_it_j = 10
a1 = 1.0
a2 = 0.0
d1 = 3.2
a = 0.0
 
print "" i       d""
for i in range(2, max_it + 1):
    a = a1 + (a1 - a2) / d1
    for j in range(1, max_it_j + 1):
        x = 0.0
        y = 0.0
        for k in range(1, (1 << i) + 1):
            y = 1.0 - 2.0 * y * x
            x = a - x * x
        a = a - x / y
    d = (a1 - a2) / (a - a1)
    print(""{0:2d}    {1:.8f}"".format(i, d))
    d1 = d
    a2 = a1
    a1 = a"
a55g,python,Fermat numbers,Mathematics,Number Theory,"def factors(x):
    factors = []
    i = 2
    s = int(x ** 0.5)
    while i < s:
        if x % i == 0:
            factors.append(i)
            x = int(x / i)
            s = int(x ** 0.5)
        i += 1
    factors.append(x)
    return factors
 
print(""First 10 Fermat numbers:"")
for i in range(10):
    fermat = 2 ** 2 ** i + 1
    print(""F{} = {}"".format(chr(i + 0x2080) , fermat))
 
print(""\nFactors of first few Fermat numbers:"")
for i in range(10):
    fermat = 2 ** 2 ** i + 1
    fac = factors(fermat)
    if len(fac) == 1:
        print(""F{} -> IS PRIME"".format(chr(i + 0x2080)))
    else:
        print(""F{} -> FACTORS: {}"".format(chr(i + 0x2080), fac))"
qxxs,python,Fibonacci n-step number sequences,Mathematics,Mathematical Sequences and Series,">>> def fiblike(start):
	addnum = len(start)
	memo = start[:]
	def fibber(n):
		try:
			return memo[n]
		except IndexError:
			ans = sum(fibber(i) for i in range(n-addnum, n))
			memo.append(ans)
			return ans
	return fibber
 
>>> fibo = fiblike([1,1])
>>> [fibo(i) for i in range(10)]
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
>>> lucas = fiblike([2,1])
>>> [lucas(i) for i in range(10)]
[2, 1, 3, 4, 7, 11, 18, 29, 47, 76]
>>> for n, name in zip(range(2,11), 'fibo tribo tetra penta hexa hepta octo nona deca'.split()) :
	fibber = fiblike([1] + [2**i for i in range(n-1)])
	print('n=%2i, %5snacci -> %s ...' % (n, name, ' '.join(str(fibber(i)) for i in range(15))))
 
 
n= 2,  fibonacci -> 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 ...
n= 3, tribonacci -> 1 1 2 4 7 13 24 44 81 149 274 504 927 1705 3136 ...
n= 4, tetranacci -> 1 1 2 4 8 15 29 56 108 208 401 773 1490 2872 5536 ...
n= 5, pentanacci -> 1 1 2 4 8 16 31 61 120 236 464 912 1793 3525 6930 ...
n= 6,  hexanacci -> 1 1 2 4 8 16 32 63 125 248 492 976 1936 3840 7617 ...
n= 7, heptanacci -> 1 1 2 4 8 16 32 64 127 253 504 1004 2000 3984 7936 ...
n= 8,  octonacci -> 1 1 2 4 8 16 32 64 128 255 509 1016 2028 4048 8080 ...
n= 9,  nonanacci -> 1 1 2 4 8 16 32 64 128 256 511 1021 2040 4076 8144 ...
n=10,  decanacci -> 1 1 2 4 8 16 32 64 128 256 512 1023 2045 4088 8172 ...
>>> "
gr94,python,Fibonacci sequence,Mathematics,Mathematical Sequences and Series,"from math import *
 
def analytic_fibonacci(n):
  sqrt_5 = sqrt(5);
  p = (1 + sqrt_5) / 2;
  q = 1/p;
  return int( (p**n + q**n) / sqrt_5 + 0.5 )
 
for i in range(1,31):
  print analytic_fibonacci(i),"
bjwj,python,Fibonacci word,Mathematics,Combinatorics,">>> import math
>>> from collections import Counter
>>> 
>>> def entropy(s):
...     p, lns = Counter(s), float(len(s))
...     return -sum( count/lns * math.log(count/lns, 2) for count in p.values())
... 
>>> 
>>> def fibword(nmax=37):
...     fwords = ['1', '0']
...     print('%-3s %10s %-10s %s' % tuple('N Length Entropy Fibword'.split()))
...     def pr(n, fwords):
...         while len(fwords) < n:
...             fwords += [''.join(fwords[-2:][::-1])]
...         v = fwords[n-1]
...         print('%3i %10i %10.7g %s' % (n, len(v), entropy(v), v if len(v) < 20 else '<too long>'))
...     for n in range(1, nmax+1): pr(n, fwords)
... 
>>> fibword()
N       Length Entropy    Fibword
  1          1         -0 1
  2          1         -0 0
  3          2          1 01
  4          3  0.9182958 010
  5          5  0.9709506 01001
  6          8   0.954434 01001010
  7         13  0.9612366 0100101001001
  8         21  0.9587119 <too long>
  9         34  0.9596869 <too long>
 10         55   0.959316 <too long>
 11         89  0.9594579 <too long>
 12        144  0.9594038 <too long>
 13        233  0.9594244 <too long>
 14        377  0.9594165 <too long>
 15        610  0.9594196 <too long>
 16        987  0.9594184 <too long>
 17       1597  0.9594188 <too long>
 18       2584  0.9594187 <too long>
 19       4181  0.9594187 <too long>
 20       6765  0.9594187 <too long>
 21      10946  0.9594187 <too long>
 22      17711  0.9594187 <too long>
 23      28657  0.9594187 <too long>
 24      46368  0.9594187 <too long>
 25      75025  0.9594187 <too long>
 26     121393  0.9594187 <too long>
 27     196418  0.9594187 <too long>
 28     317811  0.9594187 <too long>
 29     514229  0.9594187 <too long>
 30     832040  0.9594187 <too long>
 31    1346269  0.9594187 <too long>
 32    2178309  0.9594187 <too long>
 33    3524578  0.9594187 <too long>
 34    5702887  0.9594187 <too long>
 35    9227465  0.9594187 <too long>
 36   14930352  0.9594187 <too long>
 37   24157817  0.9594187 <too long>
>>> "
zafz,python,Fibonacci word/fractal,Puzzles and Games,Simulation and Modeling,"from functools import wraps
from turtle import *
 
def memoize(obj):
    cache = obj.cache = {}
    @wraps(obj)
    def memoizer(*args, **kwargs):
        key = str(args) + str(kwargs)
        if key not in cache:
            cache[key] = obj(*args, **kwargs)
        return cache[key]
    return memoizer
 
@memoize
def fibonacci_word(n):
    assert n > 0
    if n == 1:
        return ""1""
    if n == 2:
        return ""0""
    return fibonacci_word(n - 1) + fibonacci_word(n - 2)
 
def draw_fractal(word, step):
    for i, c in enumerate(word, 1):
        forward(step)
        if c == ""0"":
            if i % 2 == 0:
                left(90)
            else:
                right(90)
 
def main():
    n = 25 # Fibonacci Word to use.
    step = 1 # Segment length.
    width = 1050 # Width of plot area.
    height = 1050 # Height of plot area.
    w = fibonacci_word(n)
 
    setup(width=width, height=height)
    speed(0)
    setheading(90)
    left(90)
    penup()
    forward(500)
    right(90)
    backward(500)
    pendown()
    tracer(10000)
    hideturtle()
 
    draw_fractal(w, step)
 
    # Save Poscript image.
    getscreen().getcanvas().postscript(file=""fibonacci_word_fractal.eps"")
    exitonclick()
 
if __name__ == '__main__':
    main()"
494o,python,File extension is in extensions list,Systems Programming and File I/O,File Operations," 
def isExt(fileName, extensions):
  return True in map(fileName.lower().endswith, (""."" + e.lower() for e in extensions))
 "
fadi,python,File input/output,Systems Programming and File I/O,File Operations,"import shutil
shutil.copyfile('input.txt', 'output.txt')"
49mw,python,File modification time,Systems Programming and File I/O,File Operations,"import os
 
#Get modification time:
modtime = os.path.getmtime('filename')
 
#Set the access and modification times:
os.utime('path', (actime, mtime))
 
#Set just the modification time:
os.utime('path', (os.path.getatime('path'), mtime))
 
#Set the access and modification times to the current time:
os.utime('path', None)"
mkrg,python,File size,Systems Programming and File I/O,File Operations,"import os
 
size = os.path.getsize('input.txt')
size = os.path.getsize('/input.txt')"
wmk1,python,File size distribution,Systems Programming and File I/O,File Operations,"import sys, os
from collections import Counter
 
def dodir(path):
    global h
 
    for name in os.listdir(path):
        p = os.path.join(path, name)
 
        if os.path.islink(p):
            pass
        elif os.path.isfile(p):
            h[os.stat(p).st_size] += 1
        elif os.path.isdir(p):
            dodir(p)
        else:
            pass
 
def main(arg):
    global h
    h = Counter()
    for dir in arg:
        dodir(dir)
 
    s = n = 0
    for k, v in sorted(h.items()):
        print(""Size %d -> %d file(s)"" % (k, v))
        n += v
        s += k * v
    print(""Total %d bytes for %d files"" % (s, n))
 
main(sys.argv[1:])"
0fyp,python,Filter,Algorithms and Data Structures,Algorithms,"values = range(10)
evens = [x for x in values if not x & 1]
ievens = (x for x in values if not x & 1) # lazy
# alternately but less idiomatic:
evens = filter(lambda x: not x & 1, values)"
k5r0,python,Find Chess960 starting position identifier,Puzzles and Games,Puzzle Solving Algorithms," 
# optional, but task function depends on it as written
def validate_position(candidate: str):
    assert (
        len(candidate) == 8
    ), f""candidate position has invalide len = {len(candidate)}""
 
    valid_pieces = {""R"": 2, ""N"": 2, ""B"": 2, ""Q"": 1, ""K"": 1}
    assert {
        piece for piece in candidate
    } == valid_pieces.keys(), f""candidate position contains invalid pieces""
    for piece_type in valid_pieces.keys():
        assert (
            candidate.count(piece_type) == valid_pieces[piece_type]
        ), f""piece type '{piece_type}' has invalid count""
 
    bishops_pos = [index for index, value in enumerate(candidate) if value == ""B""]
    assert (
        bishops_pos[0] % 2 != bishops_pos[1] % 2
    ), f""candidate position has both bishops in the same color""
 
    assert [piece for piece in candidate if piece in ""RK""] == [
        ""R"",
        ""K"",
        ""R"",
    ], ""candidate position has K outside of RR""
 
 
def calc_position(start_pos: str):
    try:
        validate_position(start_pos)
    except AssertionError:
        raise AssertionError
    # step 1
    subset_step1 = [piece for piece in start_pos if piece not in ""QB""]
    nights_positions = [
        index for index, value in enumerate(subset_step1) if value == ""N""
    ]
    nights_table = {
        (0, 1): 0,
        (0, 2): 1,
        (0, 3): 2,
        (0, 4): 3,
        (1, 2): 4,
        (1, 3): 5,
        (1, 4): 6,
        (2, 3): 7,
        (2, 4): 8,
        (3, 4): 9,
    }
    N = nights_table.get(tuple(nights_positions))
 
    # step 2
    subset_step2 = [piece for piece in start_pos if piece != ""N""]
    Q = subset_step2.index(""Q"")
 
    # step 3
    dark_squares = [
        piece for index, piece in enumerate(start_pos) if index in range(0, 9, 2)
    ]
    light_squares = [
        piece for index, piece in enumerate(start_pos) if index in range(1, 9, 2)
    ]
    D = dark_squares.index(""B"")
    L = light_squares.index(""B"")
 
    return 4 * (4 * (6*N + Q) + D) + L
 "
fjzi,python,Find common directory path,Operating Systems and Shell Programming,File Operations,">>> import os
>>> os.path.commonpath(['/home/user1/tmp/coverage/test', 
                        '/home/user1/tmp/covert/operator', '/home/user1/tmp/coven/members'])
'/home/user1/tmp'"
zubk,python,Find duplicate files,Systems Programming and File I/O,File Operations,"from __future__ import print_function
import os
import hashlib
import datetime
 
def FindDuplicateFiles(pth, minSize = 0, hashName = ""md5""):
    knownFiles = {}
 
    #Analyse files
    for root, dirs, files in os.walk(pth):
        for fina in files:
            fullFina = os.path.join(root, fina)
            isSymLink = os.path.islink(fullFina)
            if isSymLink:
                continue # Skip symlinks
            si = os.path.getsize(fullFina)
            if si < minSize:
                continue
            if si not in knownFiles:
                knownFiles[si] = {}
            h = hashlib.new(hashName)
            h.update(open(fullFina, ""rb"").read())
            hashed = h.digest()
            if hashed in knownFiles[si]:
                fileRec = knownFiles[si][hashed]
                fileRec.append(fullFina)
            else:
                knownFiles[si][hashed] = [fullFina]
 
    #Print result
    sizeList = list(knownFiles.keys())
    sizeList.sort(reverse=True)
    for si in sizeList:
        filesAtThisSize = knownFiles[si]
        for hashVal in filesAtThisSize:
            if len(filesAtThisSize[hashVal]) < 2:
                continue
            fullFinaLi = filesAtThisSize[hashVal]
            print (""=======Duplicate======="")
            for fullFina in fullFinaLi:
                st = os.stat(fullFina)
                isHardLink = st.st_nlink > 1 
                infoStr = []
                if isHardLink:
                    infoStr.append(""(Hard linked)"")
                fmtModTime = datetime.datetime.utcfromtimestamp(st.st_mtime).strftime('%Y-%m-%dT%H:%M:%SZ')
                print (fmtModTime, si, os.path.relpath(fullFina, pth), "" "".join(infoStr))
 
if __name__==""__main__"":
 
    FindDuplicateFiles('/home/tim/Dropbox', 1024*1024)
 "
pzf1,python,Find if a point is within a triangle,Mathematics,Geometry and Trigonometry," 
"""""" find if point is in a triangle """"""
 
from sympy.geometry import Point, Triangle
 
def sign(pt1, pt2, pt3):
    """""" which side of plane cut by line (pt2, pt3) is pt1 on? """"""
    return (pt1.x - pt3.x) * (pt2.y - pt3.y) - (pt2.x - pt3.x) * (pt1.y - pt3.y)
 
 
def iswithin(point, pt1, pt2, pt3):
    """""" 
    Determine if point is within triangle formed by points p1, p2, p3.
    If so, the point will be on the same side of each of the half planes
    defined by vectors p1p2, p2p3, and p3p1. zval is positive if outside,
    negative if inside such a plane. All should be positive or all negative
    if point is within the triangle.
    """"""
    zval1 = sign(point, pt1, pt2)
    zval2 = sign(point, pt2, pt3)
    zval3 = sign(point, pt3, pt1)
    notanyneg = zval1 >= 0 and zval2 >= 0 and zval3 >= 0
    notanypos = zval1 <= 0 and zval2 <= 0 and zval3 <= 0
    return notanyneg or notanypos
 
if __name__ == ""__main__"":
    POINTS = [Point(0, 0)]
    TRI = Triangle(Point(1.5, 2.4), Point(5.1, -3.1), Point(-3.8, 0.5))
    for pnt in POINTS:
        a, b, c = TRI.vertices
        isornot = ""is"" if iswithin(pnt, a, b, c) else ""is not""
        print(""Point"", pnt, isornot, ""within the triangle"", TRI)
 "
2zyg,python,Find largest left truncatable prime in a given base,Mathematics,Number Theory,"import random
 
def is_probable_prime(n,k):
    #this uses the miller-rabin primality test found from rosetta code
    if n==0 or n==1:
        return False
    if n==2:
        return True
    if n % 2 == 0:
        return False
    s = 0
    d = n-1
 
    while True:
        quotient, remainder = divmod(d, 2)
        if remainder == 1:
            break
        s += 1
        d = quotient
 
    def try_composite(a):
        if pow(a, d, n) == 1:
            return False
        for i in range(s):
            if pow(a, 2**i * d, n) == n-1:
                return False
        return True # n is definitely composite
 
    for i in range(k):
        a = random.randrange(2, n)
        if try_composite(a):
            return False
 
    return True # no base tested showed n as composite    
 
 
def largest_left_truncatable_prime(base):    
    radix = 0
    candidates = [0]
    while True:
        new_candidates=[]
        multiplier = base**radix
        for i in range(1,base):
            new_candidates += [x+i*multiplier for x in candidates if is_probable_prime(x+i*multiplier,30)]
        if len(new_candidates)==0:
            return max(candidates)
        candidates = new_candidates
        radix += 1
 
for b in range(3,24):
    print(""%d:%d\n"" % (b,largest_left_truncatable_prime(b)))
 "
bqn4,python,Find limit of recursion,Programming Concepts,Fundamentals,"import sys
print(sys.getrecursionlimit())"
xgqp,python,Find palindromic numbers in both binary and ternary bases,Mathematics,Number Theory,"from itertools import islice
 
digits = ""0123456789abcdefghijklmnopqrstuvwxyz""
 
def baseN(num,b):
  if num == 0: return ""0""
  result = """"
  while num != 0:
    num, d = divmod(num, b)
    result += digits[d]
  return result[::-1] # reverse
 
def pal2(num):
    if num == 0 or num == 1: return True
    based = bin(num)[2:]
    return based == based[::-1]
 
def pal_23():
    yield 0
    yield 1
    n = 1
    while True:
        n += 1
        b = baseN(n, 3)
        revb = b[::-1]
        #if len(b) > 12: break
        for trial in ('{0}{1}'.format(b, revb), '{0}0{1}'.format(b, revb),
                      '{0}1{1}'.format(b, revb), '{0}2{1}'.format(b, revb)):
            t = int(trial, 3)
            if pal2(t):
                yield t
 
for pal23 in islice(pal_23(), 6):
    print(pal23, baseN(pal23, 3), baseN(pal23, 2))"
fvks,python,Find the intersection of a line with a plane,Mathematics,Geometry and Trigonometry,"#!/bin/python
from __future__ import print_function
import numpy as np
 
def LinePlaneCollision(planeNormal, planePoint, rayDirection, rayPoint, epsilon=1e-6):
 
	ndotu = planeNormal.dot(rayDirection)
	if abs(ndotu) < epsilon:
		raise RuntimeError(""no intersection or line is within plane"")
 
	w = rayPoint - planePoint
	si = -planeNormal.dot(w) / ndotu
	Psi = w + si * rayDirection + planePoint
	return Psi
 
 
if __name__==""__main__"":
	#Define plane
	planeNormal = np.array([0, 0, 1])
	planePoint = np.array([0, 0, 5]) #Any point on the plane
 
	#Define ray
	rayDirection = np.array([0, -1, -1])
	rayPoint = np.array([0, 0, 10]) #Any point along the ray
 
	Psi = LinePlaneCollision(planeNormal, planePoint, rayDirection, rayPoint)
	print (""intersection at"", Psi)"
ub5a,python,Find the intersection of two lines,Mathematics,Geometry and Trigonometry,"def line_intersect(Ax1, Ay1, Ax2, Ay2, Bx1, By1, Bx2, By2):
    """""" returns a (x, y) tuple or None if there is no intersection """"""
    d = (By2 - By1) * (Ax2 - Ax1) - (Bx2 - Bx1) * (Ay2 - Ay1)
    if d:
        uA = ((Bx2 - Bx1) * (Ay1 - By1) - (By2 - By1) * (Ax1 - Bx1)) / d
        uB = ((Ax2 - Ax1) * (Ay1 - By1) - (Ay2 - Ay1) * (Ax1 - Bx1)) / d
    else:
        return
    if not(0 <= uA <= 1 and 0 <= uB <= 1):
        return
    x = Ax1 + uA * (Ax2 - Ax1)
    y = Ay1 + uA * (Ay2 - Ay1)
 
    return x, y
 
if __name__ == '__main__':
    (a, b), (c, d) = (4, 0), (6, 10)  # try (4, 0), (6, 4)
    (e, f), (g, h) = (0, 3), (10, 7)  # for non intersecting test
    pt = line_intersect(a, b, c, d, e, f, g, h)
    print(pt)"
7wyx,python,Find the last Sunday of each month,Mathematics,Probability and Statistics," 
import sys
import calendar
 
year = 2013
if len(sys.argv) > 1:
    try:
        year = int(sys.argv[-1])
    except ValueError:
        pass
 
for month in range(1, 13):
    last_sunday = max(week[-1] for week in calendar.monthcalendar(year, month))
    print('{}-{}-{:2}'.format(year, calendar.month_abbr[month], last_sunday))
 "
6ntn,python,Find the missing permutation,Puzzles and Games,Logic and Mathematical Puzzles,"from itertools import permutations
 
given = '''ABCD CABD ACDB DACB BCDA ACBD ADCB CDAB DABC BCAD CADB CDBA
           CBAD ABDC ADBC BDCA DCBA BACD BADC BDAC CBDA DBCA DCAB'''.split()
 
allPerms = [''.join(x) for x in permutations(given[0])]
 
missing = list(set(allPerms) - set(given)) # ['DBAC']"
aqri,python,First class environments,Programming Concepts,Advanced Concepts,"environments = [{'cnt':0, 'seq':i+1} for i in range(12)]
 
code = '''
print('% 4d' % seq, end='')
if seq != 1:
    cnt += 1
    seq = 3 * seq + 1 if seq & 1 else seq // 2
'''
 
while any(env['seq'] > 1 for env in environments):
    for env in environments:
        exec(code, globals(), env)
    print()
 
print('Counts')
for env in environments:
    print('% 4d' % env['cnt'], end='')
print()"
botm,python,First perfect square in base n with n unique digits,Mathematics,Number Theory,"'''Perfect squares using every digit in a given base.'''
 
from itertools import count, dropwhile, repeat
from math import ceil, sqrt
from time import time
 
 
# allDigitSquare :: Int -> Int -> Int
def allDigitSquare(base, above):
    '''The lowest perfect square which
       requires all digits in the given base.
    '''
    bools = list(repeat(True, base))
    return next(
        dropwhile(
            missingDigitsAtBase(base, bools),
            count(
                max(
                    above,
                    ceil(sqrt(int(
                        '10' + '0123456789abcdef'[2:base],
                        base
                    )))
                )
            )
        )
    )
 
 
# missingDigitsAtBase :: Int -> [Bool] -> Int -> Bool
def missingDigitsAtBase(base, bools):
    '''Fusion of representing the square of integer N at a
       given base with checking whether all digits of
       that base contribute to N^2.
       Clears the bool at a digit position to False when used.
       True if any positions remain uncleared (unused).
    '''
    def go(x):
        xs = bools.copy()
        while x:
            xs[x % base] = False
            x //= base
        return any(xs)
    return lambda n: go(n * n)
 
 
# digit :: Int -> Char
def digit(n):
    '''Digit character for given integer.'''
    return '0123456789abcdef'[n]
 
 
# ------------------------- TEST -------------------------
# main :: IO ()
def main():
    '''Smallest perfect squares using all digits in bases 2-16'''
 
    start = time()
 
    print(main.__doc__ + ':\n\nBase      Root    Square')
    q = 0
    for b in enumFromTo(2)(16):
        q = allDigitSquare(b, q)
        print(
            str(b).rjust(2, ' ') + ' -> ' +
            showIntAtBase(b)(digit)(q)('').rjust(8, ' ') +
            ' -> ' +
            showIntAtBase(b)(digit)(q * q)('')
        )
 
    print(
        '\nc. ' + str(ceil(time() - start)) + ' seconds.'
    )
 
 
# ----------------------- GENERIC ------------------------
 
# enumFromTo :: (Int, Int) -> [Int]
def enumFromTo(m):
    '''Integer enumeration from m to n.'''
    return lambda n: list(range(m, 1 + n))
 
 
# showIntAtBase :: Int -> (Int -> String) -> Int -> 
# String -> String
def showIntAtBase(base):
    '''String representation of an integer in a given base,
       using a supplied function for the string representation
       of digits.
    '''
    def wrap(toChr, n, rs):
        def go(nd, r):
            n, d = nd
            r_ = toChr(d) + r
            return go(divmod(n, base), r_) if 0 != n else r_
        return 'unsupported base' if 1 >= base else (
            'negative number' if 0 > n else (
                go(divmod(n, base), rs))
        )
    return lambda toChr: lambda n: lambda rs: (
        wrap(toChr, n, rs)
    )
 
 
# MAIN ---
if __name__ == '__main__':
    main()
 "
ulvd,python,First power of 2 that has leading decimal digits of 12,Mathematics,Number Theory,"from math import log, modf, floor
 
def p(l, n, pwr=2):
    l = int(abs(l))
    digitcount = floor(log(l, 10))
    log10pwr = log(pwr, 10)
    raised, found = -1, 0
    while found < n:
        raised += 1
        firstdigits = floor(10**(modf(log10pwr * raised)[0] + digitcount))
        if firstdigits == l:
            found += 1
    return raised
 
 
if __name__ == '__main__':
    for l, n in [(12, 1), (12, 2), (123, 45), (123, 12345), (123, 678910)]:
        print(f""p({l}, {n}) ="", p(l, n))"
xpdd,python,First-class functions,Programming Concepts,Fundamentals,">>> # Some built in functions and their inverses
>>> from math import sin, cos, acos, asin
>>> # Add a user defined function and its inverse
>>> cube = lambda x: x * x * x
>>> croot = lambda x: x ** (1/3.0)
>>> # First class functions allow run-time creation of functions from functions
>>> # return function compose(f,g)(x) == f(g(x))
>>> compose = lambda f1, f2: ( lambda x: f1(f2(x)) )
>>> # first class functions should be able to be members of collection types
>>> funclist = [sin, cos, cube]
>>> funclisti = [asin, acos, croot]
>>> # Apply functions from lists as easily as integers
>>> [compose(inversef, f)(.5) for f, inversef in zip(funclist, funclisti)]
[0.5, 0.4999999999999999, 0.5]
>>>"
5nro,python,First-class functions/Use numbers analogously,Programming Concepts,Fundamentals,"IDLE 2.6.1      
>>> # Number literals
>>> x,xi, y,yi = 2.0,0.5, 4.0,0.25
>>> # Numbers from calculation
>>> z  = x + y
>>> zi = 1.0 / (x + y)
>>> # The multiplier function is similar to 'compose' but with numbers
>>> multiplier = lambda n1, n2: (lambda m: n1 * n2 * m)
>>> # Numbers as members of collections
>>> numlist = [x, y, z]
>>> numlisti = [xi, yi, zi]
>>> # Apply numbers from list
>>> [multiplier(inversen, n)(.5) for n, inversen in zip(numlist, numlisti)]
[0.5, 0.5, 0.5]
>>>"
tj17,python,Five weekends,Mathematics,Combinatorics,"from datetime import timedelta, date
 
DAY     = timedelta(days=1)
START, STOP = date(1900, 1, 1), date(2101, 1, 1)
WEEKEND = {6, 5, 4}     # Sunday is day 6
FMT     = '%Y %m(%B)'
 
def fiveweekendspermonth(start=START, stop=STOP):
    'Compute months with five weekends between dates'
 
    when = start
    lastmonth = weekenddays = 0
    fiveweekends = []
    while when < stop:
        year, mon, _mday, _h, _m, _s, wday, _yday, _isdst = when.timetuple()
        if mon != lastmonth:
            if weekenddays >= 15:
                fiveweekends.append(when - DAY)
            weekenddays = 0
            lastmonth = mon
        if wday in WEEKEND:
            weekenddays += 1
        when += DAY
    return fiveweekends
 
dates = fiveweekendspermonth()
indent = '  '
print('There are %s months of which the first and last five are:' % len(dates))
print(indent +('\n'+indent).join(d.strftime(FMT) for d in dates[:5]))
print(indent +'...')
print(indent +('\n'+indent).join(d.strftime(FMT) for d in dates[-5:]))
 
print('\nThere are %i years in the range that do not have months with five weekends'
      % len(set(range(START.year, STOP.year)) - {d.year for d in dates}))"
lvo3,python,Fivenum,Mathematics,Probability and Statistics,"from __future__ import division
import math
import sys
 
def fivenum(array):
    n = len(array)
    if n == 0:
        print(""you entered an empty array."")
        sys.exit()
    x = sorted(array)
 
    n4 = math.floor((n+3.0)/2.0)/2.0
    d = [1, n4, (n+1)/2, n+1-n4, n]
    sum_array = []
 
    for e in range(5):
        floor = int(math.floor(d[e] - 1))
        ceil = int(math.ceil(d[e] - 1))
        sum_array.append(0.5 * (x[floor] + x[ceil]))
 
    return sum_array
 
x = [0.14082834, 0.09748790, 1.73131507, 0.87636009, -1.95059594, 0.73438555, -0.03035726, 1.46675970,
-0.74621349, -0.72588772, 0.63905160, 0.61501527, -0.98983780, -1.00447874, -0.62759469, 0.66206163,
1.04312009, -0.10305385, 0.75775634, 0.32566578]
 
y = fivenum(x)
print(y)"
1w0a,python,Fixed length records,Systems Programming and File I/O,File Operations," 
infile = open('infile.dat', 'rb')
outfile = open('outfile.dat', 'wb')
 
while True:
    onerecord = infile.read(80)
    if len(onerecord) < 80:
        break
    onerecordreversed = bytes(reversed(onerecord))
    outfile.write(onerecordreversed)
 
infile.close()
outfile.close()
 "
sl0k,python,FizzBuzz,Puzzles and Games,Logic and Mathematical Puzzles,"for i in xrange(1, 101):
    if i % 15 == 0:
        print ""FizzBuzz""
    elif i % 3 == 0:
        print ""Fizz""
    elif i % 5 == 0:
        print ""Buzz""
    else:
        print i"
wk6r,python,Flatten a list,Algorithms and Data Structures,Algorithms,">>> def flatten(lst):
	return sum( ([x] if not isinstance(x, list) else flatten(x)
		     for x in lst), [] )
 
>>> lst = [[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]
>>> flatten(lst)
[1, 2, 3, 4, 5, 6, 7, 8]"
f30o,python,Flipping bits game,Puzzles and Games,Game Development,"""""""
Given a %i by %i sqare array of zeroes or ones in an initial
configuration, and a target configuration of zeroes and ones
The task is to transform one to the other in as few moves as 
possible by inverting whole numbered rows or whole lettered 
columns at once.
In an inversion any 1 becomes 0 and any 0 becomes 1 for that
whole row or column.
 
""""""
 
from random import randrange
from copy import deepcopy
from string import ascii_lowercase
 
 
try:    # 2to3 fix
    input = raw_input
except:
    pass
 
N = 3   # N x N Square arrray
 
board  = [[0]* N for i in range(N)]
 
def setbits(board, count=1):
    for i in range(count):
        board[randrange(N)][randrange(N)] ^= 1
 
def shuffle(board, count=1):
    for i in range(count):
        if randrange(0, 2):
            fliprow(randrange(N))
        else:
            flipcol(randrange(N))
 
 
def pr(board, comment=''):
    print(str(comment))
    print('     ' + ' '.join(ascii_lowercase[i] for i in range(N)))
    print('  ' + '\n  '.join(' '.join(['%2s' % j] + [str(i) for i in line])
                             for j, line in enumerate(board, 1)))
 
def init(board):
    setbits(board, count=randrange(N)+1)
    target = deepcopy(board)
    while board == target:
        shuffle(board, count=2 * N)
    prompt = '  X, T, or 1-%i / %s-%s to flip: ' % (N, ascii_lowercase[0], 
                                                    ascii_lowercase[N-1])
    return target, prompt
 
def fliprow(i):
    board[i-1][:] = [x ^ 1 for x in board[i-1] ]
 
def flipcol(i):
    for row in board:
        row[i] ^= 1
 
if __name__ == '__main__':
    print(__doc__ % (N, N))
    target, prompt = init(board)
    pr(target, 'Target configuration is:')
    print('')
    turns = 0
    while board != target:
        turns += 1
        pr(board, '%i:' % turns)
        ans = input(prompt).strip()
        if (len(ans) == 1 
            and ans in ascii_lowercase and ascii_lowercase.index(ans) < N):
            flipcol(ascii_lowercase.index(ans))
        elif ans and all(ch in '0123456789' for ch in ans) and 1 <= int(ans) <= N:
            fliprow(int(ans))
        elif ans == 'T':
            pr(target, 'Target configuration is:')
            turns -= 1
        elif ans == 'X':
            break
        else:
            print(""  I don't understand %r... Try again. ""
                  ""(X to exit or T to show target)\n"" % ans[:9])
            turns -= 1
    else:
        print('\nWell done!\nBye.')"
ncju,python,Flow-control structures,Programming Concepts,Fundamentals,"# Search for an odd factor of a using brute force:
for i in range(n):
    if (n%2) == 0:
        continue
    if (n%i) == 0:
        result = i
        break
else:
    result = None
    print ""No odd factors found"""
tkub,python,Floyd's triangle,Puzzles and Games,Logic and Mathematical Puzzles,">>> def floyd(rowcount=5):
	rows = [[1]]
	while len(rows) < rowcount:
		n = rows[-1][-1] + 1
		rows.append(list(range(n, n + len(rows[-1]) + 1)))
	return rows
 
>>> floyd()
[[1], [2, 3], [4, 5, 6], [7, 8, 9, 10], [11, 12, 13, 14, 15]]
>>> def pfloyd(rows=[[1], [2, 3], [4, 5, 6], [7, 8, 9, 10]]):
	colspace = [len(str(n)) for n in rows[-1]]
	for row in rows:
		print( ' '.join('%*i' % space_n for space_n in zip(colspace, row)))
 
 
>>> pfloyd()
1
2 3
4 5 6
7 8 9 10
>>> pfloyd(floyd(5))
 1
 2  3
 4  5  6
 7  8  9 10
11 12 13 14 15
>>> pfloyd(floyd(14))
 1
 2  3
 4  5  6
 7  8  9 10
11 12 13 14 15
16 17 18 19 20 21
22 23 24 25 26 27 28
29 30 31 32 33 34 35 36
37 38 39 40 41 42 43 44  45
46 47 48 49 50 51 52 53  54  55
56 57 58 59 60 61 62 63  64  65  66
67 68 69 70 71 72 73 74  75  76  77  78
79 80 81 82 83 84 85 86  87  88  89  90  91
92 93 94 95 96 97 98 99 100 101 102 103 104 105
>>> "
zk5x,python,Floyd-Warshall algorithm,Algorithms and Data Structures,Algorithms,"from math import inf
from itertools import product
 
def floyd_warshall(n, edge):
    rn = range(n)
    dist = [[inf] * n for i in rn]
    nxt  = [[0]   * n for i in rn]
    for i in rn:
        dist[i][i] = 0
    for u, v, w in edge:
        dist[u-1][v-1] = w
        nxt[u-1][v-1] = v-1
    for k, i, j in product(rn, repeat=3):
        sum_ik_kj = dist[i][k] + dist[k][j]
        if dist[i][j] > sum_ik_kj:
            dist[i][j] = sum_ik_kj
            nxt[i][j]  = nxt[i][k]
    print(""pair     dist    path"")
    for i, j in product(rn, repeat=2):
        if i != j:
            path = [i]
            while path[-1] != j:
                path.append(nxt[path[-1]][j])
            print(""%d → %d  %4d       %s"" 
                  % (i + 1, j + 1, dist[i][j], 
                     ' → '.join(str(p + 1) for p in path)))
 
if __name__ == '__main__':
    floyd_warshall(4, [[1, 3, -2], [2, 1, 4], [2, 3, 3], [3, 4, 2], [4, 2, -1]])"
4p8g,python,Forest fire,Puzzles and Games,Simulation and Modeling,"'''
Forest-Fire Cellular automation
 See: http://en.wikipedia.org/wiki/Forest-fire_model
'''
 
L = 15
# d = 2 # Fixed
initial_trees = 0.55
p = 0.01
f = 0.001
 
try:
    raw_input
except:
    raw_input = input
 
import random
 
 
tree, burning, space = 'TB.'
hood = ((-1,-1), (-1,0), (-1,1),
        (0,-1),          (0, 1),
        (1,-1),  (1,0),  (1,1))
 
def initialise():
    grid = {(x,y): (tree if random.random()<= initial_trees else space)
            for x in range(L)
            for y in range(L) }
    return grid
 
def gprint(grid):
    txt = '\n'.join(''.join(grid[(x,y)] for x in range(L))
                    for y in range(L))
    print(txt)
 
def quickprint(grid):
    t = b = 0
    ll = L * L
    for x in range(L):
        for y in range(L):
            if grid[(x,y)] in (tree, burning):
                t += 1
                if grid[(x,y)] == burning:
                    b += 1
    print(('Of %6i cells, %6i are trees of which %6i are currently burning.'
          + ' (%6.3f%%, %6.3f%%)')
          % (ll, t, b, 100. * t / ll, 100. * b / ll))
 
 
def gnew(grid):
    newgrid = {}
    for x in range(L):
        for y in range(L):
            if grid[(x,y)] == burning:
                newgrid[(x,y)] = space
            elif grid[(x,y)] == space:
                newgrid[(x,y)] = tree if random.random()<= p else space
            elif grid[(x,y)] == tree:
                newgrid[(x,y)] = (burning
                                   if any(grid.get((x+dx,y+dy),space) == burning
                                            for dx,dy in hood)
                                        or random.random()<= f 
                                   else tree)
    return newgrid
 
if __name__ == '__main__':
    grid = initialise()
    iter = 0
    while True:
        quickprint(grid)
        inp = raw_input('Print/Quit/<int>/<return> %6i: ' % iter).lower().strip()
        if inp:
            if inp[0] == 'p':
                gprint(grid)
            elif inp.isdigit():
                for i in range(int(inp)):
                    iter +=1
                    grid = gnew(grid)
                    quickprint(grid)
            elif inp[0] == 'q':
                break
        grid = gnew(grid)
        iter +=1"
65a4,python,Fork,Operating Systems and Shell Programming,Operating System Concepts,"import os
 
pid = os.fork()
if pid > 0:
 # parent code
else:
 # child code"
9lff,python,Formal power series,Mathematics,Mathematical Sequences and Series,"''' \
For a discussion on pipe() and head() see
  http://paddy3118.blogspot.com/2009/05/pipe-fitting-with-python-generators.html
'''
 
from itertools import islice
from fractions import Fraction
from functools import reduce
try:
    from itertools import izip as zip # for 2.6
except:
    pass
 
def head(n):
    ''' return a generator that passes through at most n items
    '''
    return lambda seq: islice(seq, n)
 
def pipe(gen, *cmds):
    ''' pipe(a,b,c,d, ...) -> yield from ...d(c(b(a)))
    '''
    return reduce(lambda gen, cmd: cmd(gen), cmds, gen)
 
def sinepower():
    n = 0
    fac = 1
    sign = +1
    zero = 0
    yield zero
    while True:
        n +=1
        fac *= n
        yield Fraction(1, fac*sign)
        sign = -sign
        n +=1
        fac *= n
        yield zero
def cosinepower():
    n = 0
    fac = 1
    sign = +1
    yield Fraction(1,fac)
    zero = 0
    while True:
        n +=1
        fac *= n
        yield zero
        sign = -sign
        n +=1
        fac *= n
        yield Fraction(1, fac*sign)
def pluspower(*powergenerators):
    for elements in zip(*powergenerators):
        yield sum(elements)
def minuspower(*powergenerators):
    for elements in zip(*powergenerators):
        yield elements[0] - sum(elements[1:])
def mulpower(fgen,ggen):
    'From: http://en.wikipedia.org/wiki/Power_series#Multiplication_and_division'
    a,b = [],[]
    for f,g in zip(fgen, ggen):
        a.append(f)
        b.append(g)
        yield sum(f*g for f,g in zip(a, reversed(b)))
def constpower(n):
    yield n
    while True:
        yield 0
def diffpower(gen):
    'differentiatiate power series'
    next(gen)
    for n, an in enumerate(gen, start=1):
        yield an*n
def intgpower(k=0):
    'integrate power series with constant k'
    def _intgpower(gen):
        yield k
        for n, an in enumerate(gen, start=1):
            yield an * Fraction(1,n)
    return _intgpower
 
 
print(""cosine"")
c = list(pipe(cosinepower(), head(10)))
print(c)
print(""sine"")
s = list(pipe(sinepower(), head(10)))
print(s)
# integrate cosine
integc = list(pipe(cosinepower(),intgpower(0), head(10)))
# 1 - (integrate sine)
integs1 = list(minuspower(pipe(constpower(1), head(10)),
                          pipe(sinepower(),intgpower(0), head(10))))
 
assert s == integc, ""The integral of cos should be sin""
assert c == integs1, ""1 minus the integral of sin should be cos"""
n5b9,python,Formatted numeric output,Text Processing,String Manipulation,"from math import pi, exp
r = exp(pi)-pi
print r
print ""e=%e f=%f g=%g G=%G s=%s r=%r!""%(r,r,r,r,r,r)
print ""e=%9.4e f=%9.4f g=%9.4g!""%(-r,-r,-r)
print ""e=%9.4e f=%9.4f g=%9.4g!""%(r,r,r)
print ""e=%-9.4e f=%-9.4f g=%-9.4g!""%(r,r,r)
print ""e=%09.4e f=%09.4f g=%09.4g!""%(-r,-r,-r)
print ""e=%09.4e f=%09.4f g=%09.4g!""%(r,r,r)
print ""e=%-09.4e f=%-09.4f g=%-09.4g!""%(r,r,r)"
rlgu,python,Fortunate numbers,Mathematics,Number Theory,"from sympy.ntheory.generate import primorial
from sympy.ntheory import isprime
 
def fortunate_number(n):
    '''Return the fortunate number for positive integer n.'''
    # Since primorial(n) is even for all positive integers n,
    # it suffices to search for the fortunate numbers among odd integers.
    i = 3
    primorial_ = primorial(n)
    while True:
        if isprime(primorial_ + i):
            return i
        i += 2
 
fortunate_numbers = set()
for i in range(1, 76):
    fortunate_numbers.add(fortunate_number(i))
 
# Extract the first 50 numbers.
first50 = sorted(list(fortunate_numbers))[:50]
 
print('The first 50 fortunate numbers:')
print(('{:<3} ' * 10).format(*(first50[:10])))
print(('{:<3} ' * 10).format(*(first50[10:20])))
print(('{:<3} ' * 10).format(*(first50[20:30])))
print(('{:<3} ' * 10).format(*(first50[30:40])))
print(('{:<3} ' * 10).format(*(first50[40:])))"
v2l7,python,Forward difference,Mathematics,Numerical Methods,">>> dif = lambda s: [x-s[i] for i,x in enumerate(s[1:])]
>>> # or, dif = lambda s: [x-y for x,y in zip(s[1:],s)]
>>> difn = lambda s, n: difn(dif(s), n-1) if n else s
 
>>> s = [90, 47, 58, 29, 22, 32, 55, 5, 55, 73]
>>> difn(s, 0)
[90, 47, 58, 29, 22, 32, 55, 5, 55, 73]
>>> difn(s, 1)
[-43, 11, -29, -7, 10, 23, -50, 50, 18]
>>> difn(s, 2)
[54, -40, 22, 17, 13, -73, 100, -32]
 
>>> from pprint import pprint
>>> pprint( [difn(s, i) for i in xrange(10)] )
[[90, 47, 58, 29, 22, 32, 55, 5, 55, 73],
 [-43, 11, -29, -7, 10, 23, -50, 50, 18],
 [54, -40, 22, 17, 13, -73, 100, -32],
 [-94, 62, -5, -4, -86, 173, -132],
 [156, -67, 1, -82, 259, -305],
 [-223, 68, -83, 341, -564],
 [291, -151, 424, -905],
 [-442, 575, -1329],
 [1017, -1904],
 [-2921]]"
tlx0,python,Four bit adder,Algorithms and Data Structures,Algorithms,"def xor(a, b): return (a and not b) or (b and not a)
 
def ha(a, b): return xor(a, b), a and b     # sum, carry
 
def fa(a, b, ci):
    s0, c0 = ha(ci, a)
    s1, c1 = ha(s0, b)
    return s1, c0 or c1     # sum, carry
 
def fa4(a, b):
    width = 4
    ci = [None] * width
    co = [None] * width
    s  = [None] * width
    for i in range(width):
        s[i], co[i] = fa(a[i], b[i], co[i-1] if i else 0)
    return s, co[-1]
 
def int2bus(n, width=4):
    return [int(c) for c in ""{0:0{1}b}"".format(n, width)[::-1]]
 
def bus2int(b):
    return sum(1 << i for i, bit in enumerate(b) if bit)
 
def test_fa4():
    width = 4
    tot = [None] * (width + 1)
    for a in range(2**width):
        for b in range(2**width):
            tot[:width], tot[width] = fa4(int2bus(a), int2bus(b))
            assert a + b == bus2int(tot), ""totals don't match: %i + %i != %s"" % (a, b, tot)
 
 
if __name__ == '__main__':
   test_fa4()"
zcth,python,Four is magic,Puzzles and Games,Logic and Mathematical Puzzles,"import random
from collections import OrderedDict
 
numbers = {  # taken from https://en.wikipedia.org/wiki/Names_of_large_numbers#cite_ref-a_14-3
    1: 'one',
    2: 'two',
    3: 'three',
    4: 'four',
    5: 'five',
    6: 'six',
    7: 'seven',
    8: 'eight',
    9: 'nine',
    10: 'ten',
    11: 'eleven',
    12: 'twelve',
    13: 'thirteen',
    14: 'fourteen',
    15: 'fifteen',
    16: 'sixteen',
    17: 'seventeen',
    18: 'eighteen',
    19: 'nineteen',
    20: 'twenty',
    30: 'thirty',
    40: 'forty',
    50: 'fifty',
    60: 'sixty',
    70: 'seventy',
    80: 'eighty',
    90: 'ninety',
    100: 'hundred',
    1000: 'thousand',
    10 ** 6: 'million',
    10 ** 9: 'billion',
    10 ** 12: 'trillion',
    10 ** 15: 'quadrillion',
    10 ** 18: 'quintillion',
    10 ** 21: 'sextillion',
    10 ** 24: 'septillion',
    10 ** 27: 'octillion',
    10 ** 30: 'nonillion',
    10 ** 33: 'decillion',
    10 ** 36: 'undecillion',
    10 ** 39: 'duodecillion',
    10 ** 42: 'tredecillion',
    10 ** 45: 'quattuordecillion',
    10 ** 48: 'quinquadecillion',
    10 ** 51: 'sedecillion',
    10 ** 54: 'septendecillion',
    10 ** 57: 'octodecillion',
    10 ** 60: 'novendecillion',
    10 ** 63: 'vigintillion',
    10 ** 66: 'unvigintillion',
    10 ** 69: 'duovigintillion',
    10 ** 72: 'tresvigintillion',
    10 ** 75: 'quattuorvigintillion',
    10 ** 78: 'quinquavigintillion',
    10 ** 81: 'sesvigintillion',
    10 ** 84: 'septemvigintillion',
    10 ** 87: 'octovigintillion',
    10 ** 90: 'novemvigintillion',
    10 ** 93: 'trigintillion',
    10 ** 96: 'untrigintillion',
    10 ** 99: 'duotrigintillion',
    10 ** 102: 'trestrigintillion',
    10 ** 105: 'quattuortrigintillion',
    10 ** 108: 'quinquatrigintillion',
    10 ** 111: 'sestrigintillion',
    10 ** 114: 'septentrigintillion',
    10 ** 117: 'octotrigintillion',
    10 ** 120: 'noventrigintillion',
    10 ** 123: 'quadragintillion',
    10 ** 153: 'quinquagintillion',
    10 ** 183: 'sexagintillion',
    10 ** 213: 'septuagintillion',
    10 ** 243: 'octogintillion',
    10 ** 273: 'nonagintillion',
    10 ** 303: 'centillion',
    10 ** 306: 'uncentillion',
    10 ** 309: 'duocentillion',
    10 ** 312: 'trescentillion',
    10 ** 333: 'decicentillion',
    10 ** 336: 'undecicentillion',
    10 ** 363: 'viginticentillion',
    10 ** 366: 'unviginticentillion',
    10 ** 393: 'trigintacentillion',
    10 ** 423: 'quadragintacentillion',
    10 ** 453: 'quinquagintacentillion',
    10 ** 483: 'sexagintacentillion',
    10 ** 513: 'septuagintacentillion',
    10 ** 543: 'octogintacentillion',
    10 ** 573: 'nonagintacentillion',
    10 ** 603: 'ducentillion',
    10 ** 903: 'trecentillion',
    10 ** 1203: 'quadringentillion',
    10 ** 1503: 'quingentillion',
    10 ** 1803: 'sescentillion',
    10 ** 2103: 'septingentillion',
    10 ** 2403: 'octingentillion',
    10 ** 2703: 'nongentillion',
    10 ** 3003: 'millinillion'
}
numbers = OrderedDict(sorted(numbers.items(), key=lambda t: t[0], reverse=True))
 
 
def string_representation(i: int) -> str:
    """"""
    Return the english string representation of an integer
    """"""
    if i == 0:
        return 'zero'
 
    words = ['negative'] if i < 0 else []
    working_copy = abs(i)
 
    for key, value in numbers.items():
        if key <= working_copy:
            times = int(working_copy / key)
 
            if key >= 100:
                words.append(string_representation(times))
 
            words.append(value)
            working_copy -= times * key
 
        if working_copy == 0:
            break
 
    return ' '.join(words)
 
 
def next_phrase(i: int):
    """"""
    Generate all the phrases
    """"""
    while not i == 4:  # Generate phrases until four is reached
        str_i = string_representation(i)
        len_i = len(str_i)
 
        yield str_i, 'is', string_representation(len_i)
 
        i = len_i
 
    # the last phrase
    yield string_representation(i), 'is', 'magic'
 
 
def magic(i: int) -> str:
    phrases = []
 
    for phrase in next_phrase(i):
        phrases.append(' '.join(phrase))
 
    return f'{"", "".join(phrases)}.'.capitalize()
 
 
if __name__ == '__main__':
 
    for j in (random.randint(0, 10 ** 3) for i in range(5)):
        print(j, ':\n', magic(j), '\n')
 
    for j in (random.randint(-10 ** 24, 10 ** 24) for i in range(2)):
        print(j, ':\n', magic(j), '\n')"
lwbw,python,Four is the number of letters in the ...,Mathematics,Combinatorics," 
# Python implementation of Rosetta Code Task 
# http://rosettacode.org/wiki/Four_is_the_number_of_letters_in_the_...
# Uses inflect
# https://pypi.org/project/inflect/
 
import inflect
 
def count_letters(word):
    """"""
    count letters ignore , or -, or space
    """"""
    count = 0
    for letter in word:
        if letter != ',' and letter !='-' and letter !=' ':
            count += 1
 
    return count
 
def split_with_spaces(sentence):
    """"""
    Takes string with partial sentence and returns
    list of words with spaces included.
 
    Leading space is attached to first word.
    Later spaces attached to prior word.
    """"""
    sentence_list = []
    curr_word = """"
    for c in sentence:
        if c == "" "" and curr_word != """":
            # append space to end of non-empty words
            # assumed no more than 1 consecutive space.
            sentence_list.append(curr_word+"" "")
            curr_word = """"
        else:
            curr_word += c
 
    # add trailing word that does not end with a space        
 
    if len(curr_word) > 0:
        sentence_list.append(curr_word)
 
    return sentence_list
 
def my_num_to_words(p, my_number):
    """"""
    Front end to inflect's number_to_words
 
    Get's rid of ands and commas in large numbers.
    """"""
 
    number_string_list = p.number_to_words(my_number, wantlist=True, andword='')
 
    number_string = number_string_list[0]
 
    for i in range(1,len(number_string_list)):
        number_string += "" "" + number_string_list[i]
 
    return number_string
 
def build_sentence(p, max_words):
    """"""
 
    Builds at most max_words of the task following the pattern:
 
    Four is the number of letters in the first word of this sentence, two in the second,
    three in the third, six in the fourth, two in the fifth, seven in the sixth,
 
    """"""
 
    # start with first part of sentence up first comma as a list
 
    sentence_list = split_with_spaces(""Four is the number of letters in the first word of this sentence,"")
 
    num_words = 13
 
    # which word number we are doing next
    # two/second is first one in loop
 
    word_number = 2
 
    # loop until sentance is at least as long as needs be
 
    while num_words < max_words:
        # Build something like
        # ,two in the second
 
        # get second or whatever we are on
 
        ordinal_string = my_num_to_words(p, p.ordinal(word_number))
 
        # get two or whatever the length is of the word_number word
 
        word_number_string = my_num_to_words(p, count_letters(sentence_list[word_number - 1]))
 
        # sentence addition
 
        new_string = "" ""+word_number_string+"" in the ""+ordinal_string+"",""
 
        new_list = split_with_spaces(new_string)
 
        sentence_list += new_list
 
        # add new word count
 
        num_words += len(new_list)
 
        # increment word number
 
        word_number += 1
 
    return sentence_list, num_words
 
def word_and_counts(word_num):
    """"""
 
    Print's lines like this:
 
    Word     1000 is ""in"", with 2 letters.  Length of sentence so far: 6279
 
    """"""
 
    sentence_list, num_words = build_sentence(p, word_num)
 
    word_str = sentence_list[word_num - 1].strip(' ,')
 
    num_letters = len(word_str)
 
    num_characters = 0
 
    for word in sentence_list:
       num_characters += len(word)
 
    print('Word {0:8d} is ""{1}"", with {2} letters.  Length of the sentence so far: {3}  '.format(word_num,word_str,num_letters,num_characters))
 
 
p = inflect.engine()
 
sentence_list, num_words = build_sentence(p, 201)
 
print("" "")
print(""The lengths of the first 201 words are:"")
print("" "")
 
print('{0:3d}:  '.format(1),end='')
 
total_characters = 0
 
for word_index in range(201):
 
    word_length = count_letters(sentence_list[word_index])
 
    total_characters += len(sentence_list[word_index])
 
    print('{0:2d}'.format(word_length),end='')
    if (word_index+1) % 20 == 0:
        # newline every 20
        print("" "")
        print('{0:3d}:  '.format(word_index + 2),end='')
    else:
        print("" "",end='')
 
print("" "")
print("" "")
print(""Length of the sentence so far: ""+str(total_characters))
print("" "")
 
""""""
 
Expected output this part:
 
Word     1000 is ""in"", with 2 letters.  Length of the sentence so far: 6279
Word    10000 is ""in"", with 2 letters.  Length of the sentence so far: 64140
Word   100000 is ""one"", with 3 letters.  Length of the sentence so far: 659474
Word  1000000 is ""the"", with 3 letters.  Length of the sentence so far: 7113621
Word 10000000 is ""thousand"", with 8 letters.  Length of the sentence so far: 70995756
 
""""""
 
word_and_counts(1000)
word_and_counts(10000)
word_and_counts(100000)
word_and_counts(1000000)
word_and_counts(10000000)
 "
4wyc,python,Fractal tree,Graphics and Visualization,Graphics Programming,"import pygame, math
 
pygame.init()
window = pygame.display.set_mode((600, 600))
pygame.display.set_caption(""Fractal Tree"")
screen = pygame.display.get_surface()
 
def drawTree(x1, y1, angle, depth):
    fork_angle = 20
    base_len = 10.0
    if depth > 0:
        x2 = x1 + int(math.cos(math.radians(angle)) * depth * base_len)
        y2 = y1 + int(math.sin(math.radians(angle)) * depth * base_len)
        pygame.draw.line(screen, (255,255,255), (x1, y1), (x2, y2), 2)
        drawTree(x2, y2, angle - fork_angle, depth - 1)
        drawTree(x2, y2, angle + fork_angle, depth - 1)
 
def input(event):
    if event.type == pygame.QUIT:
        exit(0)
 
drawTree(300, 550, -90, 9)
pygame.display.flip()
while True:
    input(pygame.event.wait())"
qvn5,python,Fraction reduction,Mathematics,Number Theory,"def indexOf(haystack, needle):
    idx = 0
    for straw in haystack:
        if straw == needle:
            return idx
        else:
            idx += 1
    return -1
 
def getDigits(n, le, digits):
    while n > 0:
        r = n % 10
        if r == 0 or indexOf(digits, r) >= 0:
            return False
        le -= 1
        digits[le] = r
        n = int(n / 10)
    return True
 
def removeDigit(digits, le, idx):
    pows = [1, 10, 100, 1000, 10000]
    sum = 0
    pow = pows[le - 2]
    i = 0
    while i < le:
        if i == idx:
            i += 1
            continue
        sum = sum + digits[i] * pow
        pow = int(pow / 10)
        i += 1
    return sum
 
def main():
    lims = [ [ 12, 97 ], [ 123, 986 ], [ 1234, 9875 ], [ 12345, 98764 ] ]
    count = [0 for i in range(5)]
    omitted = [[0 for i in range(10)] for j in range(5)]
 
    i = 0
    while i < len(lims):
        n = lims[i][0]
        while n < lims[i][1]:
            nDigits = [0 for k in range(i + 2)]
            nOk = getDigits(n, i + 2, nDigits)
            if not nOk:
                n += 1
                continue
            d = n + 1
            while d <= lims[i][1] + 1:
                dDigits = [0 for k in range(i + 2)]
                dOk = getDigits(d, i + 2, dDigits)
                if not dOk:
                    d += 1
                    continue
                nix = 0
                while nix < len(nDigits):
                    digit = nDigits[nix]
                    dix = indexOf(dDigits, digit)
                    if dix >= 0:
                        rn = removeDigit(nDigits, i + 2, nix)
                        rd = removeDigit(dDigits, i + 2, dix)
                        if (1.0 * n / d) == (1.0 * rn / rd):
                            count[i] += 1
                            omitted[i][digit] += 1
                            if count[i] <= 12:
                                print ""%d/%d = %d/%d by omitting %d's"" % (n, d, rn, rd, digit)
                    nix += 1
                d += 1
            n += 1
        print
        i += 1
 
    i = 2
    while i <= 5:
        print ""There are %d %d-digit fractions of which:"" % (count[i - 2], i)
        j = 1
        while j <= 9:
            if omitted[i - 2][j] == 0:
                j += 1
                continue
            print ""%6s have %d's omitted"" % (omitted[i - 2][j], j)
            j += 1
        print
        i += 1
    return None
 
main()"
ghgf,python,Fractran,Puzzles and Games,Puzzle Solving Algorithms,"from fractions import Fraction
 
def fractran(n, fstring='17 / 91, 78 / 85, 19 / 51, 23 / 38, 29 / 33,'
                        '77 / 29, 95 / 23, 77 / 19, 1 / 17, 11 / 13,'
                        '13 / 11, 15 / 14, 15 / 2, 55 / 1'):
    flist = [Fraction(f) for f in fstring.replace(' ', '').split(',')]
 
    n = Fraction(n)
    while True:
        yield n.numerator
        for f in flist:
            if (n * f).denominator == 1:
                break
        else:
            break
        n *= f
 
if __name__ == '__main__':
    n, m = 2, 15
    print('First %i members of fractran(%i):\n  ' % (m, n) +
          ', '.join(str(f) for f,i in zip(fractran(n), range(m))))"
kqu3,python,Function composition,Programming Concepts,Fundamentals,"compose = lambda f, g: lambda x: f( g(x) )"
ejki,python,Function definition,Programming Concepts,Fundamentals,"def multiply(a, b):
    return a * b"
i8vr,python,HTTPS/Client-authenticated,Networking and Web Development,Networking,"import httplib
 
connection = httplib.HTTPSConnection('www.example.com',cert_file='myCert.PEM')
connection.request('GET','/index.html')
response = connection.getresponse()
data = response.read()
 "
82uo,python,Hailstone sequence,Mathematics,Combinatorics,"def hailstone(n):
    seq = [n]
    while n>1:
        n = 3*n + 1 if n & 1 else n//2
        seq.append(n)
    return seq
 
if __name__ == '__main__':
    h = hailstone(27)
    assert len(h)==112 and h[:4]==[27, 82, 41, 124] and h[-4:]==[8, 4, 2, 1]
    print(""Maximum length %i was found for hailstone(%i) for numbers <100,000"" %
          max((len(hailstone(i)), i) for i in range(1,100000)))"
nk3m,python,Halt and catch fire,Puzzles and Games,Logic and Mathematical Puzzles,0/0
i6f2,python,Hamming numbers,Mathematics,Number Theory,"from itertools import islice
 
def hamming2():
    '''\
    This version is based on a snippet from:
        https://web.archive.org/web/20081219014725/http://dobbscodetalk.com:80
                         /index.php?option=com_content&task=view&id=913&Itemid=85
        http://www.drdobbs.com/architecture-and-design/hamming-problem/228700538
        Hamming problem
        Written by Will Ness
        December 07, 2008
 
        When expressed in some imaginary pseudo-C with automatic
        unlimited storage allocation and BIGNUM arithmetics, it can be
        expressed as:
            hamming = h where
              array h;
              n=0; h[0]=1; i=0; j=0; k=0;
              x2=2*h[ i ]; x3=3*h[j]; x5=5*h[k];
              repeat:
                h[++n] = min(x2,x3,x5);
                if (x2==h[n]) { x2=2*h[++i]; }
                if (x3==h[n]) { x3=3*h[++j]; }
                if (x5==h[n]) { x5=5*h[++k]; } 
    '''
    h = 1
    _h=[h]    # memoized
    multipliers  = (2, 3, 5)
    multindeces  = [0 for i in multipliers] # index into _h for multipliers
    multvalues   = [x * _h[i] for x,i in zip(multipliers, multindeces)]
    yield h
    while True:
        h = min(multvalues)
        _h.append(h)
        for (n,(v,x,i)) in enumerate(zip(multvalues, multipliers, multindeces)):
            if v == h:
                i += 1
                multindeces[n] = i
                multvalues[n]  = x * _h[i]
        # cap the memoization
        mini = min(multindeces)
        if mini >= 1000:
            del _h[:mini]
            multindeces = [i - mini for i in multindeces]
        #
        yield h"
cm3x,python,Handle a signal,Operating Systems and Shell Programming,Operating System Concepts,"import time
 
def counter():
    n = 0
    t1 = time.time()
    while True:
        try:
            time.sleep(0.5)
            n += 1
            print n
        except KeyboardInterrupt, e:
            print 'Program has run for %5.3f seconds.' % (time.time() - t1)
            break
 
counter()"
bmrm,python,Happy numbers,Mathematics,Number Theory,">>> def happy(n):
    past = set()			
    while n != 1:
        n = sum(int(i)**2 for i in str(n))
        if n in past:
            return False
        past.add(n)
    return True
 
>>> [x for x in xrange(500) if happy(x)][:8]
[1, 7, 10, 13, 19, 23, 28, 31]"
e3lo,python,Harmonic series,Mathematics,Mathematical Sequences and Series,"from  fractions import Fraction
 
def harmonic_series():
    n, h = Fraction(1), Fraction(1)
    while True:
        yield h
        h += 1 / (n + 1)
        n += 1
 
if __name__ == '__main__':
    from itertools import islice
    for n, d in (h.as_integer_ratio() for h in islice(harmonic_series(), 20)):
        print(n, '/', d)"
82pl,python,Harshad or Niven series,Mathematics,Number Theory,">>> import itertools
>>> def harshad():
	for n in itertools.count(1):
		if n % sum(int(ch) for ch in str(n)) == 0:
			yield n
 
 
>>> list(itertools.islice(harshad(), 0, 20))
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 18, 20, 21, 24, 27, 30, 36, 40, 42]
>>> for n in harshad():
	if n > 1000:
		print(n)
		break
 
 
1002
>>> "
v45d,python,Hash from two arrays,Programming Concepts,Fundamentals,"keys = ['a', 'b', 'c']
values = [1, 2, 3]
hash = {key: value for key, value in zip(keys, values)}"
xmsi,python,Hash join,Databases and Data Management,Database Interaction,"from collections import defaultdict
 
def hashJoin(table1, index1, table2, index2):
    h = defaultdict(list)
    # hash phase
    for s in table1:
        h[s[index1]].append(s)
    # join phase
    return [(s, r) for r in table2 for s in h[r[index2]]]
 
table1 = [(27, ""Jonah""),
          (18, ""Alan""),
          (28, ""Glory""),
          (18, ""Popeye""),
          (28, ""Alan"")]
table2 = [(""Jonah"", ""Whales""),
          (""Jonah"", ""Spiders""),
          (""Alan"", ""Ghosts""),
          (""Alan"", ""Zombies""),
          (""Glory"", ""Buffy"")]
 
for row in hashJoin(table1, 1, table2, 0):
    print(row)"
gujk,python,Haversine formula,Mathematics,Geometry and Trigonometry,"from math import radians, sin, cos, sqrt, asin
 
 
def haversine(lat1, lon1, lat2, lon2):
    R = 6372.8  # Earth radius in kilometers
 
    dLat = radians(lat2 - lat1)
    dLon = radians(lon2 - lon1)
    lat1 = radians(lat1)
    lat2 = radians(lat2)
 
    a = sin(dLat / 2)**2 + cos(lat1) * cos(lat2) * sin(dLon / 2)**2
    c = 2 * asin(sqrt(a))
 
    return R * c
 
>>> haversine(36.12, -86.67, 33.94, -118.40)
2887.2599506071106
>>> "
qn8s,python,Hello world/Graphical,Graphics and Visualization,Graphics Programming,"import bpy
 
# select default cube
bpy.data.objects['Cube'].select_set(True)
 
# delete default cube
bpy.ops.object.delete(True)
 
# add text to Blender scene  
bpy.data.curves.new(type=""FONT"", name=""Font Curve"").body = ""Hello World""
font_obj = bpy.data.objects.new(name=""Font Object"", object_data=bpy.data.curves[""Font Curve""])
bpy.context.scene.collection.objects.link(font_obj)
 
# camera center to text
bpy.context.scene.camera.location = (2.5,0.3,10)
 
# camera orient angle to text
bpy.context.scene.camera.rotation_euler = (0,0,0)
 
# change 3D scene to view from the camera
area = next(area for area in bpy.context.screen.areas if area.type == 'VIEW_3D')
area.spaces[0].region_3d.view_perspective = 'CAMERA'"
xzjr,python,Hello world/Line printer,Systems Programming and File I/O,File Operations,"lp = open(""/dev/lp0"")
lp.write(""Hello World!\n"")
lp.close()"
05nu,python,Hello world/Newbie,Programming Concepts,Fundamentals,>>> print('hello world')
exko,python,Hello world/Newline omission,Programming Concepts,Fundamentals,"import sys
sys.stdout.write(""Goodbye, World!"")"
alrq,python,Hello world/Standard error,Programming Concepts,Fundamentals,"import sys
 
print >> sys.stderr, ""Goodbye, World!"""
kw6r,python,Hello world/Text,Programming Concepts,Fundamentals,"print ""Hello world!"""
3mdl,python,Hello world/Web server,Networking and Web Development,Web Development,"from wsgiref.simple_server import make_server
 
def app(environ, start_response):
    start_response('200 OK', [('Content-Type','text/html')])
    yield b""<h1>Goodbye, World!</h1>""
 
server = make_server('127.0.0.1', 8080, app)
server.serve_forever()"
3ria,python,Here document,Programming Concepts,Fundamentals,"print(""""""\
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
"""""")"
082m,python,Heronian triangles,Mathematics,Geometry and Trigonometry,"from __future__ import division, print_function
from math import gcd, sqrt
 
 
def hero(a, b, c):
    s = (a + b + c) / 2
    a2 = s * (s - a) * (s - b) * (s - c)
    return sqrt(a2) if a2 > 0 else 0
 
 
def is_heronian(a, b, c):
    a = hero(a, b, c)
    return a > 0 and a.is_integer()
 
 
def gcd3(x, y, z):
    return gcd(gcd(x, y), z)
 
 
if __name__ == '__main__':
    MAXSIDE = 200
 
    N = 1 + MAXSIDE
    h = [(x, y, z)
         for x in range(1, N)
         for y in range(x, N)
         for z in range(y, N) if (x + y > z) and
         1 == gcd3(x, y, z) and
         is_heronian(x, y, z)]
 
    # By increasing area, perimeter, then sides
    h.sort(key=lambda x: (hero(*x), sum(x), x[::-1]))
 
    print(
        'Primitive Heronian triangles with sides up to %i:' % MAXSIDE, len(h)
    )
    print('\nFirst ten when ordered by increasing area, then perimeter,',
          'then maximum sides:')
    print('\n'.join('  %14r perim: %3i area: %i'
                    % (sides, sum(sides), hero(*sides)) for sides in h[:10]))
    print('\nAll with area 210 subject to the previous ordering:')
    print('\n'.join('  %14r perim: %3i area: %i'
                    % (sides, sum(sides), hero(*sides)) for sides in h
                    if hero(*sides) == 210))
 "
uaae,python,Hickerson series of almost integers,Mathematics,Numerical Methods,"from decimal import Decimal
import math
 
def h(n):
    'Simple, reduced precision calculation'
    return math.factorial(n) / (2 * math.log(2) ** (n + 1))
 
def h2(n):
    'Extended precision Hickerson function'
    return Decimal(math.factorial(n)) / (2 * Decimal(2).ln() ** (n + 1))
 
for n in range(18):
    x = h2(n)
    norm = str(x.normalize())
    almostinteger = (' Nearly integer' 
                     if 'E' not in norm and ('.0' in norm or '.9' in norm) 
                     else ' NOT nearly integer!')
    print('n:%2i h:%s%s' % (n, norm, almostinteger))"
0fjf,python,Higher-order functions,Programming Concepts,Fundamentals,"def first(function):
    return function()
 
def second():
    return ""second""
 
result = first(second)"
zqka,python,Hilbert curve,Graphics and Visualization,Graphics Programming,"'''Hilbert curve'''
 
from itertools import (chain, islice)
 
 
# hilbertCurve :: Int -> SVG String
def hilbertCurve(n):
    '''An SVG string representing a
       Hilbert curve of degree n.
    '''
    w = 1024
    return svgFromPoints(w)(
        hilbertPoints(w)(
            hilbertTree(n)
        )
    )
 
 
# hilbertTree :: Int -> Tree Char
def hilbertTree(n):
    '''Nth application of a rule to a seedling tree.'''
 
    # rule :: Dict Char [Char]
    rule = {
        'a': ['d', 'a', 'a', 'b'],
        'b': ['c', 'b', 'b', 'a'],
        'c': ['b', 'c', 'c', 'd'],
        'd': ['a', 'd', 'd', 'c']
    }
 
    # go :: Tree Char -> Tree Char
    def go(tree):
        c = tree['root']
        xs = tree['nest']
        return Node(c)(
            map(go, xs) if xs else map(
                flip(Node)([]),
                rule[c]
            )
        )
    seed = Node('a')([])
    return list(islice(
        iterate(go)(seed), n
    ))[-1] if 0 < n else seed
 
 
# hilbertPoints :: Int -> Tree Char -> [(Int, Int)]
def hilbertPoints(w):
    '''Serialization of a tree to a list of points
       bounded by a square of side w.
    '''
 
    # vectors :: Dict Char [(Int, Int)]
    vectors = {
        'a': [(-1, 1), (-1, -1), (1, -1), (1, 1)],
        'b': [(1, -1), (-1, -1), (-1, 1), (1, 1)],
        'c': [(1, -1), (1, 1), (-1, 1), (-1, -1)],
        'd': [(-1, 1), (1, 1), (1, -1), (-1, -1)]
    }
 
    # points :: Int -> ((Int, Int), Tree Char) -> [(Int, Int)]
    def points(d):
        '''Size -> Centre of a Hilbert subtree -> All subtree points
        '''
        def go(xy, tree):
            r = d // 2
 
            def deltas(v):
                return (
                    xy[0] + (r * v[0]),
                    xy[1] + (r * v[1])
                )
            centres = map(deltas, vectors[tree['root']])
            return chain.from_iterable(
                map(points(r), centres, tree['nest'])
            ) if tree['nest'] else centres
        return go
 
    d = w // 2
    return lambda tree: list(points(d)((d, d), tree))
 
 
# svgFromPoints :: Int -> [(Int, Int)] -> SVG String
def svgFromPoints(w):
    '''Width of square canvas -> Point list -> SVG string'''
 
    def go(xys):
        def points(xy):
            return str(xy[0]) + ' ' + str(xy[1])
        xs = ' '.join(map(points, xys))
        return '\n'.join(
            ['<svg xmlns=""http://www.w3.org/2000/svg""',
             f'width=""512"" height=""512"" viewBox=""5 5 {w} {w}"">',
             f'<path d=""M{xs}"" ',
             'stroke-width=""2"" stroke=""red"" fill=""transparent""/>',
             '</svg>'
             ]
        )
    return go
 
 
# ------------------------- TEST --------------------------
def main():
    '''Testing generation of the SVG for a Hilbert curve'''
    print(
        hilbertCurve(6)
    )
 
 
# ------------------- GENERIC FUNCTIONS -------------------
 
# Node :: a -> [Tree a] -> Tree a
def Node(v):
    '''Contructor for a Tree node which connects a
       value of some kind to a list of zero or
       more child trees.'''
    return lambda xs: {'type': 'Node', 'root': v, 'nest': xs}
 
 
# flip :: (a -> b -> c) -> b -> a -> c
def flip(f):
    '''The (curried or uncurried) function f with its
       arguments reversed.
    '''
    return lambda a: lambda b: f(b)(a)
 
 
# iterate :: (a -> a) -> a -> Gen [a]
def iterate(f):
    '''An infinite list of repeated
       applications of f to x.
    '''
    def go(x):
        v = x
        while True:
            yield v
            v = f(v)
    return go
 
 
#  TEST ---------------------------------------------------
if __name__ == '__main__':
    main()"
c4q4,python,History variables,Programming Concepts,Advanced Concepts,"import sys
 
HIST = {}
 
def trace(frame, event, arg):
    for name,val in frame.f_locals.items():
        if name not in HIST:
            HIST[name] = []
        else:
            if HIST[name][-1] is val:
                continue
        HIST[name].append(val)
    return trace
 
def undo(name):
    HIST[name].pop(-1)
    return HIST[name][-1]
 
def main():
    a = 10
    a = 20
 
    for i in range(5):
        c = i
 
    print ""c:"", c, ""-> undo x3 ->"",
    c = undo('c')
    c = undo('c')
    c = undo('c')
    print c
    print 'HIST:', HIST
 
sys.settrace(trace)
main()"
xgav,python,Hofstadter Figure-Figure sequences,Mathematics,Combinatorics,"def ffr(n):
    if n < 1 or type(n) != int: raise ValueError(""n must be an int >= 1"")
    try:
        return ffr.r[n]
    except IndexError:
        r, s = ffr.r, ffs.s
        ffr_n_1 = ffr(n-1)
        lastr = r[-1]
        # extend s up to, and one past, last r 
        s += list(range(s[-1] + 1, lastr))
        if s[-1] < lastr: s += [lastr + 1]
        # access s[n-1] temporarily extending s if necessary
        len_s = len(s)
        ffs_n_1 = s[n-1] if len_s > n else (n - len_s) + s[-1]
        ans = ffr_n_1 + ffs_n_1
        r.append(ans)
        return ans
ffr.r = [None, 1]
 
def ffs(n):
    if n < 1 or type(n) != int: raise ValueError(""n must be an int >= 1"")
    try:
        return ffs.s[n]
    except IndexError:
        r, s = ffr.r, ffs.s
        for i in range(len(r), n+2):
            ffr(i)
            if len(s) > n:
                return s[n]
        raise Exception(""Whoops!"")
ffs.s = [None, 2]
 
if __name__ == '__main__':
    first10 = [ffr(i) for i in range(1,11)]
    assert first10 == [1, 3, 7, 12, 18, 26, 35, 45, 56, 69], ""ffr() value error(s)""
    print(""ffr(n) for n = [1..10] is"", first10)
    #
    bin = [None] + [0]*1000
    for i in range(40, 0, -1):
        bin[ffr(i)] += 1
    for i in range(960, 0, -1):
        bin[ffs(i)] += 1
    if all(b == 1 for b in bin[1:1000]):
        print(""All Integers 1..1000 found OK"")
    else:
        print(""All Integers 1..1000 NOT found only once: ERROR"")"
hkf5,python,Hofstadter Q sequence,Mathematics,Mathematical Sequences and Series,"def q(n):
    if n < 1 or type(n) != int: raise ValueError(""n must be an int >= 1"")
    try:
        return q.seq[n]
    except IndexError:
        ans = q(n - q(n - 1)) + q(n - q(n - 2))
        q.seq.append(ans)
        return ans
q.seq = [None, 1, 1]
 
if __name__ == '__main__':
    first10 = [q(i) for i in range(1,11)]
    assert first10 == [1, 1, 2, 3, 3, 4, 5, 5, 6, 6], ""Q() value error(s)""
    print(""Q(n) for n = [1..10] is:"", ', '.join(str(i) for i in first10))
    assert q(1000) == 502, ""Q(1000) value error""
    print(""Q(1000) ="", q(1000))"
uip1,python,"Hofstadter-Conway $10,000 sequence",Mathematics,Combinatorics,"from __future__ import division
 
def maxandmallows(nmaxpower2):
    nmax = 2**nmaxpower2
    mx = (0.5, 2)
    mxpow2 = []
    mallows = None
 
    # Hofstadter-Conway sequence starts at hc[1],
    # hc[0] is not part of the series.
    hc = [None, 1, 1]
 
    for n in range(2, nmax + 1):
        ratio = hc[n] / n
        if ratio > mx[0]:
            mx = (ratio, n)
        if ratio >= 0.55:
            mallows = n
        if ratio == 0.5:
            print(""In the region %7i < n <= %7i: max a(n)/n = %6.4f at  n = %i"" %
		  (n//2, n, mx[0], mx[1]))
            mxpow2.append(mx[0])
            mx = (ratio, n)
        hc.append(hc[hc[n]] + hc[-hc[n]])
 
    return hc, mallows if mxpow2 and mxpow2[-1] < 0.55 and n > 4 else None
 
if __name__ == '__main__':
    hc, mallows = maxandmallows(20)
    if mallows:
        print(""\nYou too might have won $1000 with the mallows number of %i"" % mallows)
 "
7p92,python,Holidays related to Easter,Mathematics,Mathematical Sequences and Series,"from dateutil.easter import *
import datetime, calendar
 
class Holiday(object):
    def __init__(self, date, offset=0):
        self.holiday = date + datetime.timedelta(days=offset)
 
    def __str__(self):
        dayofweek = calendar.day_name[self.holiday.weekday()][0:3]
        month = calendar.month_name[self.holiday.month][0:3]
        return '{0} {1:2d} {2}'.format(dayofweek, self.holiday.day, month)
 
def get_holiday_values(year):
    holidays = {'year': year}
    easterDate = easter(year)
    holidays['easter'] = Holiday(easterDate) 
    holidays['ascension'] = Holiday(easterDate, 39)
    holidays['pentecost'] = Holiday(easterDate, 49)
    holidays['trinity'] = Holiday(easterDate, 56)
    holidays['corpus'] = Holiday(easterDate, 60)
    return holidays
 
def print_holidays(holidays):
    print '{year:4d} Easter: {easter}, Ascension: {ascension}, Pentecost: {pentecost}, Trinity: {trinity}, Corpus: {corpus}'.format(**holidays)
 
if __name__ == ""__main__"":
    print ""Christian holidays, related to Easter, for each centennial from 400 to 2100 CE:""
    for year in range(400, 2200, 100):
        print_holidays(get_holiday_values(year))
 
    print ''
    print ""Christian holidays, related to Easter, for years from 2010 to 2020 CE:""
    for year in range(2010, 2021):
        print_holidays(get_holiday_values(year))
 
 "
9l9s,python,Honeycombs,Puzzles and Games,Game Development,"#lang racket
 
(struct Hex (x y letter clicked?) #:mutable #:transparent)
 
(define hexes
  (let* ([A (char->integer #\A)]
         [letters (take (shuffle (map (compose string integer->char)
                                      (range A (+ A 26))))
                        20)])
    (for*/list ([row 4] [column 5])
      (Hex (* 3/2 column) (* 2 (+ row (if (odd? column) 1/2 0)))
           (list-ref letters (+ (* 5 row) column))
           false))))
 
(require 2htdp/image)
(define (blank width height) (rectangle width height 'outline (color 0 0 0 0)))
 
(define (hexagon mode color) (regular-polygon 1 6 mode color))
(define aspect-ratio (sin (/ pi 3)))
 
(define (board _)
  (scale 100
         (for/fold ([the-board (blank 8 (* aspect-ratio 9))])
           ([hex hexes])
           (define-values (letter-color hex-color)
             (if (Hex-clicked? hex) (values 'black 'purple) (values 'red 'yellow)))
           (underlay/align/offset
            'left 'top the-board
            (Hex-x hex) (* aspect-ratio (Hex-y hex))
            (overlay (scale 1/10 (text (Hex-letter hex) 10 letter-color))
                     (hexagon 'outline 'black)
                     (hexagon 'solid hex-color))))))
 
#| Closest hex in hexes to x y, as one with minimum distance to its center. |#
(define (hex-at x y)
  (argmin (λ (hex) (+ (sqr (- x (* 100 (add1 (Hex-x hex)))))
                      (sqr (- y (* aspect-ratio 100 (add1 (Hex-y hex)))))))
          hexes))
 
(define letters-chosen '())
(define (choose hex)
  (set-Hex-clicked?! hex true)
  (define letter (Hex-letter hex))
  (when (not (member letter letters-chosen))
    (set! letters-chosen (list* (Hex-letter hex) letters-chosen))))
 
(require 2htdp/universe)
(void (big-bang
       (void)
       [to-draw board]
       [stop-when (λ (_) (andmap Hex-clicked? hexes)) board]
       [on-key (λ (_ k)
                 (define hex (findf (λ (hex) (key=? k (string-downcase (Hex-letter hex))))
                                    hexes))
                 (when hex (choose hex)))]
       [on-mouse (λ (_ x y event-type)
                   (when (equal? ""button-down"" event-type)
                     (choose (hex-at x y))))]))
 
(displayln ""The letters were chosen in the order:"")
(for-each display (add-between (reverse letters-chosen) "" ""))"
butf,python,Horizontal sundial calculations,Mathematics,Geometry and Trigonometry,"from __future__ import print_function
import math
try: raw_input
except: raw_input = input
 
lat = float(raw_input(""Enter latitude       => ""))
lng = float(raw_input(""Enter longitude      => ""))
ref = float(raw_input(""Enter legal meridian => ""))
print()
 
slat = math.sin(math.radians(lat))
print(""    sine of latitude:   %.3f"" % slat)
print(""    diff longitude:     %.3f"" % (lng-ref))
print()
print(""Hour, sun hour angle, dial hour line angle from 6am to 6pm"")
 
for h in range(-6, 7):
  hra = 15 * h
  hra -= lng - ref
  hla = math.degrees(math.atan(slat * math.tan(math.radians(hra))))
  print(""HR=%3d; HRA=%7.3f; HLA=%7.3f"" % (h, hra, hla))"
90u3,python,Horner's rule for polynomial evaluation,Mathematics,Algebra and Arithmetic,">>> def horner(coeffs, x):
	acc = 0
	for c in reversed(coeffs):
		acc = acc * x + c
	return acc
 
>>> horner( (-19, 7, -4, 6), 3)
128"
gfn6,python,Host introspection,Systems Programming and File I/O,System Programming,">>> import platform, sys, socket
>>> platform.architecture()
('64bit', 'ELF')
>>> platform.machine()
'x86_64'
>>> platform.node()
'yourhostname'
>>> platform.system()
'Linux'
>>> sys.byteorder
little
>>> socket.gethostname()
'yourhostname'
>>>"
mrm9,python,Hostname,Networking and Web Development,Networking,"import socket
host = socket.gethostname()"
lulo,python,Hough transform,Graphics and Visualization,Graphics Programming," 
from math import hypot, pi, cos, sin
from PIL import Image
 
 
def hough(im, ntx=460, mry=360):
    ""Calculate Hough transform.""
    pim = im.load()
    nimx, mimy = im.size
    mry = int(mry/2)*2          #Make sure that this is even
    him = Image.new(""L"", (ntx, mry), 255)
    phim = him.load()
 
    rmax = hypot(nimx, mimy)
    dr = rmax / (mry/2)
    dth = pi / ntx
 
    for jx in xrange(nimx):
        for iy in xrange(mimy):
            col = pim[jx, iy]
            if col == 255: continue
            for jtx in xrange(ntx):
                th = dth * jtx
                r = jx*cos(th) + iy*sin(th)
                iry = mry/2 + int(r/dr+0.5)
                phim[jtx, iry] -= 1
    return him
 
 
def test():
    ""Test Hough transform with pentagon.""
    im = Image.open(""pentagon.png"").convert(""L"")
    him = hough(im)
    him.save(""ho5.bmp"")
 
 
if __name__ == ""__main__"": test()
 
 "
b7h6,python,Huffman coding,Algorithms and Data Structures,Algorithms,"from heapq import heappush, heappop, heapify
from collections import defaultdict
 
def encode(symb2freq):
    """"""Huffman encode the given dict mapping symbols to weights""""""
    heap = [[wt, [sym, """"]] for sym, wt in symb2freq.items()]
    heapify(heap)
    while len(heap) > 1:
        lo = heappop(heap)
        hi = heappop(heap)
        for pair in lo[1:]:
            pair[1] = '0' + pair[1]
        for pair in hi[1:]:
            pair[1] = '1' + pair[1]
        heappush(heap, [lo[0] + hi[0]] + lo[1:] + hi[1:])
    return sorted(heappop(heap)[1:], key=lambda p: (len(p[-1]), p))
 
txt = ""this is an example for huffman encoding""
symb2freq = defaultdict(int)
for ch in txt:
    symb2freq[ch] += 1
# in Python 3.1+:
# symb2freq = collections.Counter(txt)
huff = encode(symb2freq)
print ""Symbol\tWeight\tHuffman Code""
for p in huff:
    print ""%s\t%s\t%s"" % (p[0], symb2freq[p[0]], p[1])"
3ylr,python,Humble numbers,Mathematics,Number Theory,"'''Humble numbers'''
 
from itertools import groupby, islice
from functools import reduce
 
 
# humbles :: () -> [Int]
def humbles():
    '''A non-finite stream of Humble numbers.
       OEIS A002473
    '''
    hs = set([1])
    while True:
        nxt = min(hs)
        yield nxt
        hs.remove(nxt)
        hs.update(nxt * x for x in [2, 3, 5, 7])
 
 
# TEST ----------------------------------------------------
# main :: IO ()
def main():
    '''First 50, and counts with N digits'''
 
    print('First 50 Humble numbers:\n')
    for row in chunksOf(10)(
            take(50)(humbles())
    ):
        print(' '.join(map(
            lambda x: str(x).rjust(3),
            row
        )))
 
    print('\nCounts of Humble numbers with n digits:\n')
    for tpl in take(10)(
            (k, len(list(g))) for k, g in
            groupby(len(str(x)) for x in humbles())
    ):
        print(tpl)
 
 
# GENERIC -------------------------------------------------
 
# chunksOf :: Int -> [a] -> [[a]]
def chunksOf(n):
    '''A series of lists of length n, subdividing the
       contents of xs. Where the length of xs is not evenly
       divible, the final list will be shorter than n.
    '''
    return lambda xs: reduce(
        lambda a, i: a + [xs[i:n + i]],
        range(0, len(xs), n), []
    ) if 0 < n else []
 
 
# take :: Int -> [a] -> [a]
# take :: Int -> String -> String
def take(n):
    '''The prefix of xs of length n,
       or xs itself if n > length xs.
    '''
    return lambda xs: (
        list(islice(xs, n))
    )
 
 
# MAIN ---
if __name__ == '__main__':
    main()"
jyl3,python,Hunt the Wumpus,Puzzles and Games,Game Development," 
import random
 
class WumpusGame(object):
 
 
	def __init__(self, edges=[]):
 
		# Create arbitrary caves from a list of edges (see the end of the script for example).
		if edges:
			cave = {}
			N = max([edges[i][0] for i in range(len(edges))])
			for i in range(N):
				exits = [edge[1] for edge in edges if edge[0] == i]
				cave[i] = exits
 
		# If no edges are specified, play in the standard cave: a dodecahedron.
		else:
			cave = {1: [2,3,4], 2: [1,5,6], 3: [1,7,8], 4: [1,9,10], 5:[2,9,11],
				6: [2,7,12], 7: [3,6,13], 8: [3,10,14], 9: [4,5,15], 10: [4,8,16], 
				11: [5,12,17], 12: [6,11,18], 13: [7,14,18], 14: [8,13,19], 
				15: [9,16,17], 16: [10,15,19], 17: [11,20,15], 18: [12,13,20], 
				19: [14,16,20], 20: [17,18,19]}
 
		self.cave = cave
 
		self.threats = {}
 
		self.arrows = 5
 
		self.arrow_travel_distance = 5		# As in the original game. I don't like this choice:
											# a bow should not cover a whole cave.
		self.player_pos = -1
 
 
	""""""
	HELPER: These methods wrap processes that are useful or called often.
	""""""
 
 
	def get_safe_rooms(self):
		"""""" Returns a list containing all numbers of rooms that
			do not contain any threats
		""""""
		return list(set(self.cave.keys()).difference(self.threats.keys()))
 
 
	def populate_cave(self):
		"""""" Drop player and threats into random rooms in the cave.
		""""""
		for threat in ['bat', 'bat', 'pit', 'pit', 'wumpus']:
			pos = random.choice(self.get_safe_rooms())
			self.threats[pos] = threat
		self.player_pos = random.choice(self.get_safe_rooms())
 
 
	def breadth_first_search(self, source, target, max_depth=5):
		"""""" The game board (whether custom or standard dodecahedron) is an undirected graph. 
			The rooms are the vertices and the tunnels are the edges of this graph. To find 
			out whether a target room can be reached from a source room using a given amount 
			of tunnels, one can do a breadth first search on the underlying undirected graph.
 
			BFS works like this: start with the source vertex, maybe it is already the target? 
			If not, then go a level deeper and find out, if one of the children (also called 
			successors) of the source vertex is the wanted target. If not, then for each child, 
			go a level deeper and find out if one of the grand-children is the wanted target. 
			If not, then for each grand-child go a level deeper and so on. 
 
			The following is a recursive implementation of BFS. You will not find any loops 
			(for, while). Instead you manage two lists. The first one ('stack') contains all 
			the vertices of the current depth-level (e.g. all grand children). The second 
			('visited') contains all vertices that you already checked. Now there are three 
			possibilites: Either stack is empty, then all vertices have been checked unsuccessfully;
			or the target vertex is a member of the stack, then you are happy; or the target is 
			not a member of the stack, but there are still some vertices that you did not visit, 
			then you append to the stack, all successors of the members of the stack and the old 
			stack now belongs to the visited vertices.
		""""""
		# Set up some initial values.
		graph = self.cave
		depth = 0
 
		def search(stack, visited, target, depth):
			if stack == []:					# The whole graph was searched, but target was not found.
				return False, -1
			if target in stack:
				return True, depth
			visited = visited + stack
			stack = list(set([graph[v][i] for v in stack for i in range(len(graph[v]))]).difference(visited))
			depth += 1
			if depth > max_depth:			# Target is too far away from the source.
				return False, depth
			else:							# Visit all successors of vertices in the stack.
				return search(stack, visited, target, depth)
 
		return search([source], [], target, depth)
 
 
	""""""
	INPUT / OUTPUT: The player interacts with the game.
	""""""
 
 
	def print_warning(self, threat):
		"""""" Called when entering a new room. Shows threats in adjacent rooms.
		""""""
		if threat == 'bat':
			print(""You hear a rustling."")
		elif threat == 'pit':
			print(""You feel a cold wind blowing from a nearby cavern."")
		elif threat == 'wumpus':
			print(""You smell something terrible nearby."")
 
 
	def get_players_input(self):
		"""""" Queries input until valid input is given.
		""""""
		while 1:								# Query the action.
 
			inpt = input(""Shoot or move (S-M)? "")
			try:								# Ensure that the player choses a valid action (shoot or move)
				mode = str(inpt).lower()
				assert mode in ['s', 'm', 'q']
				break
			except (ValueError, AssertionError):
				print(""This is not a valid action: pick 'S' to shoot and 'M' to move."")
 
		if mode == 'q':							# I added a 'quit-button' for convenience.
			return 'q', 0
 
		while 1:								# Query the target of the action.
 
			inpt = input(""Where to? "")
			try:								# Ensure that the chosen target is convertable to an integer.
				target = int(inpt)
			except ValueError:
				print(""This is not even a real number."")
				continue						# Restart the while loop, to get a valid integer as target.
 
			if mode == 'm':
				try:							# When walking, the target must be adjacent to the current room.
					assert target in self.cave[self.player_pos]
					break
				except AssertionError:
					print(""You cannot walk that far. Please use one of the tunnels."")
 
			elif mode == 's':
				try:							# When shooting, the target must be reachable within 5 tunnels.
					bfs = self.breadth_first_search(self.player_pos, target)
					assert bfs[0] == True
					break
				except AssertionError:
					if bfs[1] == -1: 			# The target is outside cave.
						print(""There is no room with this number in the cave. Your arrow travels randomly."")
						target = random.choice(self.cave.keys())
					if bfs[1] > self.arrow_travel_distance:				# The target is too far.
						print(""Arrows aren't that croocked."")
 
		return mode, target
 
 
	""""""
	CORE / GAME LOGIC
	""""""
 
 
	def enter_room(self, room_number):
		"""""" Controls the process of entering a new room.
		""""""	
		print(""Entering room {}..."".format(room_number))
		# Maybe a threat waits in the new room.	
		if self.threats.get(room_number) == 'bat':
			# The bat teleports the player to random empty room
			print(""You encounter a bat, it transports you to a random empty room."")
			new_pos = random.choice(self.get_safe_rooms())
			return self.enter_room(new_pos)
		elif self.threats.get(room_number) == 'wumpus':
			print(""Wumpus eats you."")
			return -1
		elif self.threats.get(room_number) == 'pit':
			print(""You fall into a pit."")
			return -1
 
		# The room is safe; collect information about adjacent rooms.
		for i in self.cave[room_number]:
			self.print_warning(self.threats.get(i))
 
		# Only if nothing else happens, the player enters the room of his choice.
		return room_number
 
 
	def shoot_room(self, room_number):
		"""""" Controls the process of shooting in a room.
		""""""
		print(""Shooting an arrow into room {}..."".format(room_number))
		# Fire an arrow and see if something is hit by it.
		self.arrows -= 1
		threat = self.threats.get(room_number)
		if threat in ['bat', 'wumpus']:
			del self.threats[room_number]		
			if threat == 'wumpus':
				print(""Hurra, you killed the wumpus!"")
				return -1
			elif threat == 'bat':
				print(""You killed a bat."")
		elif threat in ['pit', None]:
			print(""This arrow is lost."")
 
		# If this was your last arrow and it did not hit the wumpus...
		if self.arrows < 1:		# This (or the updating of self.arrows) seems to be broken...
			print(""Your quiver is empty."")
			return -1
 
		#  If you shoot into another room, the Wumpus has a 75% of chance of waking up and moving into an adjacent room.
		if random.random() < 0.75:
			#print(""DEBUG: Wumpus moved."")
			for room_number, threat in self.threats.items():
				if threat == 'wumpus':
					wumpus_pos = room_number					
			new_pos = random.choice(list(set(self.cave[wumpus_pos]).difference(self.threats.keys())))
			del self.threats[room_number]
			self.threats[new_pos] = 'wumpus'			
			if new_pos == self.player_pos: # Wumpus entered players room.
				print(""Wumpus enters your room and eats you!"")
				return -1
 
		return self.player_pos
 
 
	def gameloop(self):
 
		print(""HUNT THE WUMPUS"")
		print(""==============="")
		print()
		self.populate_cave()
		self.enter_room(self.player_pos)
 
		while 1:
 
			#print(""DEBUG: Your quiver holds {} arrows."".format(self.arrows))			
			#print(""DEBUG: Rooms with no threats are: {}."".format(self.get_safe_rooms()))			
			#print(""DEBUG: Threats are located in the following rooms: {}"".format(self.threats))
 
			print(""You are in room {}."".format(self.player_pos), end="" "")
			print(""Tunnels lead to:  {0}  {1}  {2}"".format(*self.cave[self.player_pos]))
 
 
			inpt = self.get_players_input()		# Player choses move or shoot.
			print()								# Visual separation of rounds.
			if inpt[0] == 'm':					# Move.
				target = inpt[1] 
				self.player_pos = self.enter_room(target)
			elif inpt[0] == 's':				# Shoot.
				target = inpt[1]
				self.player_pos = self.shoot_room(target)
			elif inpt[0] == 'q':				# Quit.
				self.player_pos = -1
 
			if self.player_pos == -1:			# E.g. Deadly threat, quiver empty, etc.
				break							# If any of the game loosing conditions are True,
												# then player_pos will be -1. 
 
		print()
		print(""Game over!"")	
 
 
if __name__ == '__main__':						
	# Only executed if you start this script as the main script,
	# i.e. you enter 'python path/to/wumpus.py' in a terminal.
	# Assuming you saved the script in the directory 'path/to' 
	# and named it 'wumpus.py'.
 
	# TODO: In the original game you can replay a dungeon (same positions of you and the threats)
 
	WG = WumpusGame()
	WG.gameloop()
 
 "
s1a3,python,I before E except after C,Puzzles and Games,Logic and Mathematical Puzzles,"import urllib.request
import re
 
PLAUSIBILITY_RATIO = 2
 
def plausibility_check(comment, x, y):
    print('\n  Checking plausibility of: %s' % comment)
    if x > PLAUSIBILITY_RATIO * y:
        print('    PLAUSIBLE. As we have counts of %i vs %i, a ratio of %4.1f times'
              % (x, y, x / y))
    else:
        if x > y:
            print('    IMPLAUSIBLE. As although we have counts of %i vs %i, a ratio of %4.1f times does not make it plausible'
                  % (x, y, x / y))
        else:
            print('    IMPLAUSIBLE, probably contra-indicated. As we have counts of %i vs %i, a ratio of %4.1f times'
                  % (x, y, x / y))
    return x > PLAUSIBILITY_RATIO * y
 
def simple_stats(url='http://wiki.puzzlers.org/pub/wordlists/unixdict.txt'):
    words = urllib.request.urlopen(url).read().decode().lower().split()
    cie = len({word for word in words if 'cie' in word})
    cei = len({word for word in words if 'cei' in word})
    not_c_ie = len({word for word in words if re.search(r'(^ie|[^c]ie)', word)})
    not_c_ei = len({word for word in words if re.search(r'(^ei|[^c]ei)', word)})
    return cei, cie, not_c_ie, not_c_ei
 
def print_result(cei, cie, not_c_ie, not_c_ei):
    if ( plausibility_check('I before E when not preceded by C', not_c_ie, not_c_ei)
         & plausibility_check('E before I when preceded by C', cei, cie) ):
        print('\nOVERALL IT IS PLAUSIBLE!')
    else:
        print('\nOVERALL IT IS IMPLAUSIBLE!')
    print('(To be plausible, one count must exceed another by %i times)' % PLAUSIBILITY_RATIO)
 
print('Checking plausibility of ""I before E except after C"":')
print_result(*simple_stats())"
hmgj,python,IBAN,Security and Cryptography,Cryptographic Techniques,"import re
 
_country2length = dict(
    AL=28, AD=24, AT=20, AZ=28, BE=16, BH=22, BA=20, BR=29,
    BG=22, CR=21, HR=21, CY=28, CZ=24, DK=18, DO=28, EE=20,
    FO=18, FI=18, FR=27, GE=22, DE=22, GI=23, GR=27, GL=18,
    GT=28, HU=28, IS=26, IE=22, IL=23, IT=27, KZ=20, KW=30,
    LV=21, LB=28, LI=21, LT=20, LU=20, MK=19, MT=31, MR=27,
    MU=30, MC=27, MD=24, ME=22, NL=18, NO=15, PK=24, PS=29,
    PL=28, PT=25, RO=24, SM=27, SA=24, RS=22, SK=24, SI=19,
    ES=24, SE=24, CH=21, TN=24, TR=26, AE=23, GB=22, VG=24 )
 
def valid_iban(iban):
    # Ensure upper alphanumeric input.
    iban = iban.replace(' ','').replace('\t','')
    if not re.match(r'^[\dA-Z]+$', iban): 
        return False
    # Validate country code against expected length.
    if len(iban) != _country2length[iban[:2]]:
        return False
    # Shift and convert.
    iban = iban[4:] + iban[:4]
    digits = int(''.join(str(int(ch, 36)) for ch in iban)) #BASE 36: 0..9,A..Z -> 0..35
    return digits % 97 == 1
 
if __name__ == '__main__':
    for account in [""GB82 WEST 1234 5698 7654 32"", ""GB82 TEST 1234 5698 7654 32""]:
        print('%s validation is: %s' % (account, valid_iban(account)))"
7nz1,python,ISBN13 check digit,Mathematics,Number Theory,"def is_isbn13(n):
    n = n.replace('-','').replace(' ', '')
    if len(n) != 13:
        return False
    product = (sum(int(ch) for ch in n[::2]) 
               + sum(int(ch) * 3 for ch in n[1::2]))
    return product % 10 == 0
 
if __name__ == '__main__':
    tests = '''
978-1734314502
978-1734314509
978-1788399081
978-1788399083'''.strip().split()
    for t in tests:
        print(f""ISBN13 {t} validates {is_isbn13(t)}"")"
kenx,python,Identity matrix,Mathematics,Algebra and Arithmetic,"def identity(size):
    matrix = [[0]*size for i in range(size)]
    #matrix = [[0] * size] * size    #Has a flaw. See http://stackoverflow.com/questions/240178/unexpected-feature-in-a-python-list-of-lists
 
    for i in range(size):
        matrix[i][i] = 1
 
    for rows in matrix:
        for elements in rows:
            print elements,
        print """""
4d5f,python,Idiomatically determine all the characters that can be used for symbols,Programming Concepts,Fundamentals,"[ $ ""0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrS""
  $ QsTtUuVvWwXxYyZz()[]{}<>~=+-*/^\|_.,:;?!'""`%@&#$Q 
  join ] constant                                     is tokenchars (   --> $ )
 
( The first non-whitespace character after the word $
  (pronounced ""string"") is deemed to be the delimiter
  for the string that follows it. In the first string 
  the conventional character "" is used, so cannot
  appear as a character in that string. In the second 
  string all the reasonable delimiters are used, so Q
  is used as the delimiter.
 
  As it is not possible to make a string that uses all
  the characters, two strings are concatenated (join)
  to make the string during compilation. (Which is why
  $ ""0...S"" $ Qs...$Q join is nested (inside [ ... ])
  and followed by the word constant, which causes the 
  nest to be evaluated during compilation.)
 
  Regardless of operating system, Quackery only knows 
  the characters in the string tokenchars, plus space
  and carriage return.
 
  The characters in tokenchars are in QACSFOT order
  (the Quackery Arbitrary Character Sequence For 
   Ordered Text) which it uses for string comparison,
   but the valid tokens (which is all of them) will
   be printed by alltokens in the order native to the 
   operating system. (In this instance, Unicode.)     )
 
[ tokenchars find 
  tokenchars found ]                                  is validtoken ( c --> b )
 
[ 256 times 
  [ i^ validtoken if [ i^ emit ] ] ]                  is alltokens  (   -->   )
 
alltokens"
kvdg,python,Idiomatically determine all the lowercase and uppercase letters,Text Processing,String Manipulation,"classes = (str.isupper, str.islower, str.isalnum, str.isalpha, str.isdecimal,
           str.isdigit, str.isidentifier, str.isnumeric, str.isprintable,
           str.isspace, str.istitle)
 
for stringclass in classes:
    chars = ''.join(chr(i) for i in range(0x10FFFF+1) if stringclass(chr(i)))
    print('\nString class %s has %i characters the first of which are:\n  %r'
          % (stringclass.__name__, len(chars), chars[:100]))"
orms,python,Image convolution,Graphics and Visualization,Graphics Programming,"#!/bin/python
from PIL import Image, ImageFilter
 
if __name__==""__main__"":
	im = Image.open(""test.jpg"")
 
	kernelValues = [-2,-1,0,-1,1,1,0,1,2] #emboss
	kernel = ImageFilter.Kernel((3,3), kernelValues)
 
	im2 = im.filter(kernel)
 
	im2.show()"
ttma,python,Image noise,Graphics and Visualization,Graphics Programming,"import time
import random
import Tkinter
import Image, ImageTk # PIL libray
 
class App(object):
    def __init__(self, size, root):
        self.root = root
        self.root.title(""Image Noise Test"")
 
        self.img = Image.new(""RGB"", size)
        self.label = Tkinter.Label(root)
        self.label.pack()
 
        self.time = 0.0
        self.frames = 0
        self.size = size
        self.loop()
 
    def loop(self):
        self.ta = time.time()
        # 13 FPS boost. half integer idea from C#.
        rnd = random.random
        white = (255, 255, 255)
        black = (0, 0, 0)
        npixels = self.size[0] * self.size[1]
        data = [white if rnd() > 0.5 else black for i in xrange(npixels)]
        self.img.putdata(data)
        self.pimg = ImageTk.PhotoImage(self.img)
        self.label[""image""] = self.pimg
        self.tb = time.time()
 
        self.time += (self.tb - self.ta)
        self.frames += 1
 
        if self.frames == 30:
            try:
                self.fps = self.frames / self.time
            except:
                self.fps = ""INSTANT""
            print (""%d frames in %3.2f seconds (%s FPS)"" %
                  (self.frames, self.time, self.fps))
            self.time = 0
            self.frames = 0
 
        self.root.after(1, self.loop)
 
def main():
    root = Tkinter.Tk()
    app = App((320, 240), root)
    root.mainloop()
 
main()"
5g8a,python,Imaginary base numbers,Mathematics,Number Theory,"import math
import re
 
def inv(c):
    denom = c.real * c.real + c.imag * c.imag
    return complex(c.real / denom, -c.imag / denom)
 
class QuaterImaginary:
    twoI = complex(0, 2)
    invTwoI = inv(twoI)
 
    def __init__(self, str):
        if not re.match(""^[0123.]+$"", str) or str.count('.') > 1:
            raise Exception('Invalid base 2i number')
        self.b2i = str
 
    def toComplex(self):
        pointPos = self.b2i.find('.')
        posLen = len(self.b2i) if (pointPos < 0) else pointPos
        sum = complex(0, 0)
        prod = complex(1, 0)
        for j in xrange(0, posLen):
            k = int(self.b2i[posLen - 1 - j])
            if k > 0:
                sum += prod * k
            prod *= QuaterImaginary.twoI
        if pointPos != -1:
            prod = QuaterImaginary.invTwoI
            for j in xrange(posLen + 1, len(self.b2i)):
                k = int(self.b2i[j])
                if k > 0:
                    sum += prod * k
                prod *= QuaterImaginary.invTwoI
        return sum
 
    def __str__(self):
        return str(self.b2i)
 
def toQuaterImaginary(c):
    if c.real == 0.0 and c.imag == 0.0:
        return QuaterImaginary(""0"")
 
    re = int(c.real)
    im = int(c.imag)
    fi = -1
    ss = """"
    while re != 0:
        re, rem = divmod(re, -4)
        if rem < 0:
            rem += 4
            re += 1
        ss += str(rem) + '0'
    if im != 0:
        f = c.imag / 2
        im = int(math.ceil(f))
        f = -4 * (f - im)
        index = 1
        while im != 0:
            im, rem = divmod(im, -4)
            if rem < 0:
                rem += 4
                im += 1
            if index < len(ss):
                ss[index] = str(rem)
            else:
                ss += '0' + str(rem)
            index = index + 2
        fi = int(f)
    ss = ss[::-1]
    if fi != -1:
        ss += '.' + str(fi)
    ss = ss.lstrip('0')
    if ss[0] == '.':
        ss = '0' + ss
    return QuaterImaginary(ss)
 
for i in xrange(1,17):
    c1 = complex(i, 0)
    qi = toQuaterImaginary(c1)
    c2 = qi.toComplex()
    print ""{0:8} -> {1:>8} -> {2:8}     "".format(c1, qi, c2),
 
    c1 = -c1
    qi = toQuaterImaginary(c1)
    c2 = qi.toComplex()
    print ""{0:8} -> {1:>8} -> {2:8}"".format(c1, qi, c2)
print
 
for i in xrange(1,17):
    c1 = complex(0, i)
    qi = toQuaterImaginary(c1)
    c2 = qi.toComplex()
    print ""{0:8} -> {1:>8} -> {2:8}     "".format(c1, qi, c2),
 
    c1 = -c1
    qi = toQuaterImaginary(c1)
    c2 = qi.toComplex()
    print ""{0:8} -> {1:>8} -> {2:8}"".format(c1, qi, c2)
 
print ""done""
 "
55a2,python,Include a file,Systems Programming and File I/O,File Operations,import mymodule
yewv,python,Increasing gaps between consecutive Niven numbers,Mathematics,Number Theory," 
""""""
 
Python implementation of
 
http://rosettacode.org/wiki/Increasing_gaps_between_consecutive_Niven_numbers
 
""""""
 
# based on C example
 
# Returns the sum of the digits of n given the
# sum of the digits of n - 1
def digit_sum(n, sum):
    sum += 1
    while n > 0 and n % 10 == 0:
        sum -= 9
        n /= 10
 
    return sum
 
previous = 1
gap = 0
sum = 0
niven_index = 0
gap_index = 1
 
print(""Gap index  Gap    Niven index    Niven number"")
 
niven = 1
 
while gap_index <= 22:
    sum = digit_sum(niven, sum)
    if niven % sum == 0:
        if niven > previous + gap:
            gap = niven - previous;
            print('{0:9d} {1:4d}  {2:13d}     {3:11d}'.format(gap_index, gap, niven_index, previous))
            gap_index += 1
        previous = niven
        niven_index += 1
    niven += 1
 "
gk49,python,Increment a numerical string,Mathematics,Algebra and Arithmetic,next = str(int('123') + 1)
ebsx,python,Index finite lists of positive integers,Mathematics,Combinatorics,"def rank(x): return int('a'.join(map(str, [1] + x)), 11)
 
def unrank(n):
	s = ''
	while n: s,n = ""0123456789a""[n%11] + s, n//11
	return map(int, s.split('a'))[1:]
 
l = [1, 2, 3, 10, 100, 987654321]
print l
n = rank(l)
print n
l = unrank(n)
print l"
al4f,python,Infinity,Mathematics,Numerical Methods,">>> float('infinity')
inf"
ywd5,python,Inheritance/Multiple,Programming Concepts,Fundamentals,"class Camera:
  pass #functions go here..."
2pxk,python,Inheritance/Single,Programming Concepts,Fundamentals,"class Animal:
  pass #functions go here...
 
class Dog(Animal):
  pass #functions go here...
 
class Cat(Animal):
  pass #functions go here...
 
class Lab(Dog):
  pass #functions go here...
 
class Collie(Dog):
  pass #functions go here..."
m4kk,python,Input loop,Programming Concepts,Fundamentals,"while(True):
      x = input(""What is your age? "")
      print(x)"
pmjo,python,Integer comparison,Programming Concepts,Fundamentals,"#!/usr/bin/env python
a = input('Enter value of a: ')
b = input('Enter value of b: ')
 
if a < b:
    print 'a is less than b'
elif a > b:
    print 'a is greater than b'
elif a == b:
    print 'a is equal to b'"
a8mo,python,Integer overflow,Mathematics,Algebra and Arithmetic,"Python 2.7.5 (default, May 15 2013, 22:43:36) [MSC v.1500 32 bit (Intel)] on win32
Type ""copyright"", ""credits"" or ""license()"" for more information.
>>> for calc in '''   -(-2147483647-1)
   2000000000 + 2000000000
   -2147483647 - 2147483647
   46341 * 46341
   (-2147483647-1) / -1'''.split('\n'):
	ans = eval(calc)
	print('Expression: %r evaluates to %s of type %s'
	      % (calc.strip(), ans, type(ans)))
 
 
Expression: '-(-2147483647-1)' evaluates to 2147483648 of type <type 'long'>
Expression: '2000000000 + 2000000000' evaluates to 4000000000 of type <type 'long'>
Expression: '-2147483647 - 2147483647' evaluates to -4294967294 of type <type 'long'>
Expression: '46341 * 46341' evaluates to 2147488281 of type <type 'long'>
Expression: '(-2147483647-1) / -1' evaluates to 2147483648 of type <type 'long'>
>>> "
2rj6,python,Integer sequence,Mathematics,Mathematical Sequences and Series,"i=1
while i:
    print(i)
    i += 1"
4esf,python,Interactive programming (repl),Programming Concepts,Fundamentals,"python
Python 2.6.1 (r261:67517, Dec  4 2008, 16:51:00) [MSC v.1500 32 bit (Intel)] on
win32
Type ""help"", ""copyright"", ""credits"" or ""license"" for more information.
>>> def f(string1, string2, separator):
	return separator.join([string1, '', string2])
 
>>> f('Rosetta', 'Code', ':')
'Rosetta::Code'
>>>"
02we,python,Intersecting number wheels,Puzzles and Games,Puzzle Solving Algorithms,"from itertools import islice
 
class INW():
    """"""
    Intersecting Number Wheels
    represented as a dict mapping
    name to tuple of values.
    """"""
 
    def __init__(self, **wheels):
        self._wheels = wheels
        self.isect = {name: self._wstate(name, wheel) 
                      for name, wheel in wheels.items()}
 
    def _wstate(self, name, wheel):
        ""Wheel state holder""
        assert all(val in self._wheels for val in wheel if type(val) == str), \
               f""ERROR: Interconnected wheel not found in {name}: {wheel}""
        pos = 0
        ln = len(wheel)
        while True:
            nxt, pos = wheel[pos % ln], pos + 1
            yield next(self.isect[nxt]) if type(nxt) == str else nxt
 
    def __iter__(self):
        base_wheel_name = next(self.isect.__iter__())
        yield from self.isect[base_wheel_name]
 
    def __repr__(self):
        return f""{self.__class__.__name__}({self._wheels})""
 
    def __str__(self):
        txt = ""Intersecting Number Wheel group:""
        for name, wheel in self._wheels.items():
            txt += f""\n  {name+':':4}"" + ' '.join(str(v) for v in wheel)
        return txt
 
def first(iter, n):
    ""Pretty print first few terms""
    return ' '.join(f""{nxt}"" for nxt in islice(iter, n))
 
if __name__ == '__main__':
    for group in[
      {'A': (1, 2, 3)},
      {'A': (1, 'B', 2),
       'B': (3, 4)},
      {'A': (1, 'D', 'D'),
       'D': (6, 7, 8)},
      {'A': (1, 'B', 'C'),
       'B': (3, 4),
       'C': (5, 'B')}, # 135143145...
     ]:
        w = INW(**group)
        print(f""{w}\n  Generates:\n    {first(w, 20)} ...\n"")"
qb9m,python,Introspection,Programming Concepts,Fundamentals,"# Checking for system version
 import sys
 major, minor, bugfix = sys.version_info[:3]
 if major < 2:
     sys.exit('Python 2 is required')
 
 
 def defined(name): # LBYL (Look Before You Leap)
     return name in globals() or name in locals() or name in vars(__builtins__)
 
 def defined2(name): # EAFP (Easier to Ask Forgiveness than Permission)
     try:
          eval(name)
          return True
     except NameError:
          return False
 
 if defined('bloop') and defined('abs') and callable(abs):
     print abs(bloop)
 
 if defined2('bloop') and defined2('abs') and callable(abs):
     print abs(bloop)"
l3lf,python,Inverted index,Databases and Data Management,Database Interaction,"'''
This implements: http://en.wikipedia.org/wiki/Inverted_index of 28/07/10
'''
 
from pprint import pprint as pp
from glob import glob
try: reduce
except: from functools import reduce
try:    raw_input
except: raw_input = input
 
 
def parsetexts(fileglob='InvertedIndex/T*.txt'):
    texts, words = {}, set()
    for txtfile in glob(fileglob):
        with open(txtfile, 'r') as f:
            txt = f.read().split()
            words |= set(txt)
            texts[txtfile.split('\\')[-1]] = txt
    return texts, words
 
def termsearch(terms): # Searches simple inverted index
    return reduce(set.intersection,
                  (invindex[term] for term in terms),
                  set(texts.keys()))
 
texts, words = parsetexts()
print('\nTexts')
pp(texts)
print('\nWords')
pp(sorted(words))
 
invindex = {word:set(txt
                        for txt, wrds in texts.items() if word in wrds)
            for word in words}
print('\nInverted Index')
pp({k:sorted(v) for k,v in invindex.items()})
 
terms = [""what"", ""is"", ""it""]
print('\nTerm Search for: ' + repr(terms))
pp(sorted(termsearch(terms)))"
c1ms,python,Inverted syntax,Programming Concepts,Fundamentals,x = truevalue if condition else falsevalue
yfg4,python,Isqrt (integer square root) of X,Mathematics,Algebra and Arithmetic,"def isqrt ( x ):
    q = 1
    while q <= x : 
        q *= 4
    z,r = x,0
    while q > 1 :
        q  /= 4
        t,r = z-r-q,r/2
        if t >= 0 :
            z,r = t,r+q
    return r 
 
print ' '.join( '%d'%isqrt( n ) for n in xrange( 66 ))
print '\n'.join( '{0:114,} = isqrt( 7^{1:3} )'.format( isqrt( 7**n ),n ) for n in range( 1,204,2 ))"
48dn,python,Iterated digits squaring,Mathematics,Combinatorics,"from math import ceil, log10, factorial
 
def next_step(x):
    result = 0
    while x > 0:
        result += (x % 10) ** 2
        x /= 10
    return result
 
def check(number):
    candidate = 0
    for n in number:
        candidate = candidate * 10 + n
 
    while candidate != 89 and candidate != 1:
        candidate = next_step(candidate)
 
    if candidate == 89:
        digits_count = [0] * 10
        for d in number:
            digits_count[d] += 1
 
        result = factorial(len(number))
        for c in digits_count:
            result /= factorial(c)
        return result
 
    return 0
 
def main():
    limit = 100000000
    cache_size = int(ceil(log10(limit)))
    assert 10 ** cache_size == limit
 
    number = [0] * cache_size
    result = 0
    i = cache_size - 1
 
    while True:
        if i == 0 and number[i] == 9:
            break
        if i == cache_size - 1 and number[i] < 9:
            number[i] += 1
            result += check(number)
        elif number[i] == 9:
            i -= 1
        else:
            number[i] += 1
            for j in xrange(i + 1, cache_size):
                number[j] = number[i]
            i = cache_size - 1
            result += check(number)
 
    print result
 
main()"
rqf5,python,JSON,Databases and Data Management,Data Serialization and Formats,">>> import json
>>> data = json.loads('{ ""foo"": 1, ""bar"": [10, ""apples""] }')
>>> sample = { ""blue"": [1,2], ""ocean"": ""water"" }
>>> json_string = json.dumps(sample)
>>> json_string
'{""blue"": [1, 2], ""ocean"": ""water""}'
>>> sample
{'blue': [1, 2], 'ocean': 'water'}
>>> data
{'foo': 1, 'bar': [10, 'apples']}"
6j8g,python,Jacobi symbol,Mathematics,Number Theory,"def jacobi(a, n):
    if n <= 0:
        raise ValueError(""'n' must be a positive integer."")
    if n % 2 == 0:
        raise ValueError(""'n' must be odd."")
    a %= n
    result = 1
    while a != 0:
        while a % 2 == 0:
            a /= 2
            n_mod_8 = n % 8
            if n_mod_8 in (3, 5):
                result = -result
        a, n = n, a
        if a % 4 == 3 and n % 4 == 3:
            result = -result
        a %= n
    if n == 1:
        return result
    else:
        return 0"
4amw,python,Jacobsthal numbers,Mathematics,Mathematical Sequences and Series,"#!/usr/bin/python
from math import floor, pow
 
def isPrime(n):
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False        
    return True
 
def odd(n):
    return n and 1 != 0
 
def jacobsthal(n):
    return floor((pow(2,n)+odd(n))/3)
 
def jacobsthal_lucas(n):
    return int(pow(2,n)+pow(-1,n))
 
def jacobsthal_oblong(n):
    return jacobsthal(n)*jacobsthal(n+1)
 
 
if __name__ == '__main__':
    print(""First 30 Jacobsthal numbers:"")
    for j in range(0, 30):
        print(jacobsthal(j), end=""  "")
 
    print(""\n\nFirst 30 Jacobsthal-Lucas numbers: "")
    for j in range(0, 30):
        print(jacobsthal_lucas(j), end = '\t')
 
    print(""\n\nFirst 20 Jacobsthal oblong numbers: "")
    for j in range(0, 20):
        print(jacobsthal_oblong(j), end=""  "")
 
    print(""\n\nFirst 10 Jacobsthal primes: "")
    for j in range(3, 33):
        if isPrime(jacobsthal(j)):
            print(jacobsthal(j))"
qtrk,python,Jaro similarity,Mathematics,Probability and Statistics,"'''Jaro distance'''
 
from __future__ import division
 
 
def jaro(s, t):
    '''Jaro distance between two strings.'''
    s_len = len(s)
    t_len = len(t)
 
    if s_len == 0 and t_len == 0:
        return 1
 
    match_distance = (max(s_len, t_len) // 2) - 1
 
    s_matches = [False] * s_len
    t_matches = [False] * t_len
 
    matches = 0
    transpositions = 0
 
    for i in range(s_len):
        start = max(0, i - match_distance)
        end = min(i + match_distance + 1, t_len)
 
        for j in range(start, end):
            if t_matches[j]:
                continue
            if s[i] != t[j]:
                continue
            s_matches[i] = True
            t_matches[j] = True
            matches += 1
            break
 
    if matches == 0:
        return 0
 
    k = 0
    for i in range(s_len):
        if not s_matches[i]:
            continue
        while not t_matches[k]:
            k += 1
        if s[i] != t[k]:
            transpositions += 1
        k += 1
 
    return ((matches / s_len) +
            (matches / t_len) +
            ((matches - transpositions / 2) / matches)) / 3
 
 
def main():
    '''Tests'''
 
    for s, t in [('MARTHA', 'MARHTA'),
                 ('DIXON', 'DICKSONX'),
                 ('JELLYFISH', 'SMELLYFISH')]:
        print(""jaro(%r, %r) = %.10f"" % (s, t, jaro(s, t)))
 
 
if __name__ == '__main__':
    main()"
arct,python,Jaro-Winkler distance,Mathematics,Probability and Statistics,"""""""
Test Jaro-Winkler distance metric.
linuxwords.txt is from http://users.cs.duke.edu/~ola/ap/linuxwords
""""""
 
WORDS = [s.strip() for s in open(""linuxwords.txt"").read().split()]
MISSPELLINGS = [
    ""accomodate​"",
    ""definately​"",
    ""goverment"",
    ""occured"",
    ""publically"",
    ""recieve"",
    ""seperate"",
    ""untill"",
    ""wich"",
]
 
def jaro_winkler_distance(st1, st2):
    """"""
    Compute Jaro-Winkler distance between two strings.
    """"""
    if len(st1) < len(st2):
        st1, st2 = st2, st1
    len1, len2 = len(st1), len(st2)
    if len2 == 0:
        return 0.0
    delta = max(0, len2 // 2 - 1)
    flag = [False for _ in range(len2)]  # flags for possible transpositions
    ch1_match = []
    for idx1, ch1 in enumerate(st1):
        for idx2, ch2 in enumerate(st2):
            if idx2 <= idx1 + delta and idx2 >= idx1 - delta and ch1 == ch2 and not flag[idx2]:
                flag[idx2] = True
                ch1_match.append(ch1)
                break
 
    matches = len(ch1_match)
    if matches == 0:
        return 1.0
    transpositions, idx1 = 0, 0
    for idx2, ch2 in enumerate(st2):
        if flag[idx2]:
            transpositions += (ch2 != ch1_match[idx1])
            idx1 += 1
 
    jaro = (matches / len1 + matches / len2 + (matches - transpositions/2) / matches) / 3.0
    commonprefix = 0
    for i in range(min(4, len2)):
        commonprefix += (st1[i] == st2[i])
 
    return 1.0 - (jaro + commonprefix * 0.1 * (1 - jaro))
 
def within_distance(maxdistance, stri, maxtoreturn):
    """"""
    Find words in WORDS of closeness to stri within maxdistance, return up to maxreturn of them.
    """"""
    arr = [w for w in WORDS if jaro_winkler_distance(stri, w) <= maxdistance]
    arr.sort(key=lambda x: jaro_winkler_distance(stri, x))
    return arr if len(arr) <= maxtoreturn else arr[:maxtoreturn]
 
for STR in MISSPELLINGS:
    print('\nClose dictionary words ( distance < 0.15 using Jaro-Winkler distance) to ""',
          STR, '"" are:\n        Word   |  Distance')
    for w in within_distance(0.15, STR, 5):
        print('{:>14} | {:6.4f}'.format(w, jaro_winkler_distance(STR, w)))
 "
osvr,python,Jensen's Device,Programming Concepts,Advanced Concepts,"class Ref(object):
    def __init__(self, value=None):
        self.value = value
 
def harmonic_sum(i, lo, hi, term):
    # term is passed by-name, and so is i
    temp = 0
    i.value = lo
    while i.value <= hi:  # Python ""for"" loop creates a distinct which
        temp += term() # would not be shared with the passed ""i""
        i.value += 1   # Here the actual passed ""i"" is incremented.
    return temp
 
i = Ref()
 
# note the correspondence between the mathematical notation and the
# call to sum it's almost as good as sum(1/i for i in range(1,101))
print harmonic_sum(i, 1, 100, lambda: 1.0/i.value)"
x8po,python,Jewels and stones,Text Processing,String Manipulation,"def countJewels(s, j):
    return sum(x in j for x in s)
 
print countJewels(""aAAbbbb"", ""aA"")
print countJewels(""ZZ"", ""z"")"
8tjj,python,JortSort,Algorithms and Data Structures,Algorithms,">>> def jortsort(sequence):
	return list(sequence) == sorted(sequence)
>>> for data in [(1,2,4,3), (14,6,8), ['a', 'c'], ['s', 'u', 'x'], 'CVGH', 'PQRST']:
	print(f'jortsort({repr(data)}) is {jortsort(data)}')
jortsort((1, 2, 4, 3)) is False
jortsort((14, 6, 8)) is False
jortsort(['a', 'c']) is True
jortsort(['s', 'u', 'x']) is True
jortsort('CVGH') is False
jortsort('PQRST') is True
>>> "
xy3f,python,Josephus problem,Mathematics,Combinatorics,">>> def j(n, k):
	p, i, seq = list(range(n)), 0, []
	while p:
		i = (i+k-1) % len(p)
		seq.append(p.pop(i))
	return 'Prisoner killing order: %s.\nSurvivor: %i' % (', '.join(str(i) for i in seq[:-1]), seq[-1])
 
>>> print(j(5, 2))
Prisoner killing order: 1, 3, 0, 4.
Survivor: 2
>>> print(j(41, 3))
Prisoner killing order: 2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3, 34, 15.
Survivor: 30
>>> "
qy4t,python,Joystick position,Graphics and Visualization,Graphics Programming,"import sys
import pygame
 
pygame.init()
 
# Create a clock (for framerating)
clk = pygame.time.Clock()
 
# Grab joystick 0
if pygame.joystick.get_count() == 0:
    raise IOError(""No joystick detected"")
joy = pygame.joystick.Joystick(0)
joy.init()
 
# Create display
size = width, height = 600, 600
screen = pygame.display.set_mode(size)
pygame.display.set_caption(""Joystick Tester"")
 
# Frame XHair zone
frameRect = pygame.Rect((45, 45), (510, 510))
 
# Generate crosshair
crosshair = pygame.surface.Surface((10, 10))
crosshair.fill(pygame.Color(""magenta""))
pygame.draw.circle(crosshair, pygame.Color(""blue""), (5,5), 5, 0)
crosshair.set_colorkey(pygame.Color(""magenta""), pygame.RLEACCEL)
crosshair = crosshair.convert()
 
# Generate button surfaces
writer = pygame.font.Font(pygame.font.get_default_font(), 15)
buttons = {}
for b in range(joy.get_numbuttons()):
    buttons[b] = [
        writer.render(
            hex(b)[2:].upper(),
            1,
            pygame.Color(""red""),
            pygame.Color(""black"")
        ).convert(),
        # Get co-ords: ((width*slot)+offset, offset). Offsets chosen
        #                                             to match frames.
        ((15*b)+45, 560)
    ]
 
while True:
    # Pump and check the events queue
    pygame.event.pump()
    for events in pygame.event.get():
        if events.type == pygame.QUIT:
            pygame.quit()
            sys.exit()
 
    # Black the screen
    screen.fill(pygame.Color(""black""))
 
    # Get joystick axes
    x = joy.get_axis(0)
    y = joy.get_axis(1)
 
    # Blit to the needed coords:
    # x*amplitude+(centre offset (window size/2))-(xhair offset (xh size/2))
    screen.blit(crosshair, ((x*250)+300-5, (y*250)+300-5))
    pygame.draw.rect(screen, pygame.Color(""red""), frameRect, 1)
 
    # Get and display the joystick buttons
    for b in range(joy.get_numbuttons()):
        if joy.get_button(b):
            screen.blit(buttons[b][0], buttons[b][1])
 
    # Write the display
    pygame.display.flip()
    clk.tick(40) # Limit to <=40 FPS"
q6wn,python,Juggler sequence,Mathematics,Mathematical Sequences and Series,"from math import isqrt
 
def juggler(k, countdig=True, maxiters=1000):
    m, maxj, maxjpos = k, k, 0
    for i in range(1, maxiters):
        m = isqrt(m) if m % 2 == 0 else isqrt(m * m * m)
        if m >= maxj:
            maxj, maxjpos  = m, i
        if m == 1:
            print(f""{k: 9}{i: 6,}{maxjpos: 6}{len(str(maxj)) if countdig else maxj: 20,}{' digits' if countdig else ''}"")
            return i
 
    print(""ERROR: Juggler series starting with $k did not converge in $maxiters iterations"")
 
 
print(""       n    l(n)  i(n)       h(n) or d(n)\n-------------------------------------------"")
for k in range(20, 40):
    juggler(k, False)
 
for k in [113, 173, 193, 2183, 11229, 15065, 15845, 30817, 48443, 275485, 1267909]:
    juggler(k)
 "
nj4u,python,Julia set,Graphics and Visualization,Graphics Programming,"from PIL import Image
 
if __name__ == ""__main__"":
	w, h, zoom = 800,600,1
	bitmap = Image.new(""RGB"", (w, h), ""white"")
	pix = bitmap.load()
 
	cX, cY = -0.7, 0.27015
	moveX, moveY = 0.0, 0.0
	maxIter = 255
 
	for x in range(w):
		for y in range(h):
			zx = 1.5*(x - w/2)/(0.5*zoom*w) + moveX
			zy = 1.0*(y - h/2)/(0.5*zoom*h) + moveY
			i = maxIter
			while zx*zx + zy*zy < 4 and i > 1:
				tmp = zx*zx - zy*zy + cX
				zy,zx = 2.0*zx*zy + cY, tmp
				i -= 1
			# convert byte to RGB (3 bytes), kinda magic to get nice colors
			pix[x][y] = (i << 21) + (i << 10) + i*8
 
	bitmap.show()"
rvkk,python,Jump anywhere,Programming Concepts,Advanced Concepts," 
# Example 2: Restarting a loop:
from goto import goto, label
label .start
for i in range(1, 4):
    print i
    if i == 2:
        try:
            output = message
        except NameError:
            print ""Oops - forgot to define 'message'!  Start again.""
            message = ""Hello world""
            goto .start
print output, ""\n""
 "
hqe0,python,K-d tree,Algorithms and Data Structures,Algorithms,"from random import seed, random
from time import time
from operator import itemgetter
from collections import namedtuple
from math import sqrt
from copy import deepcopy
 
 
def sqd(p1, p2):
    return sum((c1 - c2) ** 2 for c1, c2 in zip(p1, p2))
 
 
class KdNode(object):
    __slots__ = (""dom_elt"", ""split"", ""left"", ""right"")
 
    def __init__(self, dom_elt, split, left, right):
        self.dom_elt = dom_elt
        self.split = split
        self.left = left
        self.right = right
 
 
class Orthotope(object):
    __slots__ = (""min"", ""max"")
 
    def __init__(self, mi, ma):
        self.min, self.max = mi, ma
 
 
class KdTree(object):
    __slots__ = (""n"", ""bounds"")
 
    def __init__(self, pts, bounds):
        def nk2(split, exset):
            if not exset:
                return None
            exset.sort(key=itemgetter(split))
            m = len(exset) // 2
            d = exset[m]
            while m + 1 < len(exset) and exset[m + 1][split] == d[split]:
                m += 1
            d = exset[m]
 
 
            s2 = (split + 1) % len(d)  # cycle coordinates
            return KdNode(d, split, nk2(s2, exset[:m]),
                                    nk2(s2, exset[m + 1:]))
        self.n = nk2(0, pts)
        self.bounds = bounds
 
T3 = namedtuple(""T3"", ""nearest dist_sqd nodes_visited"")
 
 
def find_nearest(k, t, p):
    def nn(kd, target, hr, max_dist_sqd):
        if kd is None:
            return T3([0.0] * k, float(""inf""), 0)
 
        nodes_visited = 1
        s = kd.split
        pivot = kd.dom_elt
        left_hr = deepcopy(hr)
        right_hr = deepcopy(hr)
        left_hr.max[s] = pivot[s]
        right_hr.min[s] = pivot[s]
 
        if target[s] <= pivot[s]:
            nearer_kd, nearer_hr = kd.left, left_hr
            further_kd, further_hr = kd.right, right_hr
        else:
            nearer_kd, nearer_hr = kd.right, right_hr
            further_kd, further_hr = kd.left, left_hr
 
        n1 = nn(nearer_kd, target, nearer_hr, max_dist_sqd)
        nearest = n1.nearest
        dist_sqd = n1.dist_sqd
        nodes_visited += n1.nodes_visited
 
        if dist_sqd < max_dist_sqd:
            max_dist_sqd = dist_sqd
        d = (pivot[s] - target[s]) ** 2
        if d > max_dist_sqd:
            return T3(nearest, dist_sqd, nodes_visited)
        d = sqd(pivot, target)
        if d < dist_sqd:
            nearest = pivot
            dist_sqd = d
            max_dist_sqd = dist_sqd
 
        n2 = nn(further_kd, target, further_hr, max_dist_sqd)
        nodes_visited += n2.nodes_visited
        if n2.dist_sqd < dist_sqd:
            nearest = n2.nearest
            dist_sqd = n2.dist_sqd
 
        return T3(nearest, dist_sqd, nodes_visited)
 
    return nn(t.n, p, t.bounds, float(""inf""))
 
 
def show_nearest(k, heading, kd, p):
    print(heading + "":"")
    print(""Point:           "", p)
    n = find_nearest(k, kd, p)
    print(""Nearest neighbor:"", n.nearest)
    print(""Distance:        "", sqrt(n.dist_sqd))
    print(""Nodes visited:   "", n.nodes_visited, ""\n"")
 
 
def random_point(k):
    return [random() for _ in range(k)]
 
 
def random_points(k, n):
    return [random_point(k) for _ in range(n)]
 
if __name__ == ""__main__"":
    seed(1)
    P = lambda *coords: list(coords)
    kd1 = KdTree([P(2, 3), P(5, 4), P(9, 6), P(4, 7), P(8, 1), P(7, 2)],
                  Orthotope(P(0, 0), P(10, 10)))
    show_nearest(2, ""Wikipedia example data"", kd1, P(9, 2))
 
    N = 400000
    t0 = time()
    kd2 = KdTree(random_points(3, N), Orthotope(P(0, 0, 0), P(1, 1, 1)))
    t1 = time()
    text = lambda *parts: """".join(map(str, parts))
    show_nearest(2, text(""k-d tree with "", N,
                         "" random 3D points (generation time: "",
                         t1-t0, ""s)""),
                 kd2, random_point(3))"
g7cu,python,K-means++ clustering,Artificial Intelligence and Machine Learning,Basic AI Concepts,"from math import pi, sin, cos
from collections import namedtuple
from random import random, choice
from copy import copy
 
try:
    import psyco
    psyco.full()
except ImportError:
    pass
 
 
FLOAT_MAX = 1e100
 
 
class Point:
    __slots__ = [""x"", ""y"", ""group""]
    def __init__(self, x=0.0, y=0.0, group=0):
        self.x, self.y, self.group = x, y, group
 
 
def generate_points(npoints, radius):
    points = [Point() for _ in xrange(npoints)]
 
    # note: this is not a uniform 2-d distribution
    for p in points:
        r = random() * radius
        ang = random() * 2 * pi
        p.x = r * cos(ang)
        p.y = r * sin(ang)
 
    return points
 
 
def nearest_cluster_center(point, cluster_centers):
    """"""Distance and index of the closest cluster center""""""
    def sqr_distance_2D(a, b):
        return (a.x - b.x) ** 2  +  (a.y - b.y) ** 2
 
    min_index = point.group
    min_dist = FLOAT_MAX
 
    for i, cc in enumerate(cluster_centers):
        d = sqr_distance_2D(cc, point)
        if min_dist > d:
            min_dist = d
            min_index = i
 
    return (min_index, min_dist)
 
 
def kpp(points, cluster_centers):
    cluster_centers[0] = copy(choice(points))
    d = [0.0 for _ in xrange(len(points))]
 
    for i in xrange(1, len(cluster_centers)):
        sum = 0
        for j, p in enumerate(points):
            d[j] = nearest_cluster_center(p, cluster_centers[:i])[1]
            sum += d[j]
 
        sum *= random()
 
        for j, di in enumerate(d):
            sum -= di
            if sum > 0:
                continue
            cluster_centers[i] = copy(points[j])
            break
 
    for p in points:
        p.group = nearest_cluster_center(p, cluster_centers)[0]
 
 
def lloyd(points, nclusters):
    cluster_centers = [Point() for _ in xrange(nclusters)]
 
    # call k++ init
    kpp(points, cluster_centers)
 
    lenpts10 = len(points) >> 10
 
    changed = 0
    while True:
        # group element for centroids are used as counters
        for cc in cluster_centers:
            cc.x = 0
            cc.y = 0
            cc.group = 0
 
        for p in points:
            cluster_centers[p.group].group += 1
            cluster_centers[p.group].x += p.x
            cluster_centers[p.group].y += p.y
 
        for cc in cluster_centers:
            cc.x /= cc.group
            cc.y /= cc.group
 
        # find closest centroid of each PointPtr
        changed = 0
        for p in points:
            min_i = nearest_cluster_center(p, cluster_centers)[0]
            if min_i != p.group:
                changed += 1
                p.group = min_i
 
        # stop when 99.9% of points are good
        if changed <= lenpts10:
            break
 
    for i, cc in enumerate(cluster_centers):
        cc.group = i
 
    return cluster_centers
 
 
def print_eps(points, cluster_centers, W=400, H=400):
    Color = namedtuple(""Color"", ""r g b"");
 
    colors = []
    for i in xrange(len(cluster_centers)):
        colors.append(Color((3 * (i + 1) % 11) / 11.0,
                            (7 * i % 11) / 11.0,
                            (9 * i % 11) / 11.0))
 
    max_x = max_y = -FLOAT_MAX
    min_x = min_y = FLOAT_MAX
 
    for p in points:
        if max_x < p.x: max_x = p.x
        if min_x > p.x: min_x = p.x
        if max_y < p.y: max_y = p.y
        if min_y > p.y: min_y = p.y
 
    scale = min(W / (max_x - min_x),
                H / (max_y - min_y))
    cx = (max_x + min_x) / 2
    cy = (max_y + min_y) / 2
 
    print ""%%!PS-Adobe-3.0\n%%%%BoundingBox: -5 -5 %d %d"" % (W + 10, H + 10)
 
    print (""/l {rlineto} def /m {rmoveto} def\n"" +
           ""/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\n"" +
           ""/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath "" +
           ""   gsave 1 setgray fill grestore gsave 3 setlinewidth"" +
           "" 1 setgray stroke grestore 0 setgray stroke }def"")
 
    for i, cc in enumerate(cluster_centers):
        print (""%g %g %g setrgbcolor"" %
               (colors[i].r, colors[i].g, colors[i].b))
 
        for p in points:
            if p.group != i:
                continue
            print (""%.3f %.3f c"" % ((p.x - cx) * scale + W / 2,
                                    (p.y - cy) * scale + H / 2))
 
        print (""\n0 setgray %g %g s"" % ((cc.x - cx) * scale + W / 2,
                                        (cc.y - cy) * scale + H / 2))
 
    print ""\n%%%%EOF""
 
 
def main():
    npoints = 30000
    k = 7 # # clusters
 
    points = generate_points(npoints, 10)
    cluster_centers = lloyd(points, k)
    print_eps(points, cluster_centers)
 
 
main()"
fzeb,python,Kaprekar numbers,Mathematics,Number Theory,">>> def k(n):
	n2 = str(n**2)
	for i in range(len(n2)):
		a, b = int(n2[:i] or 0), int(n2[i:])
		if b and a + b == n:
			return n
			#return (n, (n2[:i], n2[i:]))
 
 
>>> [x for x in range(1,10000) if k(x)]
[1, 9, 45, 55, 99, 297, 703, 999, 2223, 2728, 4879, 4950, 5050, 5292, 7272, 7777, 9999]
>>> len([x for x in range(1,1000000) if k(x)])
54
>>> "
nwyq,python,Kernighans large earthquake problem,Text Processing,Parsing and Tokenization,"python -c '
with open(""data.txt"") as f:
    for ln in f:
        if float(ln.strip().split()[2]) > 6:
            print(ln.strip())'"
5p2p,python,Keyboard input/Flush the keyboard buffer,Systems Programming and File I/O,File Operations,"def flush_input():
    try:
        import msvcrt
        while msvcrt.kbhit():
            msvcrt.getch()
    except ImportError:
        import sys, termios
        termios.tcflush(sys.stdin, termios.TCIOFLUSH)
 "
xcje,python,Keyboard input/Keypress check,Programming Concepts,Fundamentals,"#!/usr/bin/env python
# -*- coding: utf-8 -*-
from __future__ import absolute_import, division, unicode_literals, print_function
 
import tty, termios
import sys
if sys.version_info.major < 3:
    import thread as _thread
else:
    import _thread
import time
 
 
try:
    from msvcrt import getch  # try to import Windows version
except ImportError:
    def getch():   # define non-Windows version
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setraw(sys.stdin.fileno())
            ch = sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        return ch
 
def keypress():
    global char
    char = getch()
 
def main():
    global char
    char = None
    _thread.start_new_thread(keypress, ())
 
    while True:
        if char is not None:
            try:
                print(""Key pressed is "" + char.decode('utf-8'))
            except UnicodeDecodeError:
                print(""character can not be decoded, sorry!"")
                char = None
            _thread.start_new_thread(keypress, ())
            if char == 'q' or char == '\x1b':  # x1b is ESC
                exit()
            char = None
        print(""Program is running"")
        time.sleep(1)
 
if __name__ == ""__main__"":
    main()
 "
c64u,python,Keyboard input/Obtain a Y or N response,Programming Concepts,Fundamentals,"#!/usr/bin/env python
 
try:
    from msvcrt import getch
except ImportError:
    def getch():
        import sys, tty, termios
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setraw(sys.stdin.fileno())
            ch = sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        return ch
 
print ""Press Y or N to continue""
while True:
    char = getch()
    if char.lower() in (""y"", ""n""):
        print char
        break"
g70a,python,Keyboard macros,Systems Programming and File I/O,System Programming,"#!/usr/bin/env python
import curses
 
def print_message():
    stdscr.addstr('This is the message.\n')
 
stdscr = curses.initscr()
curses.noecho()
curses.cbreak()
stdscr.keypad(1)
 
stdscr.addstr('CTRL+P for message or q to quit.\n')
while True:
    c = stdscr.getch()
    if c == 16: print_message()
    elif c == ord('q'): break
 
curses.nocbreak()
stdscr.keypad(0)
curses.echo()
curses.endwin()
 "
jb1v,python,Knapsack problem/0-1,Algorithms and Data Structures,Algorithms,"from itertools import combinations
 
def anycomb(items):
    ' return combinations of any length from the items '
    return ( comb
             for r in range(1, len(items)+1)
             for comb in combinations(items, r)
             )
 
def totalvalue(comb):
    ' Totalise a particular combination of items'
    totwt = totval = 0
    for item, wt, val in comb:
        totwt  += wt
        totval += val
    return (totval, -totwt) if totwt <= 400 else (0, 0)
 
items = (
    (""map"", 9, 150), (""compass"", 13, 35), (""water"", 153, 200), (""sandwich"", 50, 160),
    (""glucose"", 15, 60), (""tin"", 68, 45), (""banana"", 27, 60), (""apple"", 39, 40),
    (""cheese"", 23, 30), (""beer"", 52, 10), (""suntan cream"", 11, 70), (""camera"", 32, 30),
    (""t-shirt"", 24, 15), (""trousers"", 48, 10), (""umbrella"", 73, 40),
    (""waterproof trousers"", 42, 70), (""waterproof overclothes"", 43, 75),
    (""note-case"", 22, 80), (""sunglasses"", 7, 20), (""towel"", 18, 12),
    (""socks"", 4, 50), (""book"", 30, 10),
    )
bagged = max( anycomb(items), key=totalvalue) # max val or min wt if values equal
print(""Bagged the following items\n  "" +
      '\n  '.join(sorted(item for item,_,_ in bagged)))
val, wt = totalvalue(bagged)
print(""for a total value of %i and a total weight of %i"" % (val, -wt))"
bqve,python,Knapsack problem/Bounded,Algorithms and Data Structures,Algorithms,"from itertools import groupby
from collections import namedtuple
 
def anyvalidcomb(items, maxwt, val=0, wt=0):
    ' All combinations below the maxwt '
    if not items:
        yield [], val, wt
    else:
        this, *items = items            # car, cdr
        for n in range(this.number + 1):
            w = wt  + n * this.weight
            if w > maxwt:
                break
            v = val + n * this.value
            this_comb = [this] * n
            for comb, value, weight in anyvalidcomb(items, maxwt, v, w):
                yield this_comb + comb, value, weight
 
maxwt = 400
COMB, VAL, WT = range(3)
Item  = namedtuple('Items', 'name weight value number')
items = [ Item(*x) for x in
          (
            (""map"", 9, 150, 1),
            (""compass"", 13, 35, 1),
            (""water"", 153, 200, 3),
            (""sandwich"", 50, 60, 2),
            (""glucose"", 15, 60, 2),
            (""tin"", 68, 45, 3),
            (""banana"", 27, 60, 3),
            (""apple"", 39, 40, 3),
            (""cheese"", 23, 30, 1),
            (""beer"", 52, 10, 3),
            (""suntan cream"", 11, 70, 1),
            (""camera"", 32, 30, 1),
            (""t-shirt"", 24, 15, 2),
            (""trousers"", 48, 10, 2),
            (""umbrella"", 73, 40, 1),
            (""waterproof trousers"", 42, 70, 1),
            (""waterproof overclothes"", 43, 75, 1),
            (""note-case"", 22, 80, 1),
            (""sunglasses"", 7, 20, 1),
            (""towel"", 18, 12, 2),
            (""socks"", 4, 50, 1),
            (""book"", 30, 10, 2),
           ) ]  
 
bagged = max( anyvalidcomb(items, maxwt), key=lambda c: (c[VAL], -c[WT])) # max val or min wt if values equal
print(""Bagged the following %i items"" % len(bagged[COMB]))
print('\n\t'.join('%i off: %s' % (len(list(grp)), item.name) for item, grp in groupby(sorted(bagged[COMB]))))
print(""for a total value of %i and a total weight of %i"" % bagged[1:])"
onnt,python,Knapsack problem/Continuous,Algorithms and Data Structures,Algorithms,"#        NAME, WEIGHT, VALUE (for this weight)
items = [(""beef"",    3.8, 36.0),
         (""pork"",    5.4, 43.0),
         (""ham"",     3.6, 90.0),
         (""greaves"", 2.4, 45.0),
         (""flitch"",  4.0, 30.0),
         (""brawn"",   2.5, 56.0),
         (""welt"",    3.7, 67.0),
         (""salami"",  3.0, 95.0),
         (""sausage"", 5.9, 98.0)]
 
MAXWT = 15.0
 
sorted_items = sorted(((value/amount, amount, name)
                       for name, amount, value in items),
                      reverse = True)
wt = val = 0
bagged = []
for unit_value, amount, name in sorted_items:
    portion = min(MAXWT - wt, amount)
    wt     += portion
    addval  = portion * unit_value
    val    += addval
    bagged += [(name, portion, addval)]
    if wt >= MAXWT:
        break
 
print(""    ITEM   PORTION VALUE"")
print(""\n"".join(""%10s %6.2f %6.2f"" % item for item in bagged))
print(""\nTOTAL WEIGHT: %5.2f\nTOTAL VALUE: %5.2f"" % (wt, val))"
59g9,python,Knapsack problem/Unbounded,Algorithms and Data Structures,Algorithms,"# Define consts
weights <- c(panacea=0.3, ichor=0.2, gold=2.0)
volumes <- c(panacea=0.025, ichor=0.015, gold=0.002)
values <- c(panacea=3000, ichor=1800, gold=2500)
sack.weight <- 25
sack.volume <- 0.25
max.items <- floor(pmin(sack.weight/weights, sack.volume/volumes))
 
# Some utility functions
getTotalValue <- function(n) sum(n*values)
getTotalWeight <- function(n) sum(n*weights)
getTotalVolume <- function(n) sum(n*volumes)
willFitInSack <- function(n) getTotalWeight(n) <= sack.weight && getTotalVolume(n) <= sack.volume
 
# Find all possible combination, then eliminate those that won't fit in the sack
knapsack <- expand.grid(lapply(max.items, function(n) seq.int(0, n)))
ok <- apply(knapsack, 1, willFitInSack)
knapok <- knapsack[ok,]
 
# Find the solutions with the highest value
vals <- apply(knapok, 1, getTotalValue)
knapok[vals == max(vals),]"
9zsm,python,Knight's tour,Puzzles and Games,Logic and Mathematical Puzzles,"import copy
 
boardsize=6
_kmoves = ((2,1), (1,2), (-1,2), (-2,1), (-2,-1), (-1,-2), (1,-2), (2,-1)) 
 
 
def chess2index(chess, boardsize=boardsize):
    'Convert Algebraic chess notation to internal index format'
    chess = chess.strip().lower()
    x = ord(chess[0]) - ord('a')
    y = boardsize - int(chess[1:])
    return (x, y)
 
def boardstring(board, boardsize=boardsize):
    r = range(boardsize)
    lines = ''
    for y in r:
        lines += '\n' + ','.join('%2i' % board[(x,y)] if board[(x,y)] else '  '
                                 for x in r)
    return lines
 
def knightmoves(board, P, boardsize=boardsize):
    Px, Py = P
    kmoves = set((Px+x, Py+y) for x,y in _kmoves)
    kmoves = set( (x,y)
                  for x,y in kmoves
                  if 0 <= x < boardsize
                     and 0 <= y < boardsize
                     and not board[(x,y)] )
    return kmoves
 
def accessibility(board, P, boardsize=boardsize):
    access = []
    brd = copy.deepcopy(board)
    for pos in knightmoves(board, P, boardsize=boardsize):
        brd[pos] = -1
        access.append( (len(knightmoves(brd, pos, boardsize=boardsize)), pos) )
        brd[pos] = 0
    return access
 
def knights_tour(start, boardsize=boardsize, _debug=False):
    board = {(x,y):0 for x in range(boardsize) for y in range(boardsize)}
    move = 1
    P = chess2index(start, boardsize)
    board[P] = move
    move += 1
    if _debug:
        print(boardstring(board, boardsize=boardsize))
    while move <= len(board):
        P = min(accessibility(board, P, boardsize))[1]
        board[P] = move
        move += 1
        if _debug:
            print(boardstring(board, boardsize=boardsize))
            input('\n%2i next: ' % move)
    return board
 
if __name__ == '__main__':
    while 1:
        boardsize = int(input('\nboardsize: '))
        if boardsize < 5:
            continue
        start = input('Start position: ')
        board = knights_tour(start, boardsize)
        print(boardstring(board, boardsize=boardsize))"
dnpk,python,Knuth shuffle,Algorithms and Data Structures,Algorithms,"from random import randrange
 
def knuth_shuffle(x):
    for i in range(len(x)-1, 0, -1):
        j = randrange(i + 1)
        x[i], x[j] = x[j], x[i]
 
x = list(range(10))
knuth_shuffle(x)
print(""shuffled:"", x)"
4xjt,python,Knuth's algorithm S,Algorithms and Data Structures,Algorithms,"from random import randrange
 
def s_of_n_creator(n):
    sample, i = [], 0
    def s_of_n(item):
        nonlocal i
 
        i += 1
        if i <= n:
            # Keep first n items
            sample.append(item)
        elif randrange(i) < n:
            # Keep item
            sample[randrange(n)] = item
        return sample
    return s_of_n
 
if __name__ == '__main__':
    bin = [0]* 10
    items = range(10)
    print(""Single run samples for n = 3:"")
    s_of_n = s_of_n_creator(3)
    for item in items:
        sample = s_of_n(item)
        print(""  Item: %i -> sample: %s"" % (item, sample))
    #
    for trial in range(100000):
        s_of_n = s_of_n_creator(3)
        for item in items:
            sample = s_of_n(item)
        for s in sample:
            bin[s] += 1
    print(""\nTest item frequencies for 100000 runs:\n "",
          '\n  '.join(""%i:%i"" % x for x in enumerate(bin)))"
g8x0,python,Knuth's power tree,Algorithms and Data Structures,Algorithms,"from __future__ import print_function
 
# remember the tree generation state and expand on demand
def path(n, p = {1:0}, lvl=[[1]]):
	if not n: return []
	while n not in p:
		q = []
		for x,y in ((x, x+y) for x in lvl[0] for y in path(x) if not x+y in p):
			p[y] = x
			q.append(y)
		lvl[0] = q
 
	return path(p[n]) + [n]
 
def tree_pow(x, n):
    r, p = {0:1, 1:x}, 0
    for i in path(n):
        r[i] = r[i-p] * r[p]
        p = i
    return r[n]
 
def show_pow(x, n):
    fmt = ""%d: %s\n"" + [""%g^%d = %f"", ""%d^%d = %d""][x==int(x)] + ""\n""
    print(fmt % (n, repr(path(n)), x, n, tree_pow(x, n)))
 
for x in range(18): show_pow(2, x)
show_pow(3, 191)
show_pow(1.1, 81)"
nu4u,python,Koch curve,Mathematics,Geometry and Trigonometry,"'''Koch curve'''
 
from math import cos, pi, sin
from operator import add, sub
from itertools import chain
 
 
# kochSnowflake :: Int -> (Float, Float) -> (Float, Float) -> [(Float, Float)]
def kochSnowflake(n, a, b):
    '''List of points on a Koch snowflake of order n, derived
       from an equilateral triangle with base a b.
    '''
    points = [a, equilateralApex(a, b), b]
    return chain.from_iterable(map(
        kochCurve(n),
        points,
        points[1:] + [points[0]]
    ))
 
 
# kochCurve :: Int -> (Float, Float) -> (Float, Float)
#                  -> [(Float, Float)]
def kochCurve(n):
    '''List of points on a Koch curve of order n,
       starting at point ab, and ending at point xy.
    '''
    def koch(n):
        def goTuple(abxy):
            ab, xy = abxy
            if 0 == n:
                return [xy]
            else:
                mp, mq = midThirdOfLine(ab, xy)
                points = [
                    ab,
                    mp,
                    equilateralApex(mp, mq),
                    mq,
                    xy
                ]
                return list(
                    chain.from_iterable(map(
                        koch(n - 1),
                        zip(points, points[1:])
                    ))
                )
        return goTuple
 
    def go(ab, xy):
        return [ab] + koch(n)((ab, xy))
    return go
 
 
# equilateralApex :: (Float, Float) -> (Float, Float) -> (Float, Float)
def equilateralApex(p, q):
    '''Apex of triangle with base p q.
    '''
    return rotatedPoint(pi / 3)(p, q)
 
 
# rotatedPoint :: Float -> (Float, Float) ->
#                (Float, Float) -> (Float, Float)
def rotatedPoint(theta):
    '''The point ab rotated theta radians
        around the origin xy.
    '''
    def go(xy, ab):
        ox, oy = xy
        a, b = ab
        dx, dy = rotatedVector(theta, (a - ox, oy - b))
        return ox + dx, oy - dy
    return go
 
 
# rotatedVector :: Float -> (Float, Float) -> (Float, Float)
def rotatedVector(theta, xy):
    '''The vector xy rotated by theta radians.
    '''
    x, y = xy
    return (
        x * cos(theta) - y * sin(theta),
        x * sin(theta) + y * cos(theta)
    )
 
 
# midThirdOfLine :: (Float, Float) -> (Float, Float)
#                -> ((Float, Float), (Float, Float))
def midThirdOfLine(ab, xy):
    '''Second of three equal segments of
       the line between ab and xy.
    '''
    vector = [x / 3 for x in map(sub, xy, ab)]
 
    def f(p):
        return tuple(map(add, vector, p))
    p = f(ab)
    return (p, f(p))
 
 
# -------------------------- TEST --------------------------
# main :: IO ()
def main():
    '''SVG for Koch snowflake of order 4.
    '''
    print(
        svgFromPoints(1024)(
            kochSnowflake(
                4, (200, 600), (800, 600)
            )
        )
    )
 
 
# -------------------------- SVG ---------------------------
 
# svgFromPoints :: Int -> [(Float, Float)] -> SVG String
def svgFromPoints(w):
    '''Width of square canvas -> Point list -> SVG string.
    '''
    def go(xys):
        xs = ' '.join(map(
            lambda xy: str(round(xy[0], 2)) + ' ' + str(round(xy[1], 2)),
            xys
        ))
        return '\n'.join([
            '<svg xmlns=""http://www.w3.org/2000/svg""',
            f'width=""512"" height=""512"" viewBox=""5 5 {w} {w}"">',
            f'<path d=""M{xs}"" ',
            'stroke-width=""2"" stroke=""red"" fill=""transparent""/>',
            '</svg>'
        ])
    return go
 
 
# MAIN ---
if __name__ == '__main__':
    main()"
27l9,python,Kolakoski sequence,Mathematics,Combinatorics,"import itertools
 
def cycler(start_items):
	return itertools.cycle(start_items).__next__
 
def _kolakoski_gen(start_items):
    s, k = [], 0
    c = cycler(start_items)
    while True:
        c_next = c()
        s.append(c_next)
        sk = s[k]
        yield sk
        if sk > 1:
            s += [c_next] * (sk - 1)
        k += 1
 
def kolakoski(start_items=(1, 2), length=20):
    return list(itertools.islice(_kolakoski_gen(start_items), length))
 
def _run_len_encoding(truncated_series):
    return [len(list(group)) for grouper, group in itertools.groupby(truncated_series)][:-1]
 
def is_series_eq_its_rle(series):
    rle = _run_len_encoding(series)
    return (series[:len(rle)] == rle) if rle else not series
 
if __name__ == '__main__':
    for start_items, length in [((1, 2), 20), ((2, 1), 20), 
                                ((1, 3, 1, 2), 30), ((1, 3, 2, 1), 30)]:
        print(f'\n## {length} members of the series generated from {start_items} is:')
        s = kolakoski(start_items, length)
        print(f'  {s}')
        ans = 'YES' if is_series_eq_its_rle(s) else 'NO'
        print(f'  Does it look like a Kolakoski sequence: {ans}')"
gugu,python,Kosaraju,Algorithms and Data Structures,Algorithms,"def kosaraju(g):
    class nonlocal: pass
 
    # 1. For each vertex u of the graph, mark u as unvisited. Let l be empty.
    size = len(g)
 
    vis = [False]*size # vertexes that have been visited
    l = [0]*size
    nonlocal.x = size
    t = [[]]*size   # transpose graph
 
    def visit(u):
        if not vis[u]:
            vis[u] = True
            for v in g[u]:
                visit(v)
                t[v] = t[v] + [u]
            nonlocal.x = nonlocal.x - 1
            l[nonlocal.x] = u
 
    # 2. For each vertex u of the graph do visit(u)
    for u in range(len(g)):
        visit(u)
    c = [0]*size
 
    def assign(u, root):
        if vis[u]:
            vis[u] = False
            c[u] = root
            for v in t[u]:
                assign(v, root)
 
    # 3: For each element u of l in order, do assign(u, u)
    for u in l:
        assign(u, u)
 
    return c
 
g = [[1], [2], [0], [1,2,4], [3,5], [2,6], [5], [4,6,7]]
print kosaraju(g)"
1p2x,python,Kronecker product,Mathematics,Algebra and Arithmetic,"#!/usr/bin/env python3
 
# Sample 1
a1 = [[1, 2], [3, 4]]
b1 = [[0, 5], [6, 7]]
 
# Sample 2
a2 = [[0, 1, 0], [1, 1, 1], [0, 1, 0]]
b2 = [[1, 1, 1, 1], [1, 0, 0, 1], [1, 1, 1, 1]]
 
def kronecker(matrix1, matrix2):
    final_list = []
    sub_list = []
 
    count = len(matrix2)
 
    for elem1 in matrix1:
        counter = 0
        check = 0
        while check < count:
            for num1 in elem1:
                for num2 in matrix2[counter]:
                    sub_list.append(num1 * num2)
            counter += 1
            final_list.append(sub_list)
            sub_list = []
            check +=1
 
    return final_list
 
# Result 1
result1 = kronecker(a1, b1)
for elem in result1:
    print(elem)
 
print("""")
 
# Result 2
result2 = kronecker(a2, b2)
for elem in result2:
    print(elem)"
weyl,python,Kronecker product based fractals,Mathematics,Mathematical Sequences and Series,"import os
from PIL import Image
 
 
def imgsave(path, arr):
    w, h = len(arr), len(arr[0])
    img = Image.new('1', (w, h))
    for x in range(w):
        for y in range(h):
            img.putpixel((x, y), arr[x][y])
    img.save(path)
 
 
def get_shape(mat):
    return len(mat), len(mat[0])
 
 
def kron(matrix1, matrix2):
    """"""
    Calculate the kronecker product of two matrices
    """"""
    final_list = []
 
    count = len(matrix2)
 
    for elem1 in matrix1:
        for i in range(count):
            sub_list = []
            for num1 in elem1:
                for num2 in matrix2[i]:
                    sub_list.append(num1 * num2)
            final_list.append(sub_list)
 
    return final_list
 
 
def kronpow(mat):
    """"""
    Generate an arbitrary number of kronecker powers
    """"""
    matrix = mat
    while True:
        yield matrix
        matrix = kron(mat, matrix)
 
 
def fractal(name, mat, order=6):
    """"""
    Save fractal as jpg to 'fractals/name'
    """"""
    path = os.path.join('fractals', name)
    os.makedirs(path, exist_ok=True)
 
    fgen = kronpow(mat)
    print(name)
    for i in range(order):
        p = os.path.join(path, f'{i}.jpg')
        print('Calculating n =', i, end='\t', flush=True)
 
        mat = next(fgen)
        imgsave(p, mat)
 
        x, y = get_shape(mat)
        print('Saved as', x, 'x', y, 'image', p)
 
 
test1 = [
    [0, 1, 0],
    [1, 1, 1],
    [0, 1, 0]
]
 
test2 = [
    [1, 1, 1],
    [1, 0, 1],
    [1, 1, 1]
]
 
test3 = [
    [1, 0, 1],
    [0, 1, 0],
    [1, 0, 1]
]
 
fractal('test1', test1)
fractal('test2', test2)
fractal('test3', test3)
 "
21ld,python,LU decomposition,Mathematics,Numerical Methods,"from pprint import pprint
 
def matrixMul(A, B):
    TB = zip(*B)
    return [[sum(ea*eb for ea,eb in zip(a,b)) for b in TB] for a in A]
 
def pivotize(m):
    """"""Creates the pivoting matrix for m.""""""
    n = len(m)
    ID = [[float(i == j) for i in xrange(n)] for j in xrange(n)]
    for j in xrange(n):
        row = max(xrange(j, n), key=lambda i: abs(m[i][j]))
        if j != row:
            ID[j], ID[row] = ID[row], ID[j]
    return ID
 
def lu(A):
    """"""Decomposes a nxn matrix A by PA=LU and returns L, U and P.""""""
    n = len(A)
    L = [[0.0] * n for i in xrange(n)]
    U = [[0.0] * n for i in xrange(n)]
    P = pivotize(A)
    A2 = matrixMul(P, A)
    for j in xrange(n):
        L[j][j] = 1.0
        for i in xrange(j+1):
            s1 = sum(U[k][j] * L[i][k] for k in xrange(i))
            U[i][j] = A2[i][j] - s1
        for i in xrange(j, n):
            s2 = sum(U[k][j] * L[i][k] for k in xrange(j))
            L[i][j] = (A2[i][j] - s2) / U[j][j]
    return (L, U, P)
 
a = [[1, 3, 5], [2, 4, 7], [1, 1, 0]]
for part in lu(a):
    pprint(part, width=19)
    print
print
b = [[11,9,24,2],[1,5,2,6],[3,17,18,1],[2,5,7,1]]
for part in lu(b):
    pprint(part)
    print"
v93v,python,LZW compression,Algorithms and Data Structures,Algorithms,"def compress(uncompressed):
    """"""Compress a string to a list of output symbols.""""""
 
    # Build the dictionary.
    dict_size = 256
    dictionary = dict((chr(i), i) for i in range(dict_size))
    # in Python 3: dictionary = {chr(i): i for i in range(dict_size)}
 
    w = """"
    result = []
    for c in uncompressed:
        wc = w + c
        if wc in dictionary:
            w = wc
        else:
            result.append(dictionary[w])
            # Add wc to the dictionary.
            dictionary[wc] = dict_size
            dict_size += 1
            w = c
 
    # Output the code for w.
    if w:
        result.append(dictionary[w])
    return result
 
 
def decompress(compressed):
    """"""Decompress a list of output ks to a string.""""""
    from io import StringIO
 
    # Build the dictionary.
    dict_size = 256
    dictionary = dict((i, chr(i)) for i in range(dict_size))
    # in Python 3: dictionary = {i: chr(i) for i in range(dict_size)}
 
    # use StringIO, otherwise this becomes O(N^2)
    # due to string concatenation in a loop
    result = StringIO()
    w = chr(compressed.pop(0))
    result.write(w)
    for k in compressed:
        if k in dictionary:
            entry = dictionary[k]
        elif k == dict_size:
            entry = w + w[0]
        else:
            raise ValueError('Bad compressed k: %s' % k)
        result.write(entry)
 
        # Add w+entry[0] to the dictionary.
        dictionary[dict_size] = w + entry[0]
        dict_size += 1
 
        w = entry
    return result.getvalue()
 
 
# How to use:
compressed = compress('TOBEORNOTTOBEORTOBEORNOT')
print (compressed)
decompressed = decompress(compressed)
print (decompressed)"
wn7y,python,Lah numbers,Mathematics,Combinatorics,"def factorial(n):
    if n == 0:
        return 1
    res = 1
    while n > 0:
        res *= n
        n -= 1
    return res
 
def lah(n,k):
    if k == 1:
        return factorial(n)
    if k == n:
        return 1
    if k > n:
        return 0
    if k < 1 or n < 1:
        return 0
    return (factorial(n) * factorial(n - 1)) / (factorial(k) * factorial(k - 1)) / factorial(n - k)
 
def main():
    print ""Unsigned Lah numbers: L(n, k):""
    print ""n/k "",
    for i in xrange(13):
        print ""%11d"" % i,
    print
    for row in xrange(13):
        print ""%-4d"" % row,
        for i in xrange(row + 1):
            l = lah(row, i)
            print ""%11d"" % l,
        print
    print ""\nMaximum value from the L(100, *) row:""
    maxVal = max([lah(100, a) for a in xrange(100)])
    print maxVal
 
main()"
heax,python,Langton's ant,Puzzles and Games,Simulation and Modeling," 
""""""Langton's ant implementation.""""""
from enum import Enum, IntEnum
 
 
class Dir(IntEnum):
    """"""Possible directions.""""""
 
    UP = 0
    RIGHT = 1
    DOWN = 2
    LEFT = 3
 
 
class Color(Enum):
    """"""Possible colors.""""""
 
    WHITE = "" ""
    BLACK = ""#""
 
 
def invert_color(grid, x, y):
    """"""Invert the color of grid at x, y coordinate.""""""
    if grid[y][x] == Color.BLACK:
        grid[y][x] = Color.WHITE
    else:
        grid[y][x] = Color.BLACK
 
 
def next_direction(grid, x, y, direction):
    """"""Compute next direction according to current position and direction.""""""
    if grid[y][x] == Color.BLACK:
        turn_right = False
    else:
        turn_right = True
    direction_index = direction.value
    if turn_right:
        direction_index = (direction_index + 1) % 4
    else:
        direction_index = (direction_index - 1) % 4
    directions = [Dir.UP, Dir.RIGHT, Dir.DOWN, Dir.LEFT]
    direction = directions[direction_index]
    return direction
 
 
def next_position(x, y, direction):
    """"""Compute next position according to direction.""""""
    if direction == Dir.UP:
        y -= 1
    elif direction == Dir.RIGHT:
        x -= 1
    elif direction == Dir.DOWN:
        y += 1
    elif direction == Dir.LEFT:
        x += 1
    return x, y
 
 
def print_grid(grid):
    """"""Display grid.""""""
    print(80 * ""#"")
    print(""\n"".join("""".join(v.value for v in row) for row in grid))
 
 
def ant(width, height, max_nb_steps):
    """"""Langton's ant.""""""
    grid = [[Color.WHITE] * width for _ in range(height)]
    x = width // 2
    y = height // 2
    direction = Dir.UP
 
    i = 0
    while i < max_nb_steps and 0 <= x < width and 0 <= y < height:
        invert_color(grid, x, y)
        direction = next_direction(grid, x, y, direction)
        x, y = next_position(x, y, direction)
        print_grid(grid)
        i += 1
 
 
if __name__ == ""__main__"":
    ant(width=75, height=52, max_nb_steps=12000)
 "
vatl,python,Largest int from concatenated ints,Algorithms and Data Structures,Algorithms,"try:
    cmp     # Python 2 OK or NameError in Python 3
    def maxnum(x):
        return ''.join(sorted((str(n) for n in x),
                              cmp=lambda x,y:cmp(y+x, x+y)))
except NameError:
    # Python 3
    from functools import cmp_to_key
    def cmp(x, y):
        return -1 if x<y else ( 0 if x==y else 1)
    def maxnum(x):
        return ''.join(sorted((str(n) for n in x),
                              key=cmp_to_key(lambda x,y:cmp(y+x, x+y))))
 
for numbers in [(1, 34, 3, 98, 9, 76, 45, 4), (54, 546, 548, 60)]:
    print('Numbers: %r\n  Largest integer: %15s' % (numbers, maxnum(numbers)))"
hvm9,python,Largest number divisible by its digits,Mathematics,Number Theory,"'''Largest number divisible by its digits'''
 
from itertools import (chain, permutations)
from functools import (reduce)
from math import (gcd)
 
 
# main :: IO ()
def main():
    '''Tests'''
 
    # (Division by zero is not an option, so 0 and 5 are omitted)
    digits = [1, 2, 3, 4, 6, 7, 8, 9]
 
    # Least common multiple of the digits above
    lcmDigits = reduce(lcm, digits)
 
    # Any 7 items drawn from the digits above,
    # including any two of [1, 4, 7]
    sevenDigits = ((delete)(digits)(x) for x in [1, 4, 7])
 
    print(
        max(
            (
                intFromDigits(x) for x
                in concatMap(permutations)(sevenDigits)
            ),
            key=lambda n: n if 0 == n % lcmDigits else 0
        )
    )
 
 
# intFromDigits :: [Int] -> Int
def intFromDigits(xs):
    '''An integer derived from an
       ordered list of digits.
    '''
    return reduce(lambda a, x: a * 10 + x, xs, 0)
 
 
# ----------------------- GENERIC ------------------------
 
# concatMap :: (a -> [b]) -> [a] -> [b]
def concatMap(f):
    '''A concatenated list over which a function has been
       mapped. The list monad can be derived by using a
       function f which wraps its output in a list,
       (using an empty list to represent computational failure).
    '''
    def go(xs):
        return chain.from_iterable(map(f, xs))
    return go
 
 
# delete :: Eq a => [a] -> a -> [a]
def delete(xs):
    '''xs with the first instance of
       x removed.
    '''
    def go(x):
        ys = xs.copy()
        ys.remove(x)
        return ys
    return go
 
 
# lcm :: Int -> Int -> Int
def lcm(x, y):
    '''The smallest positive integer divisible
       without remainder by both x and y.
    '''
    return 0 if (0 == x or 0 == y) else abs(
        y * (x // gcd(x, y))
    )
 
 
# MAIN ---
if __name__ == '__main__':
    main()"
5g3q,python,Largest proper divisor of n,Mathematics,Number Theory,"def lpd(n):
    for i in range(n-1,0,-1):
        if n%i==0: return i
    return 1
 
for i in range(1,101):
    print(""{:3}"".format(lpd(i)), end=i%10==0 and '\n' or '')"
3ofh,python,Last Friday of each month,Mathematics,Combinatorics,"import calendar
 
def last_fridays(year):
    for month in range(1, 13):
        last_friday = max(week[calendar.FRIDAY]
            for week in calendar.monthcalendar(year, month))
        print('{:4d}-{:02d}-{:02d}'.format(year, month, last_friday))"
n3wc,python,Last letter-first letter,Puzzles and Games,Puzzle Solving Algorithms,"from collections import defaultdict
 
def order_words(words):
    byfirst = defaultdict(set)
    for word in words:
        byfirst[word[0]].add( word )
    #byfirst = dict(byfirst)
    return byfirst
 
def linkfirst(byfirst, sofar):
    '''\
    For all words matching last char of last word in sofar as FIRST char and not in sofar,
    return longest chain as sofar + chain
    '''
 
    assert sofar
    chmatch = sofar[-1][-1]
    options = byfirst[chmatch] - set(sofar)
    #print('  linkfirst options: %r %r' % (chmatch, options))
    if not options:
        return sofar
    else:
        alternatives = ( linkfirst(byfirst, list(sofar) + [word])
                         for word in options )
        mx = max( alternatives, key=len )
        #input('linkfirst: %r' % mx)
        return mx
 
def llfl(words):
 
    byfirst = order_words(words)
    return max( (linkfirst(byfirst, [word]) for word in words), key=len )
 
if __name__ == '__main__':
    pokemon = '''audino bagon baltoy banette bidoof braviary bronzor carracosta charmeleon
cresselia croagunk darmanitan deino emboar emolga exeggcute gabite
girafarig gulpin haxorus heatmor heatran ivysaur jellicent jumpluff kangaskhan
kricketune landorus ledyba loudred lumineon lunatone machamp magnezone mamoswine
nosepass petilil pidgeotto pikachu pinsir poliwrath poochyena porygon2
porygonz registeel relicanth remoraid rufflet sableye scolipede scrafty seaking
sealeo silcoon simisear snivy snorlax spoink starly tirtouga trapinch treecko
tyrogue vigoroth vulpix wailord wartortle whismur wingull yamask'''
    pokemon = pokemon.strip().lower().split()
    pokemon = sorted(set(pokemon))    
    l = llfl(pokemon)
    for i in range(0, len(l), 8): print(' '.join(l[i:i+8]))
    print(len(l))"
ckwy,python,Latin Squares in reduced form,Mathematics,Combinatorics,"def dList(n, start):
    start -= 1 # use 0 basing
    a = range(n)
    a[start] = a[0]
    a[0] = start
    a[1:] = sorted(a[1:])
    first = a[1]
    # rescursive closure permutes a[1:]
    r = []
    def recurse(last):
        if (last == first):
            # bottom of recursion. you get here once for each permutation.
            # test if permutation is deranged.
            # yes, save a copy with 1 based indexing
            for j,v in enumerate(a[1:]):
                if j + 1 == v:
                    return # no, ignore it
            b = [x + 1 for x in a]
            r.append(b)
            return
        for i in xrange(last, 0, -1):
            a[i], a[last] = a[last], a[i]
            recurse(last - 1)
            a[i], a[last] = a[last], a[i]
    recurse(n - 1)
    return r
 
def printSquare(latin,n):
    for row in latin:
        print row
    print
 
def reducedLatinSquares(n,echo):
    if n <= 0:
        if echo:
            print []
        return 0
    elif n == 1:
        if echo:
            print [1]
        return 1
 
    rlatin = [None] * n
    for i in xrange(n):
        rlatin[i] = [None] * n
    # first row
    for j in xrange(0, n):
        rlatin[0][j] = j + 1
 
    class OuterScope:
        count = 0
    def recurse(i):
        rows = dList(n, i)
 
        for r in xrange(len(rows)):
            rlatin[i - 1] = rows[r]
            justContinue = False
            k = 0
            while not justContinue and k < i - 1:
                for j in xrange(1, n):
                    if rlatin[k][j] == rlatin[i - 1][j]:
                        if r < len(rows) - 1:
                            justContinue = True
                            break
                        if i > 2:
                            return
                k += 1
            if not justContinue:
                if i < n:
                    recurse(i + 1)
                else:
                    OuterScope.count += 1
                    if echo:
                        printSquare(rlatin, n)
 
    # remaining rows
    recurse(2)
    return OuterScope.count
 
def factorial(n):
    if n == 0:
        return 1
    prod = 1
    for i in xrange(2, n + 1):
        prod *= i
    return prod
 
print ""The four reduced latin squares of order 4 are:\n""
reducedLatinSquares(4,True)
 
print ""The size of the set of reduced latin squares for the following orders""
print ""and hence the total number of latin squares of these orders are:\n""
for n in xrange(1, 7):
    size = reducedLatinSquares(n, False)
    f = factorial(n - 1)
    f *= f * n * size
    print ""Order %d: Size %-4d x %d! x %d! => Total %d"" % (n, size, n, n - 1, f)"
96p8,python,Law of cosines - triples,Mathematics,Geometry and Trigonometry,"N = 13
 
def method1(N=N):
    squares = [x**2 for x in range(0, N+1)]
    sqrset = set(squares)
    tri90, tri60, tri120 = (set() for _ in range(3))
    for a in range(1, N+1):
        a2 = squares[a]
        for b in range(1, a + 1):
            b2 = squares[b]
            c2 = a2 + b2
            if c2 in sqrset:
                tri90.add(tuple(sorted((a, b, int(c2**0.5)))))
            ab = a * b
            c2 -= ab
            if c2 in sqrset:
                tri60.add(tuple(sorted((a, b, int(c2**0.5)))))
            c2 += 2 * ab
            if c2 in sqrset:
                tri120.add(tuple(sorted((a, b, int(c2**0.5)))))
    return  sorted(tri90), sorted(tri60), sorted(tri120)
#%%
if __name__ == '__main__':
    print(f'Integer triangular triples for sides 1..{N}:')
    for angle, triples in zip([90, 60, 120], method1(N)):
        print(f'  {angle:3}° has {len(triples)} solutions:\n    {triples}')
    _, t60, _ = method1(10_000)
    notsame = sum(1 for a, b, c in t60 if a != b or b != c)
    print('Extra credit:', notsame)"
ika2,python,Leap year,Mathematics,Algebra and Arithmetic,"import calendar
calendar.isleap(year)"
wsz6,python,Least common multiple,Mathematics,Algebra and Arithmetic,">>> import fractions
>>> def lcm(a,b): return abs(a * b) / fractions.gcd(a,b) if a and b else 0
 
>>> lcm(12, 18)
36
>>> lcm(-6, 14)
42
>>> assert lcm(0, 2) == lcm(2, 0) == 0
>>> "
8xtd,python,Left factorials,Mathematics,Combinatorics,"from itertools import islice
 
def lfact():
    yield 0
    fact, summ, n = 1, 0, 1 
    while 1:
        fact, summ, n = fact*n, summ + fact, n + 1
        yield summ
 
print('first 11:\n  %r' % [lf for i, lf in zip(range(11), lfact())])
print('20 through 110 (inclusive) by tens:')
for lf in islice(lfact(), 20, 111, 10):
    print(lf)
print('Digits in 1,000 through 10,000 (inclusive) by thousands:\n  %r' 
      % [len(str(lf)) for lf in islice(lfact(), 1000, 10001, 1000)] )"
rbl4,python,Legendre prime counting function,Mathematics,Number Theory,"from primesieve import primes
from math import isqrt
from functools import cache
 
p = primes(isqrt(1_000_000_000))
 
@cache
def phi(x, a):
    res = 0
    while True:
        if not a or not x:
            return x + res
 
        a -= 1
        res -= phi(x//p[a], a) # partial tail recursion
 
def legpi(n):
    if n < 2: return 0
 
    a = legpi(isqrt(n))
    return phi(n, a) + a - 1
 
for e in range(10):
    print(f'10^{e}', legpi(10**e))"
f55y,python,Leonardo numbers,Mathematics,Mathematical Sequences and Series,"def Leonardo(L_Zero, L_One, Add, Amount):
    terms = [L_Zero,L_One]
    while len(terms) < Amount:
        new = terms[-1] + terms[-2]
        new += Add
        terms.append(new)
    return terms
 
out = """"
print ""First 25 Leonardo numbers:""
for term in Leonardo(1,1,1,25):
    out += str(term) + "" ""
print out
 
out = """"
print ""Leonardo numbers with fibonacci parameters:""
for term in Leonardo(0,1,0,25):
    out += str(term) + "" ""
print out
 "
v3ie,python,Letter frequency,Text Processing,String Manipulation,"import collections, sys
 
def filecharcount(openfile):
    return sorted(collections.Counter(c for l in openfile for c in l).items())
 
f = open(sys.argv[1])
print(filecharcount(f))"
8qhl,python,Levenshtein distance,Text Processing,String Manipulation,"def levenshteinDistance(str1, str2):
    m = len(str1)
    n = len(str2)
    d = [[i] for i in range(1, m + 1)]   # d matrix rows
    d.insert(0, list(range(0, n + 1)))   # d matrix columns
    for j in range(1, n + 1):
        for i in range(1, m + 1):
            if str1[i - 1] == str2[j - 1]:   # Python (string) is 0-based
                substitutionCost = 0
            else:
                substitutionCost = 1
            d[i].insert(j, min(d[i - 1][j] + 1,
                               d[i][j - 1] + 1,
                               d[i - 1][j - 1] + substitutionCost))
    return d[-1][-1]
 
print(levenshteinDistance(""kitten"",""sitting""))
print(levenshteinDistance(""rosettacode"",""raisethysword""))"
ipnj,python,Levenshtein distance/Alignment,Text Processing,String Manipulation,"from difflib import ndiff
 
def levenshtein(str1, str2):
    result = """"
    pos, removed = 0, 0
    for x in ndiff(str1, str2):
        if pos<len(str1) and str1[pos] == x[2]:
          pos += 1
          result += x[2]
          if x[0] == ""-"":
              removed += 1
          continue
        else:
          if removed > 0:
            removed -=1
          else:
            result += ""-""
    print(result)
 
levenshtein(""place"",""palace"")
levenshtein(""rosettacode"",""raisethysword"")"
vl4e,python,Linear congruential generator,Mathematics,Probability and Statistics,"def bsd_rand(seed):
   def rand():
      rand.seed = (1103515245*rand.seed + 12345) & 0x7fffffff
      return rand.seed
   rand.seed = seed
   return rand
 
def msvcrt_rand(seed):
   def rand():
      rand.seed = (214013*rand.seed + 2531011) & 0x7fffffff
      return rand.seed >> 16
   rand.seed = seed
   return rand"
q7vo,python,List comprehensions,Programming Concepts,Fundamentals,"[(x,y,z) for x in xrange(1,n+1) for y in xrange(x,n+1) for z in xrange(y,n+1) if x**2 + y**2 == z**2]"
msgu,python,List rooted trees,Puzzles and Games,Logic and Mathematical Puzzles,"def bags(n,cache={}):
	if not n: return [(0, """")]
 
	upto = sum([bags(x) for x in range(n-1, 0, -1)], [])
	return [(c+1, '('+s+')') for c,s in bagchain((0, """"), n-1, upto)]
 
def bagchain(x, n, bb, start=0):
	if not n: return [x]
 
	out = []
	for i in range(start, len(bb)):
		c,s = bb[i]
		if c <= n: out += bagchain((x[0] + c, x[1] + s), n-c, bb, i)
	return out
 
# Maybe this lessens eye strain. Maybe not.
def replace_brackets(s):
	depth,out = 0,[]
	for c in s:
		if c == '(':
			out.append(""([{""[depth%3])
			depth += 1
		else:
			depth -= 1
			out.append("")]}""[depth%3])
	return """".join(out)
 
for x in bags(5): print(replace_brackets(x[1]))"
3bp9,python,Literals/Floating point,Programming Concepts,Fundamentals,"FLOAT
    :   '.' DIGITS (Exponent)?
    |   DIGITS '.' Exponent
    |   DIGITS ('.' (DIGITS (Exponent)?)? | Exponent)
    ;
 
DIGITS : ( '0' .. '9' )+ ;
 
Exponent
    :    ('e' | 'E') ( '+' | '-' )? DIGITS
    ;"
5ygu,python,Literals/Integer,Programming Concepts,Fundamentals,">>> # Bin(leading 0b or 0B), Oct(leading 0o or 0O), Dec, Hex(leading 0x or 0X), in order:
>>> 0b1011010111 == 0o1327 == 727 == 0x2d7
True
>>>"
s8gy,python,Literals/String,Text Processing,String Manipulation,"'c' == ""c"" # character
'text' == ""text""
' "" '
"" ' ""
'\x20' == ' '
u'unicode string'
u'\u05d0' # unicode literal"
ham7,python,Logical operations,Programming Concepts,Fundamentals,"def logic(a, b):
    print('a and b:', a and b)
    print('a or b:', a or b)
    print('not a:', not a)"
gukc,python,"Long literals, with continuations",Programming Concepts,Fundamentals,"""""""Long string literal. Requires Python 3.6+ for f-strings.""""""
 
revision = ""October 13th 2020""
 
# String literal continuation. Notice the trailing space at the end of each
# line but the last, and the lack of commas. There is exactly one ""blank""
# between each item in the list.
elements = (
    ""hydrogen helium lithium beryllium boron carbon nitrogen oxygen fluorine ""
    ""neon sodium magnesium aluminum silicon phosphorous sulfur chlorine argon ""
    ""potassium calcium scandium titanium vanadium chromium manganese iron ""
    ""cobalt nickel copper zinc gallium germanium arsenic selenium bromine ""
    ""krypton rubidium strontium yttrium zirconium niobium molybdenum ""
    ""technetium ruthenium rhodium palladium silver cadmium indium tin ""
    ""antimony tellurium iodine xenon cesium barium lanthanum cerium ""
    ""praseodymium neodymium promethium samarium europium gadolinium terbium ""
    ""dysprosium holmium erbium thulium ytterbium lutetium hafnium tantalum ""
    ""tungsten rhenium osmium iridium platinum gold mercury thallium lead ""
    ""bismuth polonium astatine radon francium radium actinium thorium ""
    ""protactinium uranium neptunium plutonium americium curium berkelium ""
    ""californium einsteinium fermium mendelevium nobelium lawrencium ""
    ""rutherfordium dubnium seaborgium bohrium hassium meitnerium darmstadtium ""
    ""roentgenium copernicium nihonium flerovium moscovium livermorium ""
    ""tennessine oganesson""
)
 
 
def report():
    """"""Write a summary report to stdout.""""""
    items = elements.split()
 
    print(f""Last revision date: {revision}"")
    print(f""Number of elements: {len(items)}"")
    print(f""Last element      : {items[-1]}"")
 
 
if __name__ == ""__main__"":
    report()
 "
e1hj,python,Long multiplication,Mathematics,Algebra and Arithmetic,"#!/usr/bin/env python
print 2**64*2**64"
xio9,python,Long primes,Mathematics,Number Theory,"def sieve(limit):
    primes = []
    c = [False] * (limit + 1) # composite = true
    # no need to process even numbers
    p = 3
    while True:
        p2 = p * p
        if p2 > limit: break
        for i in range(p2, limit, 2 * p): c[i] = True
        while True:
            p += 2
            if not c[p]: break
 
    for i in range(3, limit, 2):
        if not c[i]: primes.append(i)
    return primes
 
# finds the period of the reciprocal of n
def findPeriod(n):
    r = 1
    for i in range(1, n): r = (10 * r) % n
    rr = r
    period = 0
    while True:
        r = (10 * r) % n
        period += 1
        if r == rr: break
    return period
 
primes = sieve(64000)
longPrimes = []
for prime in primes:
    if findPeriod(prime) == prime - 1:
        longPrimes.append(prime)
numbers = [500, 1000, 2000, 4000, 8000, 16000, 32000, 64000]
count = 0
index = 0
totals = [0] * len(numbers)
for longPrime in longPrimes:
    if longPrime > numbers[index]:
        totals[index] = count
        index += 1
    count += 1
totals[-1] = count
print('The long primes up to 500 are:')
print(str(longPrimes[:totals[0]]).replace(',', ''))
print('\nThe number of long primes up to:')
for (i, total) in enumerate(totals):
    print('  %5d is %d' % (numbers[i], total))"
xjua,python,Long year,Mathematics,Combinatorics,"'''Long Year ?'''
 
from datetime import date
 
 
# longYear :: Year Int -> Bool
def longYear(y):
    '''True if the ISO year y has 53 weeks.'''
    return 52 < date(y, 12, 28).isocalendar()[1]
 
 
# --------------------------TEST---------------------------
# main :: IO ()
def main():
    '''Longer (53 week) years in the range 2000-2100'''
    for year in [
            x for x in range(2000, 1 + 2100)
            if longYear(x)
    ]:
        print(year)
 
 
# MAIN ---
if __name__ == '__main__':
    main()"
vl8a,python,Longest common subsequence,Algorithms and Data Structures,Algorithms,"def lcs(xstr, ystr):
    """"""
    >>> lcs('thisisatest', 'testing123testing')
    'tsitest'
    """"""
    if not xstr or not ystr:
        return """"
    x, xs, y, ys = xstr[0], xstr[1:], ystr[0], ystr[1:]
    if x == y:
        return str(lcs(xs, ys)) + x
    else:
        return max(lcs(xstr, ys), lcs(xs, ystr), key=len)"
fe0k,python,Longest common substring,Algorithms and Data Structures,Algorithms,"s1 = ""thisisatest""
s2 = ""testing123testing""
len1, len2 = len(s1), len(s2)
ir, jr = 0, -1
for i1 in range(len1):
    i2 = s2.find(s1[i1])
    while i2 >= 0:
        j1, j2 = i1, i2
        while j1 < len1 and j2 < len2 and s2[j2] == s1[j1]:
            if j1-i1 >= jr-ir:
                ir, jr = i1, j1
            j1 += 1; j2 += 1
        i2 = s2.find(s1[i1], i2+1)
print (s1[ir:jr+1])"
exw6,python,Longest increasing subsequence,Algorithms and Data Structures,Algorithms,"def longest_increasing_subsequence(X):
    """"""Returns the Longest Increasing Subsequence in the Given List/Array""""""
    N = len(X)
    P = [0] * N
    M = [0] * (N+1)
    L = 0
    for i in range(N):
       lo = 1
       hi = L
       while lo <= hi:
           mid = (lo+hi)//2
           if (X[M[mid]] < X[i]):
               lo = mid+1
           else:
               hi = mid-1
 
       newL = lo
       P[i] = M[newL-1]
       M[newL] = i
 
       if (newL > L):
           L = newL
 
    S = []
    k = M[L]
    for i in range(L-1, -1, -1):
        S.append(X[k])
        k = P[k]
    return S[::-1]
 
if __name__ == '__main__':
    for d in [[3,2,6,4,5,1], [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]]:
        print('a L.I.S. of %s is %s' % (d, longest_increasing_subsequence(d)))"
z5z2,python,Longest string challenge,Puzzles and Games,Logic and Mathematical Puzzles,"import fileinput
 
# This returns True if the second string has a value on the 
# same index as the last index of the first string. It runs
# faster than trimming the strings because it runs len once
# and is a single index lookup versus slicing both strings 
# one character at a time.
def longer(a, b):
    try:
        b[len(a)-1]
        return False
    except:
        return True
 
longest, lines = '', ''
for x in fileinput.input():
    if longer(x, longest):
        lines, longest = x, x
    elif not longer(longest, x):
        lines += x
 
print(lines, end='')"
4ixo,python,Look-and-say sequence,Mathematics,Mathematical Sequences and Series,"def lookandsay(number):
    result = """"
 
    repeat = number[0]
    number = number[1:]+"" ""
    times = 1
 
    for actual in number:
        if actual != repeat:
            result += str(times)+repeat
            times = 1
            repeat = actual
        else:
            times += 1
 
    return result
 
num = ""1""
 
for i in range(10):
    print num
    num = lookandsay(num)"
1a3u,python,Loop over multiple arrays simultaneously,Algorithms and Data Structures,Algorithms,">>> print ( '\n'.join(''.join(x) for x in 
zip('abc', 'ABC', '123')) )
aA1
bB2
cC3
>>>"
6b4u,python,Loops/Break,Programming Concepts,Fundamentals,"from random import randrange
 
while True:
    a = randrange(20)
    print(a)
    if a == 10:
        break
    b = randrange(20)
    print(b)"
vgpt,python,Loops/Continue,Programming Concepts,Fundamentals,"for i in xrange(1,11):
    if i % 5 == 0:
        print i
        continue
    print i, "","","
15pr,python,Loops/Do-while,Programming Concepts,Fundamentals,"val = 0
while True:
   val +=1
   print val
   if val % 6 == 0: break"
hk2o,python,Loops/Downward for,Programming Concepts,Fundamentals,"for i in xrange(10, -1, -1):
    print i"
qiaq,python,Loops/For,Programming Concepts,Fundamentals,"import sys
for i in xrange(5):
    for j in xrange(i+1):
        sys.stdout.write(""*"")
    print"
21bf,python,Loops/For with a specified step,Programming Concepts,Fundamentals,"for i in xrange(2, 9, 2):
    print ""%d,"" % i,
print ""who do we appreciate?"""
ihua,python,Loops/Foreach,Programming Concepts,Fundamentals,"for i in collection:
   print i"
6gf3,python,Loops/Increment loop index within loop body,Algorithms and Data Structures,Algorithms,"def isPrime(n):
    for x in 2, 3:
        if not n % x:
            return n == x
    d = 5
    while d * d <= n:
        for x in 2, 4:
            if not n % d:
                return False
            d += x
    return True
 
i = 42
n = 0
while n < 42:
    if isPrime(i):
        n += 1
        print('n = {:2} {:20,}'.format(n, i))
        i += i - 1
    i += 1"
1jfv,python,Loops/Infinite,Programming Concepts,Fundamentals,"while 1:
   print ""SPAM"""
12q6,python,Loops/N plus one half,Programming Concepts,Fundamentals,"print ( ', '.join(str(i+1) for i in range(10)) )"
83zh,python,Loops/Nested,Algorithms and Data Structures,Algorithms,"from random import randint
 
def do_scan(mat):
    for row in mat:
        for item in row:
            print item,
            if item == 20:
                print
                return
        print
    print
 
mat = [[randint(1, 20) for x in xrange(10)] for y in xrange(10)]
do_scan(mat)"
td6c,python,Loops/While,Programming Concepts,Fundamentals,"n = 1024
while n > 0:
    print n
    n //= 2"
ajpl,python,Loops/With multiple ranges,Programming Concepts,Fundamentals,"from itertools import chain
 
prod, sum_, x, y, z, one,three,seven = 1, 0, 5, -5, -2, 1, 3, 7
 
def _range(x, y, z=1):
    return range(x, y + (1 if z > 0 else -1), z)
 
print(f'list(_range(x, y, z)) = {list(_range(x, y, z))}')
print(f'list(_range(-seven, seven, x)) = {list(_range(-seven, seven, x))}')
 
for j in chain(_range(-three, 3**3, three), _range(-seven, seven, x), 
               _range(555, 550 - y), _range(22, -28, -three),
               _range(1927, 1939), _range(x, y, z),
               _range(11**x, 11**x + 1)):
    sum_ += abs(j)
    if abs(prod) < 2**27 and (j != 0):
        prod *= j
print(f' sum= {sum_}\nprod= {prod}')"
rn0o,python,Loops/Wrong ranges,Programming Concepts,Fundamentals,"import re
from itertools import islice # To limit execution if it would generate huge values 
# list(islice('ABCDEFG', 2)) --> ['A', 'B']
# list(islice('ABCDEFG', 4)) --> ['A', 'B', 'C', 'D']
 
 
data = '''
start 	stop 	increment 	Comment
-2 	2 	1 	Normal
-2 	2 	0 	Zero increment
-2 	2 	-1 	Increments away from stop value
-2 	2 	10 	First increment is beyond stop value
2 	-2 	1 	Start more than stop: positive increment
2 	2 	1 	Start equal stop: positive increment
2 	2 	-1 	Start equal stop: negative increment
2 	2 	0 	Start equal stop: zero increment
0 	0 	0 	Start equal stop equal zero: zero increment 
'''
 
table = [re.split(r'\s\s+', line.strip()) for line in data.strip().split('\n')]
#%%
for _start, _stop, _increment, comment in table[1:]:
    start, stop, increment = [int(x) for x in (_start, _stop, _increment)]
    print(f'{comment.upper()}:\n  range({start}, {stop}, {increment})')
    values = None
    try: 
        values = list(islice(range(start, stop, increment), 999))
    except ValueError as e:
        print('  !!ERROR!!', e)
    if values is not None:
        if len(values) < 22:
            print('    =', values)
        else:
            print('    =', str(values[:22])[:-1], '...')
 "
s0t8,python,Lucas-Lehmer test,Mathematics,Number Theory," 
from sys import stdout
from math import sqrt, log
 
def is_prime ( p ):
  if p == 2: return True # Lucas-Lehmer test only works on odd primes
  elif p <= 1 or p % 2 == 0: return False
  else:
    for i in range(3, int(sqrt(p))+1, 2 ): 
      if p % i == 0: return False
    return True
 
def is_mersenne_prime ( p ):
  if p == 2:
    return True
  else:
    m_p = ( 1 << p ) - 1
    s = 4
    for i in range(3, p+1): 
      s = (s ** 2 - 2) % m_p
    return s == 0
 
precision = 20000   # maximum requested number of decimal places of 2 ** MP-1 #
long_bits_width = precision * log(10, 2)
upb_prime = int( long_bits_width - 1 ) / 2    # no unsigned #
upb_count = 45      # find 45 mprimes if int was given enough bits #
 
print ("" Finding Mersenne primes in M[2..%d]:""%upb_prime)
 
count=0
for p in range(2, int(upb_prime+1)): 
  if is_prime(p) and is_mersenne_prime(p):
    print(""M%d""%p),
    stdout.flush()
    count += 1
  if count >= upb_count: break
print
 "
2ajq,python,Lucky and even lucky numbers,Puzzles and Games,Logic and Mathematical Puzzles,"from __future__ import print_function
 
def lgen(even=False, nmax=1000000):
    start = 2 if even else 1
    n, lst = 1, list(range(start, nmax + 1, 2))
    lenlst = len(lst)
    yield lst[0]
    while n < lenlst and lst[n] < lenlst:
        yield lst[n]
        n, lst = n + 1, [j for i,j in enumerate(lst, 1) if i % lst[n]]
        lenlst = len(lst)
    # drain
    for i in lst[n:]:
        yield i"
sjs8,python,Ludic numbers,Mathematics,Combinatorics,"def ludic(nmax=100000):
    yield 1
    lst = list(range(2, nmax + 1))
    while lst:
        yield lst[0]
        del lst[::lst[0]]
 
ludics = [l for l in ludic()]
 
print('First 25 ludic primes:')
print(ludics[:25])
print(""\nThere are %i ludic numbers <= 1000""
      % sum(1 for l in ludics if l <= 1000)) 
print(""\n2000'th..2005'th ludic primes:"")
print(ludics[2000-1: 2005])
 
n = 250
triplets = [(x, x+2, x+6)
            for x in ludics
            if x+6 < n and x+2 in ludics and x+6 in ludics]
print('\nThere are %i triplets less than %i:\n  %r'
      % (len(triplets), n, triplets))"
w8w9,python,Luhn test of credit card numbers,Mathematics,Number Theory,">>> def luhn(n):
	r = [int(ch) for ch in str(n)][::-1]
	return (sum(r[0::2]) + sum(sum(divmod(d*2,10)) for d in r[1::2])) % 10 == 0
 
>>> for n in (49927398716, 49927398717, 1234567812345678, 1234567812345670):
	print(n, luhn(n))"
e0z1,python,Lychrel numbers,Mathematics,Number Theory,"from __future__ import print_function
 
def add_reverse(num, max_iter=1000):
    i, nums = 0, {num}
    while True:
        i, num = i+1, num + reverse_int(num)
        nums.add(num)
        if reverse_int(num) == num or i >= max_iter:
            break
    return nums
 
#@functools.lru_cache(maxsize=2**20)
def reverse_int(num):
    return int(str(num)[::-1])
 
def split_roots_from_relateds(roots_and_relateds):
    roots = roots_and_relateds[::]
    i = 1
    while i < len(roots):
        this = roots[i]
        if any(this.intersection(prev) for prev in roots[:i]):
            del roots[i]
        else:
            i += 1
    root = [min(each_set) for each_set in roots]
    related = [min(each_set) for each_set in roots_and_relateds]
    related = [n for n in related if n not in root]
    return root, related
 
def find_lychrel(maxn, max_reversions):
    'Lychrel number generator'
    series = [add_reverse(n, max_reversions*2) for n in range(1, maxn + 1)]
    roots_and_relateds = [s for s in series if len(s) > max_reversions]
    return split_roots_from_relateds(roots_and_relateds)
 
 
if __name__ == '__main__':
    maxn, reversion_limit = 10000, 500
    print(""Calculations using n = 1..%i and limiting each search to 2*%i reverse-digits-and-adds""
          % (maxn, reversion_limit))
    lychrel, l_related = find_lychrel(maxn, reversion_limit)
    print('  Number of Lychrel numbers:', len(lychrel))
    print('    Lychrel numbers:', ', '.join(str(n) for n in lychrel))
    print('  Number of Lychrel related:', len(l_related))
    #print('    Lychrel related:', ', '.join(str(n) for n in l_related))
    pals = [x for x in lychrel + l_related  if x == reverse_int(x)]
    print('  Number of Lychrel palindromes:', len(pals))
    print('    Lychrel palindromes:', ', '.join(str(n) for n in pals))"
09ts,python,MAC Vendor Lookup,Networking and Web Development,Networking,"import requests
 
for addr in ['88:53:2E:67:07:BE', 'FC:FB:FB:01:FA:21',
        'D4:F4:6F:C9:EF:8D', '23:45:67']:
    vendor = requests.get('http://api.macvendors.com/' + addr).text
    print(addr, vendor)"
9zhw,python,MD4,Security and Cryptography,Cryptographic Techniques,"import hashlib
print hashlib.new(""md4"",raw_input().encode('utf-16le')).hexdigest().upper()"
hndx,python,MD5,Security and Cryptography,Cryptographic Techniques,">>> import hashlib
>>> # RFC 1321    test suite:
>>> tests = (
  (b"""", 'd41d8cd98f00b204e9800998ecf8427e'),
  (b""a"", '0cc175b9c0f1b6a831c399e269772661'),
  (b""abc"", '900150983cd24fb0d6963f7d28e17f72'),
  (b""message digest"", 'f96b697d7cb7938d525a2f31aaf161d0'),
  (b""abcdefghijklmnopqrstuvwxyz"", 'c3fcd3d76192e4007dfb496cca67e13b'),
  (b""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"", 'd174ab98d277d9f5a5611c2c9f419d9f'),
  (b""12345678901234567890123456789012345678901234567890123456789012345678901234567890"", '57edf4a22be3c955ac49da2e2107b67a') )
>>> for text, golden in tests: assert hashlib.md5(text).hexdigest() == golden
 
>>> "
ar3e,python,MD5/Implementation,Security and Cryptography,Cryptographic Techniques,"import math
 
rotate_amounts = [7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,
                  5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20,
                  4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,
                  6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]
 
constants = [int(abs(math.sin(i+1)) * 2**32) & 0xFFFFFFFF for i in range(64)]
 
init_values = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476]
 
functions = 16*[lambda b, c, d: (b & c) | (~b & d)] + \
            16*[lambda b, c, d: (d & b) | (~d & c)] + \
            16*[lambda b, c, d: b ^ c ^ d] + \
            16*[lambda b, c, d: c ^ (b | ~d)]
 
index_functions = 16*[lambda i: i] + \
                  16*[lambda i: (5*i + 1)%16] + \
                  16*[lambda i: (3*i + 5)%16] + \
                  16*[lambda i: (7*i)%16]
 
def left_rotate(x, amount):
    x &= 0xFFFFFFFF
    return ((x<<amount) | (x>>(32-amount))) & 0xFFFFFFFF
 
def md5(message):
 
    message = bytearray(message) #copy our input into a mutable buffer
    orig_len_in_bits = (8 * len(message)) & 0xffffffffffffffff
    message.append(0x80)
    while len(message)%64 != 56:
        message.append(0)
    message += orig_len_in_bits.to_bytes(8, byteorder='little')
 
    hash_pieces = init_values[:]
 
    for chunk_ofst in range(0, len(message), 64):
        a, b, c, d = hash_pieces
        chunk = message[chunk_ofst:chunk_ofst+64]
        for i in range(64):
            f = functions[i](b, c, d)
            g = index_functions[i](i)
            to_rotate = a + f + constants[i] + int.from_bytes(chunk[4*g:4*g+4], byteorder='little')
            new_b = (b + left_rotate(to_rotate, rotate_amounts[i])) & 0xFFFFFFFF
            a, b, c, d = d, new_b, b, c
        for i, val in enumerate([a, b, c, d]):
            hash_pieces[i] += val
            hash_pieces[i] &= 0xFFFFFFFF
 
    return sum(x<<(32*i) for i, x in enumerate(hash_pieces))
 
def md5_to_hex(digest):
    raw = digest.to_bytes(16, byteorder='little')
    return '{:032x}'.format(int.from_bytes(raw, byteorder='big'))
 
if __name__=='__main__':
    demo = [b"""", b""a"", b""abc"", b""message digest"", b""abcdefghijklmnopqrstuvwxyz"",
            b""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"",
            b""12345678901234567890123456789012345678901234567890123456789012345678901234567890""]
    for message in demo:
        print(md5_to_hex(md5(message)),' <= ""',message.decode('ascii'),'""', sep='')
 "
znzu,python,Machine code,Operating Systems and Shell Programming,Operating System Concepts,"import ctypes
import os
from ctypes import c_ubyte, c_int
 
code = bytes([0x8b, 0x44, 0x24, 0x04, 0x03, 0x44, 0x24, 0x08, 0xc3])
 
code_size = len(code)
# copy code into an executable buffer
if (os.name == 'posix'):
    import mmap
    executable_map = mmap.mmap(-1, code_size, mmap.MAP_PRIVATE | mmap.MAP_ANON, mmap.PROT_READ | mmap.PROT_WRITE | mmap.PROT_EXEC)
    # we must keep a reference to executable_map until the call, to avoid freeing the mapped memory
    executable_map.write(code)
    # the mmap object won't tell us the actual address of the mapping, but we can fish it out by allocating
    # some ctypes object over its buffer, then asking the address of that
    func_address = ctypes.addressof(c_ubyte.from_buffer(executable_map))
elif (os.name == 'nt'):
    # the mmap module doesn't support protection flags on Windows, so execute VirtualAlloc instead
    code_buffer = ctypes.create_string_buffer(code)
    PAGE_EXECUTE_READWRITE = 0x40  # Windows constants that would usually come from header files
    MEM_COMMIT = 0x1000
    executable_buffer_address = ctypes.windll.kernel32.VirtualAlloc(0, code_size, MEM_COMMIT, PAGE_EXECUTE_READWRITE)
    if (executable_buffer_address == 0):
        print('Warning: Failed to enable code execution, call will likely cause a protection fault.')
        func_address = ctypes.addressof(code_buffer)
    else:
        ctypes.memmove(executable_buffer_address, code_buffer, code_size)
        func_address = executable_buffer_address
else:
    # for other platforms, we just hope DEP isn't enabled
    code_buffer = ctypes.create_string_buffer(code)
    func_address = ctypes.addressof(code_buffer)
 
prototype = ctypes.CFUNCTYPE(c_int, c_ubyte, c_ubyte) # build a function prototype from return type and argument types
func = prototype(func_address)                        # build an actual function from the prototype by specifying the address
res = func(7,12)
print(res)
 "
s6t0,python,Mad Libs,Puzzles and Games,Puzzle Solving Algorithms,"import re
 
# Optional Python 2.x compatibility
#try: input = raw_input
#except: pass
 
template = '''<name> went for a walk in the park. <he or she>
found a <noun>. <name> decided to take it home.'''
 
def madlibs(template):
    print('The story template is:\n' + template)
    fields = sorted(set( re.findall('<[^>]+>', template) ))
    values = input('\nInput a comma-separated list of words to replace the following items'
                   '\n  %s: ' % ','.join(fields)).split(',')
    story = template
    for f,v in zip(fields, values):
        story = story.replace(f, v)
    print('\nThe story becomes:\n\n' + story)
 
madlibs(template)"
qlc7,python,Magic 8-ball,Puzzles and Games,Game Development,"import random
 
s = ('It is certain', 'It is decidedly so', 'Without a doubt', 'Yes, definitely',
 'You may rely on it', 'As I see it, yes', 'Most likely', 'Outlook good',
 'Signs point to yes', 'Yes', 'Reply hazy, try again', 'Ask again later',
 'Better not tell you now', 'Cannot predict now', 'Concentrate and ask again',
 ""Don't bet on it"", 'My reply is no', 'My sources say no', 'Outlook not so good',
 'Very doubtful')
 
q_and_a = {}
 
while True:
    question = input('Ask your question:')
    if len(question) == 0: break
 
    if question in q_and_a:
        print('Your question has already been answered')
    else:
        answer = random.choice(s)
        q_and_a[question] = answer
        print(answer)"
igoc,python,Magic constant,Mathematics,Combinatorics,"#!/usr/bin/python
 
def a(n):
    n += 2
    return n*(n**2 + 1)/2
 
def inv_a(x):
    k = 0
    while k*(k**2+1)/2+2 < x:
        k+=1
    return k
 
 
if __name__ == '__main__':
    print(""The first 20 magic constants are:"");
    for n in range(1, 20):
        print(int(a(n)), end = "" "");
    print(""\nThe 1,000th magic constant is:"",int(a(1000)));
 
    for e in range(1, 20):
        print(f'10^{e}: {inv_a(10**e)}');"
5vdq,python,Magic squares of doubly even order,Mathematics,Combinatorics," 
def MagicSquareDoublyEven(order):
    sq = [range(1+n*order,order + (n*order)+1) for n in range(order) ]
    n1 = order/4
    for r in range(n1):
        r1 = sq[r][n1:-n1]
        r2 = sq[order -r - 1][n1:-n1]
        r1.reverse()
        r2.reverse()
        sq[r][n1:-n1] = r2
        sq[order -r - 1][n1:-n1] = r1
    for r in range(n1, order-n1):
        r1 = sq[r][:n1]
        r2 = sq[order -r - 1][order-n1:]
        r1.reverse()
        r2.reverse()
        sq[r][:n1] = r2
        sq[order -r - 1][order-n1:] = r1
    return sq
 
def printsq(s):
    n = len(s)
    bl = len(str(n**2))+1
    for i in range(n):
        print ''.join( [ (""%""+str(bl)+""s"")%(str(x)) for x in s[i]] )
    print ""\nMagic constant = %d""%sum(s[0])
 
printsq(MagicSquareDoublyEven(8))
 "
2hzk,python,Magic squares of odd order,Mathematics,Combinatorics,">>> def magic(n):
    for row in range(1, n + 1):
        print(' '.join('%*i' % (len(str(n**2)), cell) for cell in
                       (n * ((row + col - 1 + n // 2) % n) +
                       ((row + 2 * col - 2) % n) + 1
                       for col in range(1, n + 1))))
    print('\nAll sum to magic number %i' % ((n * n + 1) * n // 2))
 
 
>>> for n in (5, 3, 7):
	print('\nOrder %i\n=======' % n)
	magic(n)
 
 
 
Order 5
=======
17 24  1  8 15
23  5  7 14 16
 4  6 13 20 22
10 12 19 21  3
11 18 25  2  9
 
All sum to magic number 65
 
Order 3
=======
8 1 6
3 5 7
4 9 2
 
All sum to magic number 15
 
Order 7
=======
30 39 48  1 10 19 28
38 47  7  9 18 27 29
46  6  8 17 26 35 37
 5 14 16 25 34 36 45
13 15 24 33 42 44  4
21 23 32 41 43  3 12
22 31 40 49  2 11 20
 
All sum to magic number 175
>>> "
qlmp,python,Magic squares of singly even order,Mathematics,Combinatorics," 
import math
from sys import stdout
 
LOG_10 = 2.302585092994
 
 
# build odd magic square
def build_oms(s):
    if s % 2 == 0:
        s += 1
    q = [[0 for j in range(s)] for i in range(s)]
    p = 1
    i = s // 2
    j = 0
    while p <= (s * s):
        q[i][j] = p
        ti = i + 1
        if ti >= s: ti = 0
        tj = j - 1
        if tj < 0: tj = s - 1
        if q[ti][tj] != 0:
            ti = i
            tj = j + 1
        i = ti
        j = tj
        p = p + 1
 
    return q, s
 
 
# build singly even magic square
def build_sems(s):
    if s % 2 == 1:
        s += 1
    while s % 4 == 0:
        s += 2
 
    q = [[0 for j in range(s)] for i in range(s)]
    z = s // 2
    b = z * z
    c = 2 * b
    d = 3 * b
    o = build_oms(z)
 
    for j in range(0, z):
        for i in range(0, z):
            a = o[0][i][j]
            q[i][j] = a
            q[i + z][j + z] = a + b
            q[i + z][j] = a + c
            q[i][j + z] = a + d
 
    lc = z // 2
    rc = lc
    for j in range(0, z):
        for i in range(0, s):
            if i < lc or i > s - rc or (i == lc and j == lc):
                if not (i == 0 and j == lc):
                    t = q[i][j]
                    q[i][j] = q[i][j + z]
                    q[i][j + z] = t
 
    return q, s
 
 
def format_sqr(s, l):
    for i in range(0, l - len(s)):
        s = ""0"" + s
    return s + "" ""
 
 
def display(q):
    s = q[1]
    print("" - {0} x {1}\n"".format(s, s))
    k = 1 + math.floor(math.log(s * s) / LOG_10)
    for j in range(0, s):
        for i in range(0, s):
            stdout.write(format_sqr(""{0}"".format(q[0][i][j]), k))
        print()
    print(""Magic sum: {0}\n"".format(s * ((s * s) + 1) // 2))
 
 
stdout.write(""Singly Even Magic Square"")
display(build_sems(6))
 "
v69f,python,Main step of GOST 28147-89,Security and Cryptography,Cryptographic Techniques," 
k8 = [	14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7 ] 
k7 = [	15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10 ]
k6 = [	10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8 ]
k5 = [	 7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15 ]
k4 = [	 2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9 ]
k3 = [	12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11 ]
k2 = [	 4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1 ]
k1 = [	13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7 ]
 
k87 = [0] * 256
k65 = [0] * 256
k43 = [0] * 256
k21 = [0] * 256
 
def kboxinit():
	for i in range(256):
		k87[i] = k8[i >> 4] << 4 | k7[i & 15]
		k65[i] = k6[i >> 4] << 4 | k5[i & 15]
		k43[i] = k4[i >> 4] << 4 | k3[i & 15]
		k21[i] = k2[i >> 4] << 4 | k1[i & 15]
 
def f(x):
	x = ( k87[x>>24 & 255] << 24 | k65[x>>16 & 255] << 16 |
	      k43[x>> 8 & 255] <<  8 | k21[x & 255] )
	return x<<11 | x>>(32-11)"
ezd9,python,Make directory path,Systems Programming and File I/O,File Operations," 
from errno import EEXIST
from os import mkdir, curdir
from os.path import split, exists
 
def mkdirp(path, mode=0777):
    head, tail = split(path)
    if not tail:
        head, tail = split(head)
    if head and tail and not exists(head):
        try:
            mkdirp(head, mode)
        except OSError as e:
            # be happy if someone already created the path
            if e.errno != EEXIST:
                raise
        if tail == curdir:  # xxx/newdir/. exists if xxx/newdir exists
            return
    try:
        mkdir(path, mode)
    except OSError as e:
        # be happy if someone already created the path
        if e.errno != EEXIST:
            raise
 "
35ua,python,Man or boy test,Puzzles and Games,Logic and Mathematical Puzzles,"#!/usr/bin/env python
import sys
sys.setrecursionlimit(1025)
 
def a(in_k, x1, x2, x3, x4, x5):
    k = [in_k]
    def b():
        k[0] -= 1
        return a(k[0], b, x1, x2, x3, x4)
    return x4() + x5() if k[0] <= 0 else b()
 
x = lambda i: lambda: i
print(a(10, x(1), x(-1), x(-1), x(1), x(0))) 
 "
66jk,python,Mandelbrot set,Graphics and Visualization,Graphics Programming,"# Python 3.0+ and 2.5+
try:
    from functools import reduce
except:
    pass
 
 
def mandelbrot(a):
    return reduce(lambda z, _: z * z + a, range(50), 0)
 
def step(start, step, iterations):
    return (start + (i * step) for i in range(iterations))
 
rows = ((""*"" if abs(mandelbrot(complex(x, y))) < 2 else "" ""
        for x in step(-2.0, .0315, 80))
        for y in step(1, -.05, 41))
 
print(""\n"".join("""".join(row) for row in rows))
 "
hpem,python,Map range,Mathematics,Algebra and Arithmetic,">>> def maprange( a, b, s):
	(a1, a2), (b1, b2) = a, b
	return  b1 + ((s - a1) * (b2 - b1) / (a2 - a1))
 
>>> for s in range(11):
	print(""%2g maps to %g"" % (s, maprange( (0, 10), (-1, 0), s)))
 
 
 0 maps to -1
 1 maps to -0.9
 2 maps to -0.8
 3 maps to -0.7
 4 maps to -0.6
 5 maps to -0.5
 6 maps to -0.4
 7 maps to -0.3
 8 maps to -0.2
 9 maps to -0.1
10 maps to 0"
bmof,python,Mastermind,Puzzles and Games,Game Development," 
import random
 
 
def encode(correct, guess):
    output_arr = [''] * len(correct)
 
    for i, (correct_char, guess_char) in enumerate(zip(correct, guess)):
        output_arr[i] = 'X' if guess_char == correct_char else 'O' if guess_char in correct else '-'
 
    return ''.join(output_arr)
 
 
def safe_int_input(prompt, min_val, max_val):
    while True:
        user_input = input(prompt)
 
        try:
            user_input = int(user_input)
        except ValueError:
            continue
 
        if min_val <= user_input <= max_val:
            return user_input
 
 
def play_game():
    print(""Welcome to Mastermind."")
    print(""You will need to guess a random code."")
    print(""For each guess, you will receive a hint."")
    print(""In this hint, X denotes a correct letter, and O a letter in the original string but in a different position."")
    print()
 
    number_of_letters = safe_int_input(""Select a number of possible letters for the code (2-20): "", 2, 20)
    code_length = safe_int_input(""Select a length for the code (4-10): "", 4, 10)
 
    letters = 'ABCDEFGHIJKLMNOPQRST'[:number_of_letters]
    code = ''.join(random.choices(letters, k=code_length))
    guesses = []
 
    while True:
        print()
        guess = input(f""Enter a guess of length {code_length} ({letters}): "").upper().strip()
 
        if len(guess) != code_length or any([char not in letters for char in guess]):
            continue
        elif guess == code:
            print(f""\nYour guess {guess} was correct!"")
            break
        else:
            guesses.append(f""{len(guesses)+1}: {' '.join(guess)} => {' '.join(encode(code, guess))}"")
 
        for i_guess in guesses:
            print(""------------------------------------"")
            print(i_guess)
        print(""------------------------------------"")
 
 
if __name__ == '__main__':
    play_game()
 
 "
8she,python,Matrix chain multiplication,Algorithms and Data Structures,Algorithms,"def parens(n):
    def aux(n, k):
        if n == 1:
            yield k
        elif n == 2:
            yield [k, k + 1]
        else:
            a = []
            for i in range(1, n):
                for u in aux(i, k):
                    for v in aux(n - i, k + i):
                        yield [u, v]
    yield from aux(n, 0)"
n1ts,python,Matrix digital rain,Graphics and Visualization,Graphics Programming," 
import curses
import random
import time
 
""""""
 
Based on C ncurses version
 
http://rosettacode.org/wiki/Matrix_Digital_Rain#NCURSES_version
 
""""""
 
""""""
Time between row updates in seconds
Controls the speed of the digital rain effect.
""""""
 
ROW_DELAY=.0001
 
def get_rand_in_range(min, max):
    return random.randrange(min,max+1)
 
try:
    # Characters to randomly appear in the rain sequence.
    chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
 
    total_chars = len(chars)
 
    stdscr = curses.initscr()
    curses.noecho()
    curses.curs_set(False)
 
    curses.start_color()
    curses.init_pair(1, curses.COLOR_GREEN, curses.COLOR_BLACK)
    stdscr.attron(curses.color_pair(1))
 
    max_x = curses.COLS - 1
    max_y = curses.LINES - 1
 
 
    # Create arrays of columns based on screen width.
 
    # Array containing the current row of each column.
 
    columns_row = []
 
    # Array containing the active status of each column.
    # A column draws characters on a row when active.
 
    columns_active = []
 
    for i in range(max_x+1):
        columns_row.append(-1)
        columns_active.append(0)
 
    while(True):
        for i in range(max_x):
            if columns_row[i] == -1:
                # If a column is at the top row, pick a
                # random starting row and active status.
                columns_row[i] = get_rand_in_range(0, max_y)
                columns_active[i] = get_rand_in_range(0, 1)
 
        # Loop through columns and draw characters on rows
 
        for i in range(max_x):
            if columns_active[i] == 1:
                # Draw a random character at this column's current row.
                char_index = get_rand_in_range(0, total_chars-1)
                #mvprintw(columns_row[i], i, ""%c"", chars[char_index])                
                stdscr.addstr(columns_row[i], i, chars[char_index])
            else:
                # Draw an empty character if the column is inactive.
                #mvprintw(columns_row[i], i, "" "");
                stdscr.addstr(columns_row[i], i, "" "");
 
 
            columns_row[i]+=1
 
            # When a column reaches the bottom row, reset to top.
            if columns_row[i] >= max_y:
                columns_row[i] = -1
 
            # Randomly alternate the column's active status.
            if get_rand_in_range(0, 1000) == 0:
                if columns_active[i] == 0:      
                    columns_active[i] = 1
                else:
                    columns_active[i] = 0
 
            time.sleep(ROW_DELAY)
            stdscr.refresh()
 
except KeyboardInterrupt as err:
    curses.endwin()    
 "
fs5o,python,Matrix multiplication,Mathematics,Algebra and Arithmetic,"a=((1,  1,  1,   1), # matrix A #
     (2,  4,  8,  16),
     (3,  9, 27,  81),
     (4, 16, 64, 256))
 
b=((  4  , -3  ,  4/3.,  -1/4. ), # matrix B #
     (-13/3., 19/4., -7/3.,  11/24.),
     (  3/2., -2.  ,  7/6.,  -1/4. ),
     ( -1/6.,  1/4., -1/6.,   1/24.))
 
 
 
def MatrixMul( mtx_a, mtx_b):
    tpos_b = zip( *mtx_b)
    rtn = [[ sum( ea*eb for ea,eb in zip(a,b)) for b in tpos_b] for a in mtx_a]
    return rtn
 
 
v = MatrixMul( a, b )
 
print 'v = ('
for r in v:
    print '[', 
    for val in r:
        print '%8.2f '%val, 
    print ']'
print ')'
 
 
u = MatrixMul(b,a)
 
print 'u = '
for r in u:
    print '[', 
    for val in r:
        print '%8.2f '%val, 
    print ']'
print ')'"
hghj,python,Matrix transposition,Algorithms and Data Structures,Algorithms,"m=((1,  1,  1,   1),
   (2,  4,  8,  16),
   (3,  9, 27,  81),
   (4, 16, 64, 256),
   (5, 25,125, 625))
print(zip(*m))
# in Python 3.x, you would do:
# print(list(zip(*m)))"
fxwu,python,Matrix-exponentiation operator,Algorithms and Data Structures,Algorithms,">>> from operator import mul
>>> def matrixMul(m1, m2):
  return map(
    lambda row:
      map(
        lambda *column:
          sum(map(mul, row, column)),
        *m2),
    m1)
 
>>> def identity(size):
	size = range(size)
	return [[(i==j)*1 for i in size] for j in size]
 
>>> def matrixExp(m, pow):
	assert pow>=0 and int(pow)==pow, ""Only non-negative, integer powers allowed""
	accumulator = identity(len(m))
	for i in range(pow):
		accumulator = matrixMul(accumulator, m)
	return accumulator
 
>>> def printtable(data):
	for row in data:
		print ' '.join('%-5s' % ('%s' % cell) for cell in row)
 
 
>>> m = [[3,2], [2,1]]
>>> for i in range(5):
	print '\n%i:' % i
	printtable( matrixExp(m, i) )
 
 
 
0:
1     0    
0     1    
 
1:
3     2    
2     1    
 
2:
13    8    
8     5    
 
3:
55    34   
34    21   
 
4:
233   144  
144   89   
>>> printtable( matrixExp(m, 10) )
1346269 832040
832040 514229
>>>"
m28g,python,Maximum triangle path sum,Puzzles and Games,Logic and Mathematical Puzzles,"def solve(tri):
    while len(tri) > 1:
        t0 = tri.pop()
        t1 = tri.pop()
        tri.append([max(t0[i], t0[i+1]) + t for i,t in enumerate(t1)])
    return tri[0][0]
 
 
data = """"""                55
                        94 48
                       95 30 96
                     77 71 26 67
                    97 13 76 38 45
                  07 36 79 16 37 68
                 48 07 09 18 70 26 06
               18 72 79 46 59 79 29 90
              20 76 87 11 32 07 07 49 18
            27 83 58 35 71 11 25 57 29 85
           14 64 36 96 27 11 58 56 92 18 55
         02 90 03 60 48 49 41 46 33 36 47 23
        92 50 48 02 36 59 42 79 72 20 82 77 42
      56 78 38 80 39 75 02 71 66 66 01 03 55 72
     44 25 67 84 71 67 11 61 40 57 58 89 40 56 36
   85 32 25 85 57 48 84 35 47 62 17 01 01 99 89 52
  06 71 28 75 94 48 37 10 23 51 06 48 53 18 74 98 15
27 02 92 23 08 71 76 84 15 52 92 63 81 10 44 10 69 93""""""
 
print solve([map(int, row.split()) for row in data.splitlines()])"
hmfh,python,Mayan calendar,Mathematics,Numerical Methods," 
import datetime
 
 
def g2m(date, gtm_correlation=True):
    """"""
    Translates Gregorian date into Mayan date, see
    https://rosettacode.org/wiki/Mayan_calendar
 
    Input arguments:
 
     date: string date in ISO-8601 format: YYYY-MM-DD
     gtm_correlation: GTM correlation to apply if True, Astronomical correlation otherwise (optional, True by default)
 
    Output arguments:
 
     long_date: Mayan date in Long Count system as string
     round_date: Mayan date in Calendar Round system as string
    """"""
 
    # define some parameters and names
 
    correlation = 584283 if gtm_correlation else 584285
 
    long_count_days = [144000, 7200, 360, 20, 1]
 
    tzolkin_months = ['Imix’', 'Ik’', 'Ak’bal', 'K’an', 'Chikchan', 'Kimi', 'Manik’', 'Lamat', 'Muluk', 'Ok', 'Chuwen',
                      'Eb', 'Ben', 'Hix', 'Men', 'K’ib’', 'Kaban', 'Etz’nab’', 'Kawak', 'Ajaw']  # tzolk'in
 
    haad_months = ['Pop', 'Wo’', 'Sip', 'Sotz’', 'Sek', 'Xul', 'Yaxk’in', 'Mol', 'Ch’en', 'Yax', 'Sak’', 'Keh', 'Mak',
                   'K’ank’in', 'Muwan', 'Pax', 'K’ayab', 'Kumk’u', 'Wayeb’']  # haab'
 
    gregorian_days = datetime.datetime.strptime(date, '%Y-%m-%d').toordinal()
    julian_days = gregorian_days + 1721425
 
    # 1. calculate long count date
 
    long_date = list()
    remainder = julian_days - correlation
 
    for days in long_count_days:
 
        result, remainder = divmod(remainder, days)
        long_date.append(int(result))
 
    long_date = '.'.join(['{:02d}'.format(d) for d in long_date])
 
    # 2. calculate round calendar date
 
    tzolkin_month = (julian_days + 16) % 20
    tzolkin_day = ((julian_days + 5) % 13) + 1
 
    haab_month = int(((julian_days + 65) % 365) / 20)
    haab_day = ((julian_days + 65) % 365) % 20
    haab_day = haab_day if haab_day else 'Chum'
 
    lord_number = (julian_days - correlation) % 9
    lord_number = lord_number if lord_number else 9
 
    round_date = f'{tzolkin_day} {tzolkin_months[tzolkin_month]} {haab_day} {haad_months[haab_month]} G{lord_number}'
 
    return long_date, round_date
 
if __name__ == '__main__':
 
    dates = ['2004-06-19', '2012-12-18', '2012-12-21', '2019-01-19', '2019-03-27', '2020-02-29', '2020-03-01']
 
    for date in dates:
 
        long, round = g2m(date)
        print(date, long, round)
 "
7ll2,python,Mayan numerals,Mathematics,Numerical Methods,"'''Mayan numerals'''
 
from functools import (reduce)
 
 
# -------------------- MAYAN NUMERALS --------------------
 
# mayanNumerals :: Int -> [[String]]
def mayanNumerals(n):
    '''Rows of Mayan digit cells,
       representing the integer n.
    '''
    return showIntAtBase(20)(
        mayanDigit
    )(n)([])
 
 
# mayanDigit :: Int -> [String]
def mayanDigit(n):
    '''List of strings representing a Mayan digit.'''
    if 0 < n:
        r = n % 5
        return [
            (['●' * r] if 0 < r else []) +
            (['━━'] * (n // 5))
        ]
    else:
        return ['Θ']
 
 
# mayanFramed :: Int -> String
def mayanFramed(n):
    '''Mayan integer in the form of a
       Wiki table source string.
    '''
    return 'Mayan ' + str(n) + ':\n\n' + (
        wikiTable({
            'class': 'wikitable',
            'style': cssFromDict({
                'text-align': 'center',
                'background-color': '#F0EDDE',
                'color': '#605B4B',
                'border': '2px solid silver'
            }),
            'colwidth': '3em',
            'cell': 'vertical-align: bottom;'
        })([[
            '<br>'.join(col) for col in mayanNumerals(n)
        ]])
    )
 
 
# ------------------------- TEST -------------------------
 
# main :: IO ()
def main():
    '''Mayan numeral representations of various integers'''
    print(
        main.__doc__ + ':\n\n' +
        '\n'.join(mayanFramed(n) for n in [
            4005, 8017, 326205, 886205, 1081439556,
            1000000, 1000000000
        ])
    )
 
 
# ------------------------ BOXES -------------------------
 
# wikiTable :: Dict -> [[a]] -> String
def wikiTable(opts):
    '''Source text for wiki-table display of rows of cells,
       using CSS key-value pairs in the opts dictionary.
    '''
    def colWidth():
        return 'width:' + opts['colwidth'] + '; ' if (
            'colwidth' in opts
        ) else ''
 
    def cellStyle():
        return opts['cell'] if 'cell' in opts else ''
 
    return lambda rows: '{| ' + reduce(
        lambda a, k: (
            a + k + '=""' + opts[k] + '"" ' if (
                k in opts
            ) else a
        ),
        ['class', 'style'],
        ''
    ) + '\n' + '\n|-\n'.join(
        '\n'.join(
            ('|' if (
                0 != i and ('cell' not in opts)
            ) else (
                '|style=""' + colWidth() + cellStyle() + '""|'
            )) + (
                str(x) or ' '
            ) for x in row
        ) for i, row in enumerate(rows)
    ) + '\n|}\n\n'
 
 
# ----------------------- GENERIC ------------------------
 
# cssFromDict :: Dict -> String
def cssFromDict(dct):
    '''CSS string from a dictinary of key-value pairs'''
    return reduce(
        lambda a, k: a + k + ':' + dct[k] + '; ',
        dct.keys(),
        ''
    )
 
 
# showIntAtBase :: Int -> (Int -> String)
# -> Int -> String -> String
def showIntAtBase(base):
    '''String representation of an integer in a given base,
       using a supplied function for the string
       representation of digits.
    '''
    def wrap(toChr, n, rs):
        def go(nd, r):
            n, d = nd
            r_ = toChr(d) + r
            return go(divmod(n, base), r_) if 0 != n else r_
        return 'unsupported base' if 1 >= base else (
            'negative number' if 0 > n else (
                go(divmod(n, base), rs))
        )
    return lambda toChr: lambda n: lambda rs: (
        wrap(toChr, n, rs)
    )
 
 
# MAIN ---
if __name__ == '__main__':
    main()"
ipio,python,Maze generation,Puzzles and Games,Puzzle Solving Algorithms,"from random import shuffle, randrange
 
def make_maze(w = 16, h = 8):
    vis = [[0] * w + [1] for _ in range(h)] + [[1] * (w + 1)]
    ver = [[""|  ""] * w + ['|'] for _ in range(h)] + [[]]
    hor = [[""+--""] * w + ['+'] for _ in range(h + 1)]
 
    def walk(x, y):
        vis[y][x] = 1
 
        d = [(x - 1, y), (x, y + 1), (x + 1, y), (x, y - 1)]
        shuffle(d)
        for (xx, yy) in d:
            if vis[yy][xx]: continue
            if xx == x: hor[max(y, yy)][x] = ""+  ""
            if yy == y: ver[y][max(x, xx)] = ""   ""
            walk(xx, yy)
 
    walk(randrange(w), randrange(h))
 
    s = """"
    for (a, b) in zip(hor, ver):
        s += ''.join(a + ['\n'] + b + ['\n'])
    return s
 
if __name__ == '__main__':
    print(make_maze())"
0met,python,Maze solving,Puzzles and Games,Puzzle Solving Algorithms," 
# python 3
 
def Dijkstra(Graph, source):
    '''
        +   +---+---+
        | 0   1   2 |
        +---+   +   +
        | 3   4 | 5  
        +---+---+---+
 
        >>> graph = (        # or ones on the diagonal
        ...     (0,1,0,0,0,0,),
        ...     (1,0,1,0,1,0,),
        ...     (0,1,0,0,0,1,),
        ...     (0,0,0,0,1,0,),
        ...     (0,1,0,1,0,0,),
        ...     (0,0,1,0,0,0,),
        ... )
        ...
        >>> Dijkstra(graph, 0)
        ([0, 1, 2, 3, 2, 3], [1e+140, 0, 1, 4, 1, 2])
        >>> display_solution([1e+140, 0, 1, 4, 1, 2])
        5<2<1<0
    '''
    # Graph[u][v] is the weight from u to v (however 0 means infinity)
    infinity = float('infinity')
    n = len(graph)
    dist = [infinity]*n   # Unknown distance function from source to v
    previous = [infinity]*n # Previous node in optimal path from source
    dist[source] = 0        # Distance from source to source
    Q = list(range(n)) # All nodes in the graph are unoptimized - thus are in Q
    while Q:           # The main loop
        u = min(Q, key=lambda n:dist[n])                 # vertex in Q with smallest dist[]
        Q.remove(u)
        if dist[u] == infinity:
            break # all remaining vertices are inaccessible from source
        for v in range(n):               # each neighbor v of u
            if Graph[u][v] and (v in Q): # where v has not yet been visited
                alt = dist[u] + Graph[u][v]
                if alt < dist[v]:       # Relax (u,v,a)
                    dist[v] = alt
                    previous[v] = u
    return dist,previous
 
def display_solution(predecessor):
    cell = len(predecessor)-1
    while cell:
        print(cell,end='<')
        cell = predecessor[cell]
    print(0)
 "
q79r,python,McNuggets problem,Mathematics,Combinatorics,">>> from itertools import product
>>> nuggets = set(range(101))
>>> for s, n, t in product(range(100//6+1), range(100//9+1), range(100//20+1)):
	nuggets.discard(6*s + 9*n + 20*t)
 
 
>>> max(nuggets)
43
>>> "
6dg1,python,Median filter,Graphics and Visualization,Graphics Programming,"import Image, ImageFilter
im = Image.open('image.ppm')
 
median = im.filter(ImageFilter.MedianFilter(3))
median.save('image2.ppm')"
txbb,python,Memory allocation,Systems Programming and File I/O,File Operations,">>> from array import array
>>> argslist = [('l', []), ('c', 'hello world'), ('u', u'hello \u2641'),
	('l', [1, 2, 3, 4, 5]), ('d', [1.0, 2.0, 3.14])]
>>> for typecode, initializer in argslist:
	a = array(typecode, initializer)
	print a
	del a
 
 
array('l')
array('c', 'hello world')
array('u', u'hello \u2641')
array('l', [1, 2, 3, 4, 5])
array('d', [1.0, 2.0, 3.1400000000000001])
>>>"
nu5j,python,Memory layout of a data structure,Systems Programming and File I/O,System Programming,"from ctypes import Structure, c_int
 
rs232_9pin  = ""_0 CD RD TD DTR SG DSR RTS CTS RI"".split()
rs232_25pin = ( ""_0  PG  TD  RD  RTS CTS DSR SG  CD  pos neg""
                ""_11 SCD SCS STD TC  SRD RC""
                ""_18 SRS DTR SQD RI DRS XTC"" ).split()
 
class RS232_9pin(Structure):
    _fields_ = [(__, c_int, 1) for __ in rs232_9pin]
 
 
class RS232_25pin(Structure):
    _fields_ = [(__, c_int, 1) for __ in rs232_25pin]"
eb6e,python,Menu,Programming Concepts,Fundamentals,"def _menu(items):
    for indexitem in enumerate(items):
        print (""  %2i) %s"" % indexitem)
 
def _ok(reply, itemcount):
    try:
        n = int(reply)
        return 0 <= n < itemcount
    except:
        return False
 
def selector(items, prompt):
    'Prompt to select an item from the items'
    if not items: return ''
    reply = -1
    itemcount = len(items)
    while not _ok(reply, itemcount):
        _menu(items)
        # Use input instead of raw_input for Python 3.x
        reply = raw_input(prompt).strip()
    return items[int(reply)]
 
if __name__ == '__main__':
    items = ['fee fie', 'huff and puff', 'mirror mirror', 'tick tock']
    item = selector(items, 'Which is from the three pigs: ')
    print (""You chose: "" + item)"
vs3p,python,Merge and aggregate datasets,Databases and Data Management,Data Serialization and Formats,"# to install pandas library go to cmd prompt and type:
# cd %USERPROFILE%\AppData\Local\Programs\Python\Python38-32\Scripts\
# pip install pandas
import pandas as pd
 
# load data from csv files
df_patients = pd.read_csv (r'patients.csv', sep = "","", decimal=""."")
df_visits = pd.read_csv (r'visits.csv', sep = "","", decimal=""."")
 
''' # load data hard coded, create data frames
import io
str_patients = """"""PATIENT_ID,LASTNAME
1001,Hopper
4004,Wirth
3003,Kemeny
2002,Gosling
5005,Kurtz
""""""
df_patients = pd.read_csv(io.StringIO(str_patients), sep = "","", decimal=""."")
str_visits = """"""PATIENT_ID,VISIT_DATE,SCORE
2002,2020-09-10,6.8
1001,2020-09-17,5.5
4004,2020-09-24,8.4
2002,2020-10-08,
1001,,6.6
3003,2020-11-12,
4004,2020-11-05,7.0
1001,2020-11-19,5.3
""""""
df_visits = pd.read_csv(io.StringIO(str_visits), sep = "","", decimal=""."")
'''
 
# typecast from string to datetime so .agg can 'max' it
df_visits['VISIT_DATE'] = pd.to_datetime(df_visits['VISIT_DATE'])
 
# merge on PATIENT_ID
df_merge = df_patients.merge(df_visits, on='PATIENT_ID', how='left')
 
# groupby is an intermediate object
df_group = df_merge.groupby(['PATIENT_ID','LASTNAME'], as_index=False)
 
# note: you can use 'sum' instead of the lambda function but that returns NaN as 0 (zero)
df_result = df_group.agg({'VISIT_DATE': 'max', 'SCORE': [lambda x: x.sum(min_count=1),'mean']})
 
print(df_result)"
gf9b,python,Mertens function,Mathematics,Number Theory,"def mertens(count):
    """"""Generate Mertens numbers""""""
    m = [None, 1]
    for n in range(2, count+1):
        m.append(1)
        for k in range(2, n+1):
            m[n] -= m[n//k]
    return m
 
 
ms = mertens(1000)
 
print(""The first 99 Mertens numbers are:"")
print(""  "", end=' ')
col = 1
for n in ms[1:100]:
    print(""{:2d}"".format(n), end=' ')
    col += 1
    if col == 10:
        print()
        col = 0
 
zeroes = sum(x==0 for x in ms)
crosses = sum(a!=0 and b==0 for a,b in zip(ms, ms[1:]))
print(""M(N) equals zero {} times."".format(zeroes))
print(""M(N) crosses zero {} times."".format(crosses))"
3n1s,python,Metallic ratios,Mathematics,Numerical Methods,"from itertools import count, islice
from _pydecimal import getcontext, Decimal
 
def metallic_ratio(b):
    m, n = 1, 1
    while True:
        yield m, n
        m, n = m*b + n, m
 
def stable(b, prec):
    def to_decimal(b):
        for m,n in metallic_ratio(b):
            yield Decimal(m)/Decimal(n)
 
    getcontext().prec = prec
    last = 0
    for i,x in zip(count(), to_decimal(b)):
        if x == last:
            print(f'after {i} iterations:\n\t{x}')
            break
        last = x
 
for b in range(4):
    coefs = [n for _,n in islice(metallic_ratio(b), 15)]
    print(f'\nb = {b}: {coefs}')
    stable(b, 32)
 
print(f'\nb = 1 with 256 digits:')
stable(1, 256)"
trhw,python,Metaprogramming,Programming Concepts,Advanced Concepts," 
from macropy.core.macros import *
from macropy.core.quotes import macros, q, ast, u
 
macros = Macros()
 
@macros.expr
def expand(tree, **kw):
    addition = 10
    return q[lambda x: x * ast[tree] + u[addition]]
 "
lc3c,python,Metered concurrency,Concurrency and Parallelism,Synchronization Mechanisms,"import time
import threading
 
# Only 4 workers can run in the same time
sem = threading.Semaphore(4)
 
workers = []
running = 1
 
 
def worker():
    me = threading.currentThread()
    while 1:
        sem.acquire()
        try:
            if not running:
                break
            print '%s acquired semaphore' % me.getName()
            time.sleep(2.0)
        finally:
            sem.release()
        time.sleep(0.01) # Let others acquire
 
# Start 10 workers
for i in range(10):
    t = threading.Thread(name=str(i), target=worker)
    workers.append(t)
    t.start()
 
# Main loop
try:
    while 1:
        time.sleep(0.1)
except KeyboardInterrupt:
    running = 0
    for t in workers:
        t.join()"
kz33,python,Metronome,Puzzles and Games,Simulation and Modeling," 
#lang Python
import time
 
def main(bpm = 72, bpb = 4):
    sleep = 60.0 / bpm
    counter = 0
    while True:
        counter += 1
        if counter % bpb:
            print 'tick'
        else:
            print 'TICK'
        time.sleep(sleep)
 
 
 
main()
 
 "
pnde,python,Mian-Chowla sequence,Mathematics,Combinatorics,"from itertools import count, islice, chain
import time
 
def mian_chowla():
    mc = [1]
    yield mc[-1]
    psums = set([2])
    newsums = set([])
    for trial in count(2):
        for n in chain(mc, [trial]):
            sum = n + trial
            if sum in psums:
                newsums.clear()
                break
            newsums.add(sum)
        else:
            psums |= newsums
            newsums.clear()
            mc.append(trial)
            yield trial
 
def pretty(p, t, s, f):
    print(p, t, "" "".join(str(n) for n in (islice(mian_chowla(), s, f))))
 
if __name__ == '__main__':
    st = time.time()
    ts = ""of the Mian-Chowla sequence are:\n""
    pretty(""The first 30 terms"", ts, 0, 30)
    pretty(""\nTerms 91 to 100"", ts, 90, 100)
    print(""\nComputation time was"", (time.time()-st) * 1000, ""ms"")"
7nnt,python,Middle three digits,Mathematics,Combinatorics,">>> def middle_three_digits(i):
	s = str(abs(i))
	length = len(s)
	assert length >= 3 and length % 2 == 1, ""Need odd and >= 3 digits""
	mid = length // 2
	return s[mid-1:mid+2]
 
>>> passing = [123, 12345, 1234567, 987654321, 10001, -10001, -123, -100, 100, -12345]
>>> failing = [1, 2, -1, -10, 2002, -2002, 0]
>>> for x in passing + failing:
	try:
		answer = middle_three_digits(x)
	except AssertionError as error:
		answer = error
	print(""middle_three_digits(%s) returned: %r"" % (x, answer))
 
 
middle_three_digits(123) returned: '123'
middle_three_digits(12345) returned: '234'
middle_three_digits(1234567) returned: '345'
middle_three_digits(987654321) returned: '654'
middle_three_digits(10001) returned: '000'
middle_three_digits(-10001) returned: '000'
middle_three_digits(-123) returned: '123'
middle_three_digits(-100) returned: '100'
middle_three_digits(100) returned: '100'
middle_three_digits(-12345) returned: '234'
middle_three_digits(1) returned: AssertionError('Need odd and >= 3 digits',)
middle_three_digits(2) returned: AssertionError('Need odd and >= 3 digits',)
middle_three_digits(-1) returned: AssertionError('Need odd and >= 3 digits',)
middle_three_digits(-10) returned: AssertionError('Need odd and >= 3 digits',)
middle_three_digits(2002) returned: AssertionError('Need odd and >= 3 digits',)
middle_three_digits(-2002) returned: AssertionError('Need odd and >= 3 digits',)
middle_three_digits(0) returned: AssertionError('Need odd and >= 3 digits',)
>>> "
qez4,python,Miller–Rabin primality test,Security and Cryptography,Cryptographic Techniques," 
 
import random
 
def is_Prime(n):
    """"""
    Miller-Rabin primality test.
 
    A return value of False means n is certainly not prime. A return value of
    True means n is very likely a prime.
    """"""
    if n!=int(n):
        return False
    n=int(n)
    #Miller-Rabin test for prime
    if n==0 or n==1 or n==4 or n==6 or n==8 or n==9:
        return False
 
    if n==2 or n==3 or n==5 or n==7:
        return True
    s = 0
    d = n-1
    while d%2==0:
        d>>=1
        s+=1
    assert(2**s * d == n-1)
 
    def trial_composite(a):
        if pow(a, d, n) == 1:
            return False
        for i in range(s):
            if pow(a, 2**i * d, n) == n-1:
                return False
        return True  
 
    for i in range(8):#number of trials 
        a = random.randrange(2, n)
        if trial_composite(a):
            return False
 
    return True  "
npju,python,Mind boggling card trick,Puzzles and Games,Puzzle Solving Algorithms,"import random
 
## 1. Cards
n = 52
Black, Red = 'Black', 'Red'
blacks = [Black] * (n // 2) 
reds = [Red] * (n // 2)
pack = blacks + reds
# Give the pack a good shuffle.
random.shuffle(pack)
 
## 2. Deal from the randomised pack into three stacks
black_stack, red_stack, discard = [], [], []
while pack:
    top = pack.pop()
    if top == Black:
        black_stack.append(pack.pop())
    else:
        red_stack.append(pack.pop())
    discard.append(top)
print('(Discards:', ' '.join(d[0] for d in discard), ')\n')
 
## 3. Swap the same, random, number of cards between the two stacks.
# We can't swap more than the number of cards in a stack.
max_swaps = min(len(black_stack), len(red_stack))
# Randomly choose the number of cards to swap.
swap_count = random.randint(0, max_swaps)
print('Swapping', swap_count)
# Randomly choose that number of cards out of each stack to swap.
def random_partition(stack, count):
    ""Partition the stack into 'count' randomly selected members and the rest""
    sample = random.sample(stack, count)
    rest = stack[::]
    for card in sample:
        rest.remove(card)
    return rest, sample
 
black_stack, black_swap = random_partition(black_stack, swap_count)
red_stack, red_swap = random_partition(red_stack, swap_count)
 
# Perform the swap.
black_stack += red_swap
red_stack += black_swap
 
## 4. Order from randomness?
if black_stack.count(Black) == red_stack.count(Red):
    print('Yeha! The mathematicians assertion is correct.')
else:
    print('Whoops - The mathematicians (or my card manipulations) are flakey')"
cd96,python,Minesweeper game,Puzzles and Games,Game Development," 
'''
Minesweeper game.
 
    There is an n by m grid that has a random number of between 20% to 60%
    of randomly hidden mines that need to be found. 
 
    Positions in the grid are modified by entering their coordinates
    where the first coordinate is horizontal in the grid and the second
    vertical. The top left of the grid is position 1,1; the bottom right is
    at n,m.
 
    * The total number of mines to be found is shown at the beginning of the
    game.
    * Each mine occupies a single grid point, and its position is initially
    unknown to the player
    * The grid is shown as a rectangle of characters between moves.
    * You are initially shown all grids as obscured, by a single dot '.'
    * You may mark what you think is the position of a mine which will show
    as a '?'
    * You can mark what you think is free space by entering its coordinates.
    :*  If the point is free space then it is cleared, as are any adjacent
    points that are also free space- this is repeated recursively for
    subsequent adjacent free points unless that point is marked as a mine
    or is a mine.
    ::*   Points marked as a mine show as a '?'.
    ::*   Other free points show as an integer count of the number of adjacent
    true mines in its immediate neighbourhood, or as a single space ' ' if the
    free point is not adjacent to any true mines.
    * Of course you loose if you try to clear space that starts on a mine.
    * You win when you have correctly identified all mines.
 
 
    When prompted you may:
        Toggle where you think a mine is at position x, y:
          m <x> <y>
        Clear the grid starting at position x, y (and print the result):
          c <x> <y>
        Print the grid so far:
          p
        Resign
          r
    Resigning will first show the grid with an 'N' for unfound true mines, a
    'Y' for found true mines and a '?' for where you marked clear space as a
    mine 
 
'''
 
 
gridsize  = (6, 4)
minerange = (0.2, 0.6)
 
 
try:
    raw_input
except:
    raw_input = input
 
import random
from itertools import product
from pprint import pprint as pp
 
 
def gridandmines(gridsize=gridsize, minerange=minerange):
    xgrid, ygrid = gridsize
    minmines, maxmines = minerange
    minecount = xgrid * ygrid    
    minecount = random.randint(int(minecount*minmines), int(minecount*maxmines))
    grid = set(product(range(xgrid), range(ygrid)))
    mines = set(random.sample(grid, minecount))
    show = {xy:'.' for xy in grid}
    return grid, mines, show
 
def printgrid(show, gridsize=gridsize):
    xgrid, ygrid = gridsize
    grid = '\n'.join(''.join(show[(x,y)] for x in range(xgrid))
                     for y in range(ygrid))
    print( grid )
 
def resign(showgrid, mines, markedmines):
    for m in mines:
        showgrid[m] = 'Y' if m in markedmines else 'N'
 
def clear(x,y, showgrid, grid, mines, markedmines):
    if showgrid[(x, y)] == '.':
        xychar = str(sum(1
                         for xx in (x-1, x, x+1)
                         for yy in (y-1, y, y+1)
                         if (xx, yy) in mines ))
        if xychar == '0': xychar = '.'
        showgrid[(x,y)] = xychar
        for xx in (x-1, x, x+1):
            for yy in (y-1, y, y+1):
                xxyy = (xx, yy)
                if ( xxyy != (x, y)
                     and xxyy in grid
                     and xxyy not in mines | markedmines ):
                    clear(xx, yy, showgrid, grid, mines, markedmines)
 
if __name__ == '__main__':
    grid, mines, showgrid = gridandmines()
    markedmines = set([])
    print( __doc__ )
    print( '\nThere are %i true mines of fixed position in the grid\n' % len(mines) )
    printgrid(showgrid)
    while markedmines != mines:
        inp = raw_input('m x y/c x y/p/r: ').strip().split()
        if inp:
            if inp[0] == 'm':
                x, y = [int(i)-1 for i in inp[1:3]]
                if (x,y) in markedmines:
                    markedmines.remove((x,y))
                    showgrid[(x,y)] = '.'
                else:
                    markedmines.add((x,y))
                    showgrid[(x,y)] = '?'
            elif inp[0] == 'p':
                printgrid(showgrid)
            elif inp[0] == 'c':
                x, y = [int(i)-1 for i in inp[1:3]]
                if (x,y) in mines | markedmines:
                    print( '\nKLABOOM!! You hit a mine.\n' )
                    resign(showgrid, mines, markedmines)
                    printgrid(showgrid)
                    break
                clear(x,y, showgrid, grid, mines, markedmines)
                printgrid(showgrid)
            elif inp[0] == 'r':
                print( '\nResigning!\n' )
                resign(showgrid, mines, markedmines)
                printgrid(showgrid)
                break
 
    print( '\nYou got %i and missed %i of the %i mines'
           % (len(mines.intersection(markedmines)),
              len(markedmines.difference(mines)),
              len(mines)) )"
qqia,python,Minimal steps down to 1,Algorithms and Data Structures,Algorithms," 
from functools import lru_cache
 
 
#%%
 
DIVS = {2, 3}
SUBS = {1}
 
class Minrec():
    ""Recursive, memoised minimised steps to 1""
 
    def __init__(self, divs=DIVS, subs=SUBS):
        self.divs, self.subs = divs, subs
 
    @lru_cache(maxsize=None)
    def _minrec(self, n):
        ""Recursive, memoised""
        if n == 1:
            return 0, ['=1']
        possibles = {}
        for d in self.divs:
            if n % d == 0:
                possibles[f'/{d}=>{n // d:2}'] = self._minrec(n // d)
        for s in self.subs:
            if n > s:
                possibles[f'-{s}=>{n - s:2}'] = self._minrec(n - s)
        thiskind, (count, otherkinds) = min(possibles.items(), key=lambda x: x[1])
        ret = 1 + count, [thiskind] + otherkinds
        return ret
 
    def __call__(self, n):
        ""Recursive, memoised""
        ans = self._minrec(n)[1][:-1]
        return len(ans), ans
 
 
if __name__ == '__main__':
    for DIVS, SUBS in [({2, 3}, {1}), ({2, 3}, {2})]:
        minrec = Minrec(DIVS, SUBS)
        print('\nMINIMUM STEPS TO 1: Recursive algorithm')
        print('  Possible divisors:  ', DIVS)
        print('  Possible decrements:', SUBS)
        for n in range(1, 11):
            steps, how = minrec(n)
            print(f'    minrec({n:2}) in {steps:2} by: ', ', '.join(how))
 
        upto = 2000
        print(f'\n    Those numbers up to {upto} that take the maximum, ""minimal steps down to 1"":')
        stepn = sorted((minrec(n)[0], n) for n in range(upto, 0, -1))
        mx = stepn[-1][0]
        ans = [x[1] for x in stepn if x[0] == mx]
        print('      Taking', mx, f'steps is/are the {len(ans)} numbers:',
              ', '.join(str(n) for n in sorted(ans)))
        #print(minrec._minrec.cache_info())
        print()"
xgde,python,Minimum multiple of m where digital sum equals m,Mathematics,Number Theory,"'''A131382'''
 
from itertools import count, islice
 
 
# a131382 :: [Int]
def a131382():
    '''An infinite series of the terms of A131382'''
    return (
        elemIndex(x)(
            productDigitSums(x)
        ) for x in count(1)
    )
 
 
# productDigitSums :: Int -> [Int]
def productDigitSums(n):
    '''The sum of the decimal digits of n'''
    return (digitSum(n * x) for x in count(0))
 
 
# ------------------------- TEST -------------------------
# main :: IO ()
def main():
    '''First 40 terms of A131382'''
 
    print(
        table(10)([
            str(x) for x in islice(
                a131382(),
                40
            )
        ])
    )
 
 
# ----------------------- GENERIC ------------------------
 
# chunksOf :: Int -> [a] -> [[a]]
def chunksOf(n):
    '''A series of lists of length n, subdividing the
       contents of xs. Where the length of xs is not evenly
       divisible, the final list will be shorter than n.
    '''
    def go(xs):
        return (
            xs[i:n + i] for i in range(0, len(xs), n)
        ) if 0 < n else None
    return go
 
 
# digitSum :: Int -> Int
def digitSum(n):
    '''The sum of the digital digits of n.
    '''
    return sum(int(x) for x in list(str(n)))
 
 
# elemIndex :: a -> [a] -> (None | Int)
def elemIndex(x):
    '''Just the first index of x in xs,
       or None if no elements match.
    '''
    def go(xs):
        try:
            return next(
                i for i, v in enumerate(xs) if x == v
            )
        except StopIteration:
            return None
    return go
 
 
# table :: Int -> [String] -> String
def table(n):
    '''A list of strings formatted as
       right-justified rows of n columns.
    '''
    def go(xs):
        w = len(xs[-1])
        return '\n'.join(
            ' '.join(row) for row in chunksOf(n)([
                s.rjust(w, ' ') for s in xs
            ])
        )
    return go
 
 
# MAIN ---
if __name__ == '__main__':
    main()"
bdjz,python,Minimum positive multiple in base 10 using only 0 and 1,Mathematics,Number Theory,"def getA004290(n):
    if n < 2:
        return 1
    arr = [[0 for _ in range(n)] for _ in range(n)]
    arr[0][0] = 1
    arr[0][1] = 1
    m = 0
    while True:
        m += 1
        if arr[m - 1][-10 ** m % n] == 1:
            break
        arr[m][0] = 1
        for k in range(1, n):
            arr[m][k] = max([arr[m - 1][k], arr[m - 1][k - 10 ** m % n]])
    r = 10 ** m
    k = -r % n
    for j in range((m - 1), 0, -1):
        if arr[j - 1][k] == 0:
            r = r + 10 ** j
            k = (k - 10 ** j) % n   
    if k == 1:
        r += 1
    return r
 
for n in [i for i in range(1, 11)] + \
          [i for i in range(95, 106)] + \
          [297, 576, 594, 891, 909, 999, 1998, 2079, 2251, 2277, 2439, 2997, 4878]:
    result = getA004290(n)
    print(f""A004290({n}) = {result} = {n} * {result // n})"")
 "
dzp7,python,Minkowski question-mark function,Mathematics,Number Theory,"import math
 
MAXITER = 151
 
 
def minkowski(x):
    if x > 1 or x < 0:
        return math.floor(x) + minkowski(x - math.floor(x))
 
    p = int(x)
    q = 1
    r = p + 1
    s = 1
    d = 1.0
    y = float(p)
 
    while True:
        d /= 2
        if y + d == y:
            break
 
        m = p + r
        if m < 0 or p < 0:
            break
 
        n = q + s
        if n < 0:
            break
 
        if x < m / n:
            r = m
            s = n
        else:
            y += d
            p = m
            q = n
 
    return y + d
 
 
def minkowski_inv(x):
    if x > 1 or x < 0:
        return math.floor(x) + minkowski_inv(x - math.floor(x))
 
    if x == 1 or x == 0:
        return x
 
    cont_frac = [0]
    current = 0
    count = 1
    i = 0
 
    while True:
        x *= 2
 
        if current == 0:
            if x < 1:
                count += 1
            else:
                cont_frac.append(0)
                cont_frac[i] = count
 
                i += 1
                count = 1
                current = 1
                x -= 1
        else:
            if x > 1:
                count += 1
                x -= 1
            else:
                cont_frac.append(0)
                cont_frac[i] = count
 
                i += 1
                count = 1
                current = 0
 
        if x == math.floor(x):
            cont_frac[i] = count
            break
 
        if i == MAXITER:
            break
 
    ret = 1.0 / cont_frac[i]
    for j in range(i - 1, -1, -1):
        ret = cont_frac[j] + 1.0 / ret
 
    return 1.0 / ret
 
 
if __name__ == ""__main__"":
    print(
        ""{:19.16f} {:19.16f}"".format(
            minkowski(0.5 * (1 + math.sqrt(5))),
            5.0 / 3.0,
        )
    )
 
    print(
        ""{:19.16f} {:19.16f}"".format(
            minkowski_inv(-5.0 / 9.0),
            (math.sqrt(13) - 7) / 6,
        )
    )
 
    print(
        ""{:19.16f} {:19.16f}"".format(
            minkowski(minkowski_inv(0.718281828)),
            minkowski_inv(minkowski(0.1213141516171819)),
        )
    )
 "
ti40,python,Modified random distribution,Algorithms and Data Structures,Algorithms,"import random
from typing import List, Callable, Optional
 
 
def modifier(x: float) -> float:
    """"""
    V-shaped, modifier(x) goes from 1 at 0 to 0 at 0.5 then back to 1 at 1.0 .
 
    Parameters
    ----------
    x : float
        Number, 0.0 .. 1.0 .
 
    Returns
    -------
    float
        Target probability for generating x; between 0 and 1.
 
    """"""
    return 2*(.5 - x) if x < 0.5 else 2*(x - .5)
 
 
def modified_random_distribution(modifier: Callable[[float], float],
                                 n: int) -> List[float]:
    """"""
    Generate n random numbers between 0 and 1 subject to modifier.
 
    Parameters
    ----------
    modifier : Callable[[float], float]
        Target random number gen. 0 <= modifier(x) < 1.0 for 0 <= x < 1.0 .
    n : int
        number of random numbers generated.
 
    Returns
    -------
    List[float]
        n random numbers generated with given probability.
 
    """"""
    d: List[float] = []
    while len(d) < n:
        r1 = prob = random.random()
        if random.random() < modifier(prob):
            d.append(r1)
    return d
 
 
if __name__ == '__main__':
    from collections import Counter
 
    data = modified_random_distribution(modifier, 50_000)
    bins = 15
    counts = Counter(d // (1 / bins) for d in data)
    #
    mx = max(counts.values())
    print(""   BIN, COUNTS, DELTA: HISTOGRAM\n"")
    last: Optional[float] = None
    for b, count in sorted(counts.items()):
        delta = 'N/A' if last is None else str(count - last)
        print(f""  {b / bins:5.2f},  {count:4},  {delta:>4}: ""
              f""{'#' * int(40 * count / mx)}"")
        last = count"
sw3v,python,Modular arithmetic,Mathematics,Algebra and Arithmetic,"import operator
import functools
 
@functools.total_ordering
class Mod:
    __slots__ = ['val','mod']
 
    def __init__(self, val, mod):
        if not isinstance(val, int):
            raise ValueError('Value must be integer')
        if not isinstance(mod, int) or mod<=0:
            raise ValueError('Modulo must be positive integer')
        self.val = val % mod
        self.mod = mod
 
    def __repr__(self):
        return 'Mod({}, {})'.format(self.val, self.mod)
 
    def __int__(self):
        return self.val
 
    def __eq__(self, other):
        if isinstance(other, Mod):
            if self.mod == other.mod:
                return self.val==other.val
            else:
                return NotImplemented
        elif isinstance(other, int):
            return self.val == other
        else:
            return NotImplemented
 
    def __lt__(self, other):
        if isinstance(other, Mod):
            if self.mod == other.mod:
                return self.val<other.val
            else:
                return NotImplemented
        elif isinstance(other, int):
            return self.val < other
        else:
            return NotImplemented
 
    def _check_operand(self, other):
        if not isinstance(other, (int, Mod)):
            raise TypeError('Only integer and Mod operands are supported')
        if isinstance(other, Mod) and self.mod != other.mod:
            raise ValueError('Inconsistent modulus: {} vs. {}'.format(self.mod, other.mod))
 
    def __pow__(self, other):
        self._check_operand(other)
        # We use the built-in modular exponentiation function, this way we can avoid working with huge numbers.
        return Mod(pow(self.val, int(other), self.mod), self.mod)
 
    def __neg__(self):
        return Mod(self.mod - self.val, self.mod)
 
    def __pos__(self):
        return self # The unary plus operator does nothing.
 
    def __abs__(self):
        return self # The value is always kept non-negative, so the abs function should do nothing.
 
# Helper functions to build common operands based on a template.
# They need to be implemented as functions for the closures to work properly.
def _make_op(opname):
    op_fun = getattr(operator, opname)  # Fetch the operator by name from the operator module
    def op(self, other):
        self._check_operand(other)
        return Mod(op_fun(self.val, int(other)) % self.mod, self.mod)
    return op
 
def _make_reflected_op(opname):
    op_fun = getattr(operator, opname)
    def op(self, other):
        self._check_operand(other)
        return Mod(op_fun(int(other), self.val) % self.mod, self.mod)
    return op
 
# Build the actual operator overload methods based on the template.
for opname, reflected_opname in [('__add__', '__radd__'), ('__sub__', '__rsub__'), ('__mul__', '__rmul__')]:
    setattr(Mod, opname, _make_op(opname))
    setattr(Mod, reflected_opname, _make_reflected_op(opname))
 
def f(x):
    return x**100+x+1
 
print(f(Mod(10,13)))
# Output: Mod(1, 13)"
402y,python,Modular exponentiation,Algorithms and Data Structures,Algorithms,"a = 2988348162058574136915891421498819466320163312926952423791023078876139
b = 2351399303373464486466122544523690094744975233415544072992656881240319
m = 10 ** 40
print(pow(a, b, m))"
ov0x,python,Modular inverse,Mathematics,Number Theory,">>> def extended_gcd(aa, bb):
    lastremainder, remainder = abs(aa), abs(bb)
    x, lastx, y, lasty = 0, 1, 1, 0
    while remainder:
        lastremainder, (quotient, remainder) = remainder, divmod(lastremainder, remainder)
        x, lastx = lastx - quotient*x, x
        y, lasty = lasty - quotient*y, y
    return lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1)
 
>>> def modinv(a, m):
	g, x, y = extended_gcd(a, m)
	if g != 1:
		raise ValueError
	return x % m
 
>>> modinv(42, 2017)
1969
>>> "
qfkh,python,Monads/List monad,Programming Concepts,Advanced Concepts,"""""""A List Monad. Requires Python >= 3.7 for type hints.""""""
from __future__ import annotations
from itertools import chain
 
from typing import Any
from typing import Callable
from typing import Iterable
from typing import List
from typing import TypeVar
 
 
T = TypeVar(""T"")
 
 
class MList(List[T]):
    @classmethod
    def unit(cls, value: Iterable[T]) -> MList[T]:
        return cls(value)
 
    def bind(self, func: Callable[[T], MList[Any]]) -> MList[Any]:
        return MList(chain.from_iterable(map(func, self)))
 
    def __rshift__(self, func: Callable[[T], MList[Any]]) -> MList[Any]:
        return self.bind(func)
 
 
if __name__ == ""__main__"":
    # Chained int and string functions
    print(
        MList([1, 99, 4])
        .bind(lambda val: MList([val + 1]))
        .bind(lambda val: MList([f""${val}.00""]))
    )
 
    # Same, but using `>>` as the bind operator.
    print(
        MList([1, 99, 4])
        >> (lambda val: MList([val + 1]))
        >> (lambda val: MList([f""${val}.00""]))
    )
 
    # Cartesian product of [1..5] and [6..10]
    print(
        MList(range(1, 6)).bind(
            lambda x: MList(range(6, 11)).bind(lambda y: MList([(x, y)]))
        )
    )
 
    # Pythagorean triples with elements between 1 and 25
    print(
        MList(range(1, 26)).bind(
            lambda x: MList(range(x + 1, 26)).bind(
                lambda y: MList(range(y + 1, 26)).bind(
                    lambda z: MList([(x, y, z)])
                    if x * x + y * y == z * z
                    else MList([])
                )
            )
        )
    )
 "
ruee,python,Monads/Maybe monad,Programming Concepts,Advanced Concepts,"""""""A Maybe Monad. Requires Python >= 3.7 for type hints.""""""
from __future__ import annotations
 
from typing import Any
from typing import Callable
from typing import Generic
from typing import Optional
from typing import TypeVar
from typing import Union
 
 
T = TypeVar(""T"")
 
 
class Maybe(Generic[T]):
    def __init__(self, value: Union[Optional[T], Maybe[T]] = None):
        if isinstance(value, Maybe):
            self.value: Optional[T] = value.value
        else:
            self.value = value
 
    def __rshift__(self, func: Callable[[Optional[T]], Maybe[Any]]):
        return self.bind(func)
 
    def bind(self, func: Callable[[Optional[T]], Maybe[Any]]) -> Maybe[Any]:
        return func(self.value)
 
    def __str__(self):
        return f""{self.__class__.__name__}({self.value!r})""
 
 
def plus_one(value: Optional[int]) -> Maybe[int]:
    if value is not None:
        return Maybe[int](value + 1)
    return Maybe[int](None)
 
 
def currency(value: Optional[int]) -> Maybe[str]:
    if value is not None:
        return Maybe[str](f""${value}.00"")
    return Maybe[str](None)
 
 
if __name__ == ""__main__"":
    test_cases = [1, 99, None, 4]
 
    for case in test_cases:
        m_int = Maybe[int](case)
        result = m_int >> plus_one >> currency
        # or..
        # result = m_int.bind(plus_one).bind(currency)
        print(f""{str(case):<4} -> {result}"")
 "
thed,python,Monads/Writer monad,Programming Concepts,Advanced Concepts,"""""""A Writer Monad. Requires Python >= 3.7 for type hints.""""""
from __future__ import annotations
 
import functools
import math
import os
 
from typing import Any
from typing import Callable
from typing import Generic
from typing import List
from typing import TypeVar
from typing import Union
 
 
T = TypeVar(""T"")
 
 
class Writer(Generic[T]):
    def __init__(self, value: Union[T, Writer[T]], *msgs: str):
        if isinstance(value, Writer):
            self.value: T = value.value
            self.msgs: List[str] = value.msgs + list(msgs)
        else:
            self.value = value
            self.msgs = list(f""{msg}: {self.value}"" for msg in msgs)
 
    def bind(self, func: Callable[[T], Writer[Any]]) -> Writer[Any]:
        writer = func(self.value)
        return Writer(writer, *self.msgs)
 
    def __rshift__(self, func: Callable[[T], Writer[Any]]) -> Writer[Any]:
        return self.bind(func)
 
    def __str__(self):
        return f""{self.value}\n{os.linesep.join(reversed(self.msgs))}""
 
    def __repr__(self):
        return f""Writer({self.value}, \""{', '.join(reversed(self.msgs))}\"")""
 
 
def lift(func: Callable, msg: str) -> Callable[[Any], Writer[Any]]:
    """"""Return a writer monad version of the simple function `func`.""""""
 
    @functools.wraps(func)
    def wrapped(value):
        return Writer(func(value), msg)
 
    return wrapped
 
 
if __name__ == ""__main__"":
    square_root = lift(math.sqrt, ""square root"")
    add_one = lift(lambda x: x + 1, ""add one"")
    half = lift(lambda x: x / 2, ""div two"")
 
    print(Writer(5, ""initial"") >> square_root >> add_one >> half)
 "
aklu,python,Monte Carlo methods,Mathematics,Probability and Statistics,">>> import random, math
>>> throws = 1000
>>> 4.0 * sum(math.hypot(*[random.random()*2-1
	                 for q in [0,1]]) < 1
              for p in xrange(throws)) / float(throws)
3.1520000000000001
>>> throws = 1000000
>>> 4.0 * sum(math.hypot(*[random.random()*2-1
	                 for q in [0,1]]) < 1
              for p in xrange(throws)) / float(throws)
3.1396359999999999
>>> throws = 100000000
>>> 4.0 * sum(math.hypot(*[random.random()*2-1
	                 for q in [0,1]]) < 1
              for p in xrange(throws)) / float(throws)
3.1415666400000002"
kca6,python,Monty Hall problem,Puzzles and Games,Logic and Mathematical Puzzles,"'''
I could understand the explanation of the Monty Hall problem
but needed some more evidence
 
References:
  http://www.bbc.co.uk/dna/h2g2/A1054306
  http://en.wikipedia.org/wiki/Monty_Hall_problem especially:
  http://en.wikipedia.org/wiki/Monty_Hall_problem#Increasing_the_number_of_doors
'''
from random import randrange
 
doors, iterations = 3,100000  # could try 100,1000
 
def monty_hall(choice, switch=False, doorCount=doors):
  # Set up doors
  door = [False]*doorCount
  # One door with prize
  door[randrange(doorCount)] = True
 
  chosen = door[choice]
 
  unpicked = door
  del unpicked[choice]
 
  # Out of those unpicked, the alternative is either:
  #   the prize door, or
  #   an empty door if the initial choice is actually the prize.
  alternative = True in unpicked
 
  if switch:
    return alternative
  else:
    return chosen
 
print ""\nMonty Hall problem simulation:""
print doors, ""doors,"", iterations, ""iterations.\n""
 
print ""Not switching allows you to win"",
print sum(monty_hall(randrange(3), switch=False)
          for x in range(iterations)),
print ""out of"", iterations, ""times.""
print ""Switching allows you to win"",
print sum(monty_hall(randrange(3), switch=True)
          for x in range(iterations)),
print ""out of"", iterations, ""times.\n"""
3s60,python,Morse code,Text Processing,Text Encoding and Decoding,"import time, winsound #, sys
 
char2morse = {          
          ""!"": ""---."",      ""\"""": "".-..-."",     ""$"": ""...-..-"",    ""'"": "".----."",  
          ""("": ""-.--."",      "")"": ""-.--.-"",     ""+"": "".-.-."",      "","": ""--..--"", 
          ""-"": ""-....-"",     ""."": "".-.-.-"",     ""/"": ""-..-."", 
          ""0"": ""-----"",      ""1"": "".----"",      ""2"": ""..---"",      ""3"": ""...--"", 
          ""4"": ""....-"",      ""5"": ""....."",      ""6"": ""-...."",      ""7"": ""--..."", 
          ""8"": ""---.."",      ""9"": ""----."", 
          "":"": ""---..."",     "";"": ""-.-.-."",     ""="": ""-...-"",      ""?"": ""..--.."", 
          ""@"": "".--.-."", 
          ""A"": "".-"",         ""B"": ""-..."",       ""C"": ""-.-."",       ""D"": ""-.."", 
          ""E"": ""."",          ""F"": ""..-."",       ""G"": ""--."",        ""H"": ""...."", 
          ""I"": "".."",         ""J"": "".---"",       ""K"": ""-.-"",        ""L"": "".-.."", 
          ""M"": ""--"",         ""N"": ""-."",         ""O"": ""---"",        ""P"": "".--."", 
          ""Q"": ""--.-"",       ""R"": "".-."",        ""S"": ""..."",        ""T"": ""-"", 
          ""U"": ""..-"",        ""V"": ""...-"",       ""W"": "".--"",        ""X"": ""-..-"", 
          ""Y"": ""-.--"",       ""Z"": ""--.."", 
          ""["": ""-.--."",      ""]"": ""-.--.-"",     ""_"": ""..--.-"",
 }
 
e = 50      # Element time in ms. one dit is on for e then off for e
f = 1280    # Tone freq. in hertz
chargap = 1 # Time between characters of a word, in units of e
wordgap = 7 # Time between words, in units of e
 
def gap(n=1):
    time.sleep(n * e / 1000)
off = gap
 
def on(n=1):
    winsound.Beep(f, n * e)
 
def dit():
    on(); off()
 
def dah():
    on(3); off()
 
def bloop(n=3):
    winsound.Beep(f//2, n * e)
 
def windowsmorse(text):
    for word in text.strip().upper().split():
        for char in word:
            for element in char2morse.get(char, '?'):
                if element == '-':
                    dah()
                elif element == '.':
                    dit()
                else:
                    bloop()
            gap(chargap)
        gap(wordgap)
 
# Outputs its own source file as Morse. An audible quine!
#with open(sys.argv[0], 'r') as thisfile:
#    windowsmorse(thisfile.read())
 
while True:
    windowsmorse(input('A string to change into morse: '))
 "
dv09,python,Mouse position,Programming Concepts,Fundamentals," 
import Tkinter as tk
 
def showxy(event):
    xm, ym = event.x, event.y
    str1 = ""mouse at x=%d  y=%d"" % (xm, ym)
    # show cordinates in title
    root.title(str1)
    # switch color to red if mouse enters a set location range
    x,y, delta = 100, 100, 10
    frame.config(bg='red'
                 if abs(xm - x) < delta and abs(ym - y) < delta
                 else 'yellow')
 
root = tk.Tk()
frame = tk.Frame(root, bg= 'yellow', width=300, height=200)
frame.bind(""<Motion>"", showxy)
frame.pack()
 
root.mainloop()
 "
7sb0,python,Move-to-front algorithm,Algorithms and Data Structures,Algorithms,"from __future__ import print_function
from string import ascii_lowercase
 
SYMBOLTABLE = list(ascii_lowercase)
 
def move2front_encode(strng, symboltable):
    sequence, pad = [], symboltable[::]
    for char in strng:
        indx = pad.index(char)
        sequence.append(indx)
        pad = [pad.pop(indx)] + pad
    return sequence
 
def move2front_decode(sequence, symboltable):
    chars, pad = [], symboltable[::]
    for indx in sequence:
        char = pad[indx]
        chars.append(char)
        pad = [pad.pop(indx)] + pad
    return ''.join(chars)
 
if __name__ == '__main__':
    for s in ['broood', 'bananaaa', 'hiphophiphop']:
        encode = move2front_encode(s, SYMBOLTABLE)
        print('%14r encodes to %r' % (s, encode), end=', ')
        decode = move2front_decode(encode, SYMBOLTABLE)
        print('which decodes back to %r' % decode)
        assert s == decode, 'Whoops!'"
5fez,python,Multi-dimensional array,Algorithms and Data Structures,Data Structures,">>> from pprint import pprint as pp   # Pretty printer
>>> from itertools import product
>>> 
>>> def dict_as_mdarray(dimensions=(2, 3), init=0.0):
...     return {indices: init for indices in product(*(range(i) for i in dimensions))}
... 
>>> 
>>> mdarray = dict_as_mdarray((2, 3, 4, 5))
>>> pp(mdarray)
{(0, 0, 0, 0): 0.0,
 (0, 0, 0, 1): 0.0,
 (0, 0, 0, 2): 0.0,
 (0, 0, 0, 3): 0.0,
 (0, 0, 0, 4): 0.0,
 (0, 0, 1, 0): 0.0,
...
 (1, 2, 3, 0): 0.0,
 (1, 2, 3, 1): 0.0,
 (1, 2, 3, 2): 0.0,
 (1, 2, 3, 3): 0.0,
 (1, 2, 3, 4): 0.0}
>>> mdarray[(0, 1, 2, 3)]
0.0
>>> mdarray[(0, 1, 2, 3)] = 6.78
>>> mdarray[(0, 1, 2, 3)]
6.78
>>> mdarray[(0, 1, 2, 3)] = 5.4321
>>> mdarray[(0, 1, 2, 3)]
5.4321
>>> pp(mdarray)
{(0, 0, 0, 0): 0.0,
 (0, 0, 0, 1): 0.0,
 (0, 0, 0, 2): 0.0,
...
 (0, 1, 2, 2): 0.0,
 (0, 1, 2, 3): 5.4321,
 (0, 1, 2, 4): 0.0,
...
 (1, 2, 3, 3): 0.0,
 (1, 2, 3, 4): 0.0}
>>>"
o9qx,python,Multifactorial,Mathematics,Combinatorics,">>> from functools import reduce
>>> from operator import mul
>>> def mfac(n, m): return reduce(mul, range(n, 0, -m))
 
>>> for m in range(1, 11): print(""%2i: %r"" % (m, [mfac(n, m) for n in range(1, 11)]))
 
 1: [1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]
 2: [1, 2, 3, 8, 15, 48, 105, 384, 945, 3840]
 3: [1, 2, 3, 4, 10, 18, 28, 80, 162, 280]
 4: [1, 2, 3, 4, 5, 12, 21, 32, 45, 120]
 5: [1, 2, 3, 4, 5, 6, 14, 24, 36, 50]
 6: [1, 2, 3, 4, 5, 6, 7, 16, 27, 40]
 7: [1, 2, 3, 4, 5, 6, 7, 8, 18, 30]
 8: [1, 2, 3, 4, 5, 6, 7, 8, 9, 20]
 9: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
10: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>> "
op38,python,Multiple distinct objects,Programming Concepts,Fundamentals,[Foo()] * n # here Foo() can be any expression that returns a new object
wraj,python,Multiple regression,Mathematics,Probability and Statistics,"import numpy as np
 
height = [1.47, 1.50, 1.52, 1.55, 1.57, 1.60, 1.63,
    1.65, 1.68, 1.70, 1.73, 1.75, 1.78, 1.80, 1.83]
weight = [52.21, 53.12, 54.48, 55.84, 57.20, 58.57, 59.93,
    61.29, 63.11, 64.47, 66.28, 68.10, 69.92, 72.19, 74.46]
 
X = np.mat(height**np.arange(3)[:, None])
y = np.mat(weight)
 
print(y * X.T * (X*X.T).I)"
jbr3,python,Multiplication tables,Mathematics,Algebra and Arithmetic,">>> size = 12
>>> width = len(str(size**2))
>>> for row in range(-1,size+1):
	if row==0:
		print(""─""*width + ""┼""+""─""*((width+1)*size-1))
	else:
		print("""".join(""%*s%1s"" % ((width,) + ((""x"",""│"")      if row==-1 and col==0
					              else (row,""│"") if row>0   and col==0
					              else (col,"""")  if row==-1
					              else ("""","""")   if row>col
					              else (row*col,"""")))
			       for col in range(size+1)))
 
 
  x│  1   2   3   4   5   6   7   8   9  10  11  12 
───┼───────────────────────────────────────────────
  1│  1   2   3   4   5   6   7   8   9  10  11  12 
  2│      4   6   8  10  12  14  16  18  20  22  24 
  3│          9  12  15  18  21  24  27  30  33  36 
  4│             16  20  24  28  32  36  40  44  48 
  5│                 25  30  35  40  45  50  55  60 
  6│                     36  42  48  54  60  66  72 
  7│                         49  56  63  70  77  84 
  8│                             64  72  80  88  96 
  9│                                 81  90  99 108 
 10│                                    100 110 120 
 11│                                        121 132 
 12│                                            144 
>>> "
1d9r,python,Multiplicative order,Mathematics,Number Theory,"def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a
 
def lcm(a, b):
    return (a*b) / gcd(a, b)
 
def isPrime(p):
    return (p > 1) and all(f == p for f,e in factored(p))
 
primeList = [2,3,5,7]
def primes():
    for p in primeList:
        yield p
    while 1:
        p += 2
        while not isPrime(p):
            p += 2
        primeList.append(p)
        yield p
 
def factored( a):
    for p in primes():
        j = 0
        while a%p == 0:
            a /= p
            j += 1
        if j > 0:
            yield (p,j)
        if a < p*p: break
    if a > 1:
        yield (a,1)
 
 
def multOrdr1(a,(p,e) ):
    m = p**e
    t = (p-1)*(p**(e-1)) #  = Phi(p**e) where p prime
    qs = [1,]
    for f in factored(t):
        qs = [ q * f[0]**j for j in range(1+f[1]) for q in qs ]
    qs.sort()
 
    for q in qs:
        if pow( a, q, m )==1: break
    return q
 
 
def multOrder(a,m):
    assert gcd(a,m) == 1
    mofs = (multOrdr1(a,r) for r in factored(m))
    return reduce(lcm, mofs, 1)
 
 
if __name__ == ""__main__"":
    print multOrder(37, 1000)        # 100
    b = 10**20-1
    print multOrder(2, b) # 3748806900
    print multOrder(17,b) # 1499522760
    b = 100001
    print multOrder(54,b)
    print pow( 54, multOrder(54,b),b)
    if any( (1==pow(54,r, b)) for r in range(1,multOrder(54,b))):
        print 'Exists a power r < 9090 where pow(54,r,b)==1'
    else:
        print 'Everything checks.'"
bhc0,python,Multisplit,Text Processing,Parsing and Tokenization,">>> import re
>>> def ms2(txt=""a!===b=!=c"", sep=[""=="", ""!="", ""=""]):
	if not txt or not sep:
		return []
	ans = m = []
	for m in re.finditer('(.*?)(?:' + '|'.join('('+re.escape(s)+')' for s in sep) + ')', txt):
		ans += [m.group(1), (m.lastindex-2, m.start(m.lastindex))]
	if m and txt[m.end(m.lastindex):]:
		ans += [txt[m.end(m.lastindex):]]
	return ans
 
>>> ms2()
['a', (1, 1), '', (0, 3), 'b', (2, 6), '', (1, 7), 'c']
>>> ms2(txt=""a!===b=!=c"", sep=[""="", ""!="", ""==""])
['a', (1, 1), '', (0, 3), '', (0, 4), 'b', (0, 6), '', (1, 7), 'c']"
tvv6,python,Munchausen numbers,Mathematics,Number Theory,"for i in range(5000):
    if i == sum(int(x) ** int(x) for x in str(i)):
        print(i)"
fb16,python,Munching squares,Graphics and Visualization,Graphics Programming,"import Image, ImageDraw
 
image = Image.new(""RGB"", (256, 256))
drawingTool = ImageDraw.Draw(image)
 
for x in range(256):
    for y in range(256):
        drawingTool.point((x, y), (0, x^y, 0))
 
del drawingTool
image.save(""xorpic.png"", ""PNG"")"
7dwa,python,Musical scale,Puzzles and Games,Simulation and Modeling,">>> import winsound
>>> for note in [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25]:
	winsound.Beep(int(note+.5), 500)	
>>> "
3773,python,Mutual recursion,Algorithms and Data Structures,Algorithms,"def F(n): return 1 if n == 0 else n - M(F(n-1))
def M(n): return 0 if n == 0 else n - F(M(n-1))
 
print ([ F(n) for n in range(20) ])
print ([ M(n) for n in range(20) ])"
621r,python,Möbius function,Mathematics,Number Theory," 
# Python Program to evaluate
# Mobius def M(N) = 1 if N = 1
# M(N) = 0 if any prime factor
# of N is contained twice
# M(N) = (-1)^(no of distinct
# prime factors)
# Python Program to
# evaluate Mobius def
# M(N) = 1 if N = 1
# M(N) = 0 if any
# prime factor of
# N is contained twice
# M(N) = (-1)^(no of
# distinct prime factors)
 
# def to check if
# n is prime or not
def isPrime(n) :
 
    if (n < 2) :
        return False
    for i in range(2, n + 1) :
        if (i * i <= n and n % i == 0) :
            return False
    return True
 
def mobius(N) :
 
    # Base Case
    if (N == 1) :
        return 1
 
    # For a prime factor i
    # check if i^2 is also
    # a factor.
    p = 0
    for i in range(1, N + 1) :
        if (N % i == 0 and
                isPrime(i)) :
 
            # Check if N is
            # divisible by i^2
            if (N % (i * i) == 0) :
                return 0
            else :
 
                # i occurs only once,
                # increase f
                p = p + 1
 
    # All prime factors are
    # contained only once
    # Return 1 if p is even
    # else -1
    if(p % 2 != 0) :
        return -1
    else :
        return 1
 
# Driver Code
print(""Mobius numbers from 1..99:"")
 
for i in range(1, 100):
  print(f""{mobius(i):>4}"", end = '')
 
  if i % 20 == 0: print()
# This code is contributed by
# Manish Shaw(manishshaw1)"
vuiq,python,N'th,Mathematics,Combinatorics,"_suffix = ['th', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th']
 
def nth(n):
    return ""%i'%s"" % (n, _suffix[n%10] if n % 100 <= 10 or n % 100 > 20 else 'th')
 
if __name__ == '__main__':
    for j in range(0,1001, 250):
        print(' '.join(nth(i) for i in list(range(j, j+25))))"
ehjn,python,N-queens problem,Puzzles and Games,Logic and Mathematical Puzzles,"from itertools import permutations
 
n = 8
cols = range(n)
for vec in permutations(cols):
    if n == len(set(vec[i]+i for i in cols)) \
         == len(set(vec[i]-i for i in cols)):
        print ( vec )"
lp0z,python,N-smooth numbers,Mathematics,Number Theory,"primes = [2, 3, 5, 7, 11, 13, 17, 19, 23]
 
def isPrime(n):
    if n < 2:
        return False
 
    for i in primes:
        if n == i:
            return True
        if n % i == 0:
            return False
        if i * i > n:
            return True
    print ""Oops,"", n, "" is too large""
 
def init():
    s = 24
    while s < 600:
        if isPrime(s - 1) and s - 1 > primes[-1]:
            primes.append(s - 1)
        if isPrime(s + 1) and s + 1 > primes[-1]:
            primes.append(s + 1)
        s += 6
 
def nsmooth(n, size):
    if n < 2 or n > 521:
        raise Exception(""n"")
    if size < 1:
        raise Exception(""n"")
 
    bn = n
    ok = False
    for prime in primes:
        if bn == prime:
            ok = True
            break
    if not ok:
        raise Exception(""must be a prime number: n"")
 
    ns = [0] * size
    ns[0] = 1
 
    next = []
    for prime in primes:
        if prime > bn:
            break
        next.append(prime)
 
    indicies = [0] * len(next)
    for m in xrange(1, size):
        ns[m] = min(next)
        for i in xrange(0, len(indicies)):
            if ns[m] == next[i]:
                indicies[i] += 1
                next[i] = primes[i] * ns[indicies[i]]
 
    return ns
 
def main():
    init()
 
    for p in primes:
        if p >= 30:
            break
        print ""The first"", p, ""-smooth numbers are:""
        print nsmooth(p, 25)
        print
 
    for p in primes[1:]:
        if p >= 30:
            break
        print ""The 3000 to 3202"", p, ""-smooth numbers are:""
        print nsmooth(p, 3002)[2999:]
        print
 
    for p in [503, 509, 521]:
        print ""The 30000 to 3019"", p, ""-smooth numbers are:""
        print nsmooth(p, 30019)[29999:]
        print
 
main()"
i9sg,python,Named parameters,Programming Concepts,Fundamentals,"def subtract(x, y):
    return x - y
 
subtract(5, 3)         # used as positional parameters; evaluates to 2
subtract(y = 3, x = 5) # used as named parameters;      evaluates to 2"
1ttd,python,Naming conventions,Programming Concepts,Fundamentals,"#lang racket 
render-game-state 
send-message-to-client 
traverse-forest"
zmc0,python,Narcissist,Algorithms and Data Structures,Algorithms," 
import sys
with open(sys.argv[0]) as quine:
    code = raw_input(""Enter source code: "")
    if code == quine.read():
        print(""Accept"")
    else:
        print(""Reject"")
 "
lgzz,python,Narcissistic decimal number,Mathematics,Number Theory,"from __future__ import print_function
from itertools import count, islice
 
def narcissists():
    for digits in count(0):
        digitpowers = [i**digits for i in range(10)]
        for n in range(int(10**(digits-1)), 10**digits):
            div, digitpsum = n, 0
            while div:
                div, mod = divmod(div, 10)
                digitpsum += digitpowers[mod]
            if n == digitpsum:
                yield n
 
for i, n in enumerate(islice(narcissists(), 25), 1):
    print(n, end=' ')
    if i % 5 == 0: print() 
print()"
ei65,python,Natural sorting,Algorithms and Data Structures,Algorithms,"# -*- coding: utf-8 -*-
# Not Python 3.x (Can't compare str and int)
 
 
from itertools import groupby
from unicodedata import decomposition, name
from pprint import pprint as pp
 
commonleaders = ['the'] # lowercase leading words to ignore
replacements = {u'ß': 'ss',  # Map single char to replacement string
                u'ſ': 's',
                u'ʒ': 's',
                }
 
hexdigits = set('0123456789abcdef')
decdigits = set('0123456789')   # Don't use str.isnumeric
 
def splitchar(c):
    ' De-ligature. De-accent a char'
    de = decomposition(c)
    if de:
        # Just the words that are also hex numbers
        de = [d for d in de.split()
                  if all(c.lower()
                         in hexdigits for c in d)]
        n = name(c, c).upper()
        # (Gosh it's onerous)
        if len(de)> 1 and 'PRECEDE' in n:
            # E.g. ŉ  LATIN SMALL LETTER N PRECEDED BY APOSTROPHE
            de[1], de[0] = de[0], de[1]
        tmp = [ unichr(int(k, 16)) for k in de]
        base, others = tmp[0], tmp[1:]
        if 'LIGATURE' in n:
            # Assume two character ligature
            base += others.pop(0)
    else:
        base = c
    return base
 
 
def sortkeygen(s):
    '''Generate 'natural' sort key for s
 
    Doctests:
        >>> sortkeygen('  some extra    spaces  ')
        [u'some extra spaces']
        >>> sortkeygen('CasE InseNsItIve')
        [u'case insensitive']
        >>> sortkeygen('The Wind in the Willows')
        [u'wind in the willows']
        >>> sortkeygen(u'\462 ligature')
        [u'ij ligature']
        >>> sortkeygen(u'\335\375 upper/lower case Y with acute accent')
        [u'yy upper/lower case y with acute accent']
        >>> sortkeygen('foo9.txt')
        [u'foo', 9, u'.txt']
        >>> sortkeygen('x9y99')
        [u'x', 9, u'y', 99]
    '''
    # Ignore leading and trailing spaces
    s = unicode(s).strip()
    # All space types are equivalent
    s = ' '.join(s.split())
    # case insentsitive
    s = s.lower()
    # Title
    words = s.split()
    if len(words) > 1 and words[0] in commonleaders:
        s = ' '.join( words[1:])
    # accent and ligatures
    s = ''.join(splitchar(c) for c in s)
    # Replacements (single char replaced by one or more)
    s = ''.join( replacements.get(ch, ch) for ch in s )
    # Numeric sections as numerics
    s = [ int("""".join(g)) if isinteger else """".join(g)
          for isinteger,g in groupby(s, lambda x: x in decdigits)]
 
    return s
 
def naturalsort(items):
    ''' Naturally sort a series of strings
 
    Doctests:
        >>> naturalsort(['The Wind in the Willows','The 40th step more',
                         'The 39 steps', 'Wanda'])
        ['The 39 steps', 'The 40th step more', 'Wanda', 'The Wind in the Willows']
 
    '''
    return sorted(items, key=sortkeygen)
 
if __name__ == '__main__':
    import string
 
    ns = naturalsort
 
    print '\n# Ignoring leading spaces'
    txt = ['%signore leading spaces: 2%+i' % (' '*i, i-2) for i in range(4)]
    print 'Text strings:'; pp(txt)
    print 'Normally sorted :'; pp(sorted(txt))
    print 'Naturally sorted:'; pp(ns(txt))
 
    print '\n# Ignoring multiple adjacent spaces (m.a.s)'
    txt = ['ignore m.a.s%s spaces: 2%+i' % (' '*i, i-2) for i in range(4)]
    print 'Text strings:'; pp(txt)
    print 'Normally sorted :'; pp(sorted(txt))
    print 'Naturally sorted:'; pp(ns(txt))
 
    print '\n# Equivalent whitespace characters'
    txt = ['Equiv.%sspaces: 3%+i' % (ch, i-3)
           for i,ch in enumerate(reversed(string.whitespace))]
    print 'Text strings:'; pp(txt)
    print 'Normally sorted :'; pp(sorted(txt))
    print 'Naturally sorted:'; pp(ns(txt))
 
    print '\n# Case Indepenent sort'
    s = 'CASE INDEPENENT'
    txt = [s[:i].lower() + s[i:] + ': 3%+i' % (i-3) for i in range(1,5)]
    print 'Text strings:'; pp(txt)
    print 'Normally sorted :'; pp(sorted(txt))
    print 'Naturally sorted:'; pp(ns(txt))
 
    print '\n# Numeric fields as numerics'
    txt = ['foo100bar99baz0.txt', 'foo100bar10baz0.txt',
           'foo1000bar99baz10.txt', 'foo1000bar99baz9.txt']
    print 'Text strings:'; pp(txt)
    print 'Normally sorted :'; pp(sorted(txt))
    print 'Naturally sorted:'; pp(ns(txt))
 
    print '\n# Title sorts'
    txt = ['The Wind in the Willows','The 40th step more',
                         'The 39 steps', 'Wanda']
    print 'Text strings:'; pp(txt)
    print 'Normally sorted :'; pp(sorted(txt))
    print 'Naturally sorted:'; pp(ns(txt))
 
    print '\n# Equivalent accented characters (and case)'
    txt = ['Equiv. %s accents: 2%+i' % (ch, i-2)
           for i,ch in enumerate(u'\xfd\xddyY')]
    print 'Text strings:'; pp(txt)
    print 'Normally sorted :'; pp(sorted(txt))
    print 'Naturally sorted:'; pp(ns(txt))
 
    print '\n# Separated ligatures'
    txt = [u'\462 ligatured ij', 'no ligature',]
    print 'Text strings:'; pp(txt)
    print 'Normally sorted :'; pp(sorted(txt))
    print 'Naturally sorted:'; pp(ns(txt))
 
    print '\n# Character replacements'
    s = u'ʒſßs' # u'\u0292\u017f\xdfs'
    txt = ['Start with an %s: 2%+i' % (ch, i-2)
           for i,ch in enumerate(s)]
    print 'Text strings:'; pp(txt)
    print 'Normally sorted :'; print '\n'.join(sorted(txt))
    print 'Naturally sorted:'; print '\n'.join(ns(txt))"
nfjw,python,Nautical bell,Miscellaneous Topics,Utilities and Miscellaneous,"import time, calendar, sched, winsound
 
duration = 750      # Bell duration in ms
freq = 1280         # Bell frequency in hertz
bellchar = ""\u2407""
watches = 'Middle,Morning,Forenoon,Afternoon,First/Last dog,First'.split(',')
 
def gap(n=1):
    time.sleep(n * duration / 1000)
off = gap
 
def on(n=1):
    winsound.Beep(freq, n * duration)
 
def bong():
    on(); off(0.5)
 
def bongs(m):
    for i in range(m):
        print(bellchar, end=' ')
        bong()
        if i % 2:
            print('  ', end='')
            off(0.5)
    print('')
 
scheds =  sched.scheduler(time.time, time.sleep)
 
def ships_bell(now=None):
    def adjust_to_half_hour(atime):
        atime[4] = (atime[4] // 30) * 30
        atime[5] = 0
        return atime
 
    debug = now is not None
    rightnow = time.gmtime()
    if not debug:
        now = adjust_to_half_hour( list(rightnow) )
    then = now[::]
    then[4] += 30
    hr, mn = now[3:5]
    watch, b = divmod(int(2 * hr + mn // 30 - 1), 8)
    b += 1
    bells = '%i bell%s' % (b, 's' if b > 1 else ' ')
    if debug:
        print(""%02i:%02i, %-20s %s"" % (now[3], now[4], watches[watch] + ' watch', bells), end=' ')
    else:
        print(""%02i:%02i, %-20s %s"" % (rightnow[3], rightnow[4], watches[watch] + ' watch', bells), end=' ')
    bongs(b)
    if not debug:
        scheds.enterabs(calendar.timegm(then), 0, ships_bell)
        #print(time.struct_time(then))
        scheds.run()
 
def dbg_tester():
    for h in range(24):
        for m in (0, 30):
            if (h,m) == (24,30): break
            ships_bell( [2013, 3, 2, h, m, 15, 5, 61, 0] )
 
 
if __name__ == '__main__':
    ships_bell()"
2oty,python,Negative base numbers,Mathematics,Number Theory,"#!/bin/python
from __future__ import print_function
 
def EncodeNegBase(n, b): #Converts from decimal
	if n == 0:
		return ""0""
	out = []
	while n != 0:
		n, rem = divmod(n, b)
		if rem < 0:
			n += 1
			rem -= b
		out.append(rem)
	return """".join(map(str, out[::-1]))
 
def DecodeNegBase(nstr, b): #Converts to decimal
	if nstr == ""0"":
		return 0
 
	total = 0
	for i, ch in enumerate(nstr[::-1]):
		total += int(ch) * b**i
	return total
 
if __name__==""__main__"":
 
	print (""Encode 10 as negabinary (expect 11110)"")
	result = EncodeNegBase(10, -2)
	print (result)
	if DecodeNegBase(result, -2) == 10: print (""Converted back to decimal"")
	else: print (""Error converting back to decimal"")
 
	print (""Encode 146 as negaternary (expect 21102)"")
	result = EncodeNegBase(146, -3)
	print (result)
	if DecodeNegBase(result, -3) == 146: print (""Converted back to decimal"")
	else: print (""Error converting back to decimal"")
 
	print (""Encode 15 as negadecimal (expect 195)"")
	result = EncodeNegBase(15, -10)
	print (result)
	if DecodeNegBase(result, -10) == 15: print (""Converted back to decimal"")
	else: print (""Error converting back to decimal"")"
ac9a,python,Nested function,Programming Concepts,Fundamentals,"def makeList(separator):
    counter = 1
 
    def makeItem(item):
        nonlocal counter
        result = str(counter) + separator + item + ""\n""
        counter += 1
        return result
 
    return makeItem(""first"") + makeItem(""second"") + makeItem(""third"")
 
print(makeList("". ""))"
02fc,python,Nested templated data,Programming Concepts,Fundamentals,"from pprint import pprint as pp
 
class Template():
    def __init__(self, structure):
        self.structure = structure
        self.used_payloads, self.missed_payloads = [], []
 
    def inject_payload(self, id2data):
 
        def _inject_payload(substruct, i2d, used, missed):
            used.extend(i2d[x] for x in substruct if type(x) is not tuple and x in i2d)
            missed.extend(f'??#{x}' 
                          for x in substruct if type(x) is not tuple and x not in i2d)
            return tuple(_inject_payload(x, i2d, used, missed) 
                           if type(x) is tuple 
                           else i2d.get(x, f'??#{x}') 
                         for x in substruct)
 
        ans = _inject_payload(self.structure, id2data, 
                              self.used_payloads, self.missed_payloads)
        self.unused_payloads = sorted(set(id2data.values()) 
                                      - set(self.used_payloads))
        self.missed_payloads = sorted(set(self.missed_payloads))
        return ans
 
if __name__ == '__main__':
    index2data = {p: f'Payload#{p}' for p in range(7)}
    print(""##PAYLOADS:\n  "", end='')
    print('\n  '.join(list(index2data.values())))
    for structure in [
     (((1, 2),
       (3, 4, 1),
       5),),
 
     (((1, 2),
       (10, 4, 1),
       5),)]:
        print(""\n\n# TEMPLATE:"")
        pp(structure, width=13)
        print(""\n TEMPLATE WITH PAYLOADS:"")
        t = Template(structure)
        out = t.inject_payload(index2data)
        pp(out)
        print(""\n UNUSED PAYLOADS:\n  "", end='')
        unused = t.unused_payloads
        print('\n  '.join(unused) if unused else '-')
        print("" MISSING PAYLOADS:\n  "", end='')
        missed = t.missed_payloads
        print('\n  '.join(missed) if missed else '-')"
4t8v,python,Next highest int from digits,Algorithms and Data Structures,Algorithms,"def closest_more_than(n, lst):
    ""(index of) closest int from lst, to n that is also > n""
    large = max(lst) + 1
    return lst.index(min(lst, key=lambda x: (large if x <= n else x)))
 
def nexthigh(n):
    ""Return nxt highest number from n's digits using scan & re-order""
    assert n == int(abs(n)), ""n >= 0""
    this = list(int(digit) for digit in str(int(n)))[::-1]
    mx = this[0]
    for i, digit in enumerate(this[1:], 1):
        if digit < mx:
            mx_index = closest_more_than(digit, this[:i + 1])
            this[mx_index], this[i] = this[i], this[mx_index]
            this[:i] = sorted(this[:i], reverse=True)
            return int(''.join(str(d) for d in this[::-1]))
        elif digit > mx:
            mx, mx_index = digit, i
    return 0
 
 
if __name__ == '__main__':
    for x in [0, 9, 12, 21, 12453, 738440, 45072010, 95322020,
              9589776899767587796600]:
        print(f""{x:>12_d} -> {nexthigh(x):>12_d}"")"
resw,python,Nim game,Puzzles and Games,Game Development," 
print(""Py Nim\n"")
 
def getTokens(curTokens):
	global tokens
 
	print(""How many tokens would you like to take? "", end='')
	take = int(input())
 
	if (take < 1 or take > 3):
		print(""Number must be between 1 and 3.\n"")
		getTokens(curTokens)
		return
 
	tokens = curTokens - take
	print(f'You take {take} tokens.')
	print(f'{tokens} tokens remaining.\n')
 
def compTurn(curTokens):
	global tokens
 
	take = curTokens % 4
	tokens = curTokens - take
	print (f'Computer takes {take} tokens.')
	print (f'{tokens} tokens remaining.\n')
 
 
tokens = 12
while (tokens > 0):
	getTokens(tokens)
	compTurn(tokens)
 
print(""Computer wins!"")
 "
4ly3,python,Non-continuous subsequences,Algorithms and Data Structures,Algorithms,"def ncsub(seq, s=0):
    if seq:
        x = seq[:1]
        xs = seq[1:]
        p2 = s % 2
        p1 = not p2
        return [x + ys for ys in ncsub(xs, s + p1)] + ncsub(xs, s + p2)
    else:
        return [[]] if s >= 3 else []"
6gpo,python,Non-decimal radices/Convert,Mathematics,Number Theory,"i = int('1a',16)  # returns the integer 26"
wn9d,python,Non-decimal radices/Input,Mathematics,Number Theory,">>> text = '100'
>>> for base in range(2,21):
    print (""String '%s' in base %i is  %i in base 10"" 
           % (text, base, int(text, base)))
 
 
String '100' in base 2 is  4 in base 10
String '100' in base 3 is  9 in base 10
String '100' in base 4 is  16 in base 10
String '100' in base 5 is  25 in base 10
String '100' in base 6 is  36 in base 10
String '100' in base 7 is  49 in base 10
String '100' in base 8 is  64 in base 10
String '100' in base 9 is  81 in base 10
String '100' in base 10 is  100 in base 10
String '100' in base 11 is  121 in base 10
String '100' in base 12 is  144 in base 10
String '100' in base 13 is  169 in base 10
String '100' in base 14 is  196 in base 10
String '100' in base 15 is  225 in base 10
String '100' in base 16 is  256 in base 10
String '100' in base 17 is  289 in base 10
String '100' in base 18 is  324 in base 10
String '100' in base 19 is  361 in base 10
String '100' in base 20 is  400 in base 10"
ui00,python,Non-decimal radices/Output,Mathematics,Number Theory,"for n in range(34):
  print "" %3o %2d %2X"" % (n, n, n)"
5zdi,python,Non-transitive dice,Mathematics,Combinatorics,"from collections import namedtuple
from itertools import permutations, product
from functools import lru_cache
 
 
Die = namedtuple('Die', 'name, faces')
 
@lru_cache(maxsize=None)
def cmpd(die1, die2):
    'compares two die returning 1, -1 or 0 for >, < =='
    # Numbers of times one die wins against the other for all combinations
    # cmp(x, y) is `(x > y) - (y > x)` to return 1, 0, or -1 for numbers
    tot = [0, 0, 0]
    for d1, d2 in product(die1.faces, die2.faces):
        tot[1 + (d1 > d2) - (d2 > d1)] += 1
    win2, _, win1 = tot
    return (win1 > win2) - (win2 > win1)
 
def is_non_trans(dice):
    ""Check if ordering of die in dice is non-transitive returning dice or None""
    check = (all(cmpd(c1, c2) == -1 
                 for c1, c2 in zip(dice, dice[1:]))  # Dn < Dn+1
             and cmpd(dice[0], dice[-1]) ==  1)      # But D[0] > D[-1]
    return dice if check else False
 
def find_non_trans(alldice, n=3):
    return [perm for perm in permutations(alldice, n) 
            if is_non_trans(perm)]
 
def possible_dice(sides, mx):
    print(f""\nAll possible 1..{mx} {sides}-sided dice"")
    dice = [Die(f""D{n+1}"", faces)
            for n, faces in enumerate(product(range(1, mx+1), repeat=sides))]
    print(f'  Created {len(dice)} dice')
    print('  Remove duplicate with same bag of numbers on different faces')
    found = set()
    filtered = []
    for d in dice:
        count = tuple(sorted(d.faces))
        if count not in found:
            found.add(count)
            filtered.append(d)      
    l = len(filtered)
    print(f'   Return {l} filtered dice')
    return filtered
 
#%% more verbose extra checks
def verbose_cmp(die1, die2):
    'compares two die returning their relationship of their names as a string'
    # Numbers of times one die wins against the other for all combinations
    win1 = sum(d1 > d2 for d1, d2 in product(die1.faces, die2.faces))
    win2 = sum(d2 > d1 for d1, d2 in product(die1.faces, die2.faces))
    n1, n2 = die1.name, die2.name
    return f'{n1} > {n2}' if win1 > win2 else (f'{n1} < {n2}' if win1 < win2 else f'{n1} = {n2}')
 
def verbose_dice_cmp(dice):
    c = [verbose_cmp(x, y) for x, y in zip(dice, dice[1:])]
    c += [verbose_cmp(dice[0], dice[-1])]
    return ', '.join(c)
 
 
#%% Use
if __name__ == '__main__':
    dice = possible_dice(sides=4, mx=4)
    for N in (3, 4):   # length of non-transitive group of dice searched for
        non_trans = find_non_trans(dice, N)
        print(f'\n  Non_transitive length-{N} combinations found: {len(non_trans)}')
        for lst in non_trans:
            print()
            for i, die in enumerate(lst):
                print(f""    {' ' if i else '['}{die}{',' if i < N-1 else ']'}"")
        if non_trans:
            print('\n  More verbose comparison of last non_transitive result:')
            print(' ',   verbose_dice_cmp(non_trans[-1]))
        print('\n  ====')"
