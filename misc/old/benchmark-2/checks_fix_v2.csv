index,insperation_index_db,domain_label,label,code,Source,Description
4c5k_1,4c5k,python,Sorting Algorithm (Bubble Sort),"numbers = [64, 34, 25, 12, 22, 11, 90]
length = len(numbers)

for i in range(length):
    swapped = False
    for j in range(0, length-i-1):
        if numbers[j] > numbers[j+1]:
            numbers[j], numbers[j+1] = numbers[j+1], numbers[j]
            swapped = True
    if not swapped:
        break

print(numbers)",GPT,Same code
4c5k_2,4c5k,python,Sorting Algorithm (Bubble Sort),"vals = [64, 34, 25, 12, 22, 11, 90]
n = len(vals)

for i in range(n):
    swapped = False
    for j in range(0, n-i-1):
        if vals[j] > vals[j+1]:
            vals[j], vals[j+1] = vals[j+1], vals[j]
            swapped = True
    if not swapped:
        break

print(vals)",GPT,Different Variable Names
4c5k_3,4c5k,python,Sorting Algorithm (Bubble Sort),"# Bubble Sort: Optimized version to stop if no elements were swapped in the inner loop
numbers = [64, 34, 25, 12, 22, 11, 90]
length = len(numbers)

for i in range(length):
    swapped = False
    for j in range(0, length-i-1):
        # Swap if the element found is greater than the next element
        if numbers[j] > numbers[j+1]:
            numbers[j], numbers[j+1] = numbers[j+1], numbers[j]
            swapped = True
    # If no two elements were swapped in the inner loop, the list is sorted
    if not swapped:
        break

print(numbers)",GPT,With Documentation
4c5k_4,4c5k,python,Sorting Algorithm (Bubble Sort),"import numpy as np

numbers = np.array([64, 34, 25, 12, 22, 11, 90])
length = len(numbers)

for i in range(length):
    swapped = False
    for j in range(0, length-i-1):
        if numbers[j] > numbers[j+1]:
            numbers[j], numbers[j+1] = numbers[j+1], numbers[j]
            swapped = True
    if not swapped:
        break

print(numbers)",GPT,With External Libraries
4c5k_5,4c5k,python,Sorting Algorithm (Bubble Sort),"numbers = [64, 34, 25, 12, 22, 11, 90]

if not isinstance(numbers, list):
    raise TypeError(""Input must be a list."")

length = len(numbers)

for i in range(length):
    swapped = False
    for j in range(0, length-i-1):
        if numbers[j] > numbers[j+1]:
            numbers[j], numbers[j+1] = numbers[j+1], numbers[j]
            swapped = True
    if not swapped:
        break

print(numbers)",GPT,With Error Handling
4c5k_6,4c5k,python,Sorting Algorithm (Bubble Sort),"numbers = [64, 34, 25, 12, 22, 11, 90]
length = len(numbers)

for i in range(length):
    for _ in range(10):  # Introducing unnecessary operations
        pass
    for j in range(0, length-i-1):
        if numbers[j] > numbers[j+1]:
            numbers[j], numbers[j+1] = numbers[j+1], numbers[j]

print(numbers)",GPT,Non-Optimized Code
4c5k_7,4c5k,python,Sorting Algorithm (Bubble Sort),"x1 = [64, 34, 25, 12, 22, 11, 90]
x2 = len(x1)

for x3 in range(x2):
    swapped = False
    for x4 in range(0, x2-x3-1):
        if x1[x4] > x1[x4+1]:
            x1[x4], x1[x4+1] = x1[x4+1], x1[x4]
            swapped = True
    if not swapped:
        break

print(x1)",GPT,Abstract Names
4c5k_8,4c5k,python,Sorting Algorithm (Bubble Sort),"numbers = [64, 34, 25, 12, 22, 11, 90]
length = len(numbers)

for i in range(length):
  swapped = False
  for j in range(0, length-i-1):
   if numbers[j] > numbers[j+1]:
    numbers[j], numbers[j+1] = numbers[j+1], numbers[j]
    swapped = True
  if not swapped:
    break

print(numbers)",GPT,Different Indentations
4c5k_9,4c5k,python,Sorting Algorithm (Bubble Sort),"def bubble_sort(numbers):
    length = len(numbers)

    for i in range(length):
        swapped = False
        for j in range(0, length-i-1):
            if numbers[j] > numbers[j+1]:
                numbers[j], numbers[j+1] = numbers[j+1], numbers[j]
                swapped = True
        if not swapped:
            break
    return numbers

numbers = [64, 34, 25, 12, 22, 11, 90]
sorted_numbers = bubble_sort(numbers)
print(sorted_numbers)",GPT,Function
4c5k_10,4c5k,python,Sorting Algorithm (Bubble Sort),"numbers = [64.5, 34.2, 25.1, 12.8, 22.9, 11.4, 90.0]  # Floats instead of integers
length = len(numbers)

for i in range(length):
    swapped = False
    for j in range(0, length-i-1):
        if numbers[j] > numbers[j+1]:
            numbers[j], numbers[j+1] = numbers[j+1], numbers[j]
            swapped = True
    if not swapped:
        break

print(numbers)",GPT,Different Data Types
4c5k_11,4c5k,python,Descending Sorting Algorithm (Bubble Sort),"numbers = [64, 34, 25, 12, 22, 11, 90]
length = len(numbers)

for i in range(length):
    swapped = False
    for j in range(0, length-i-1):
        if numbers[j] < numbers[j+1]:  # Changed logic to sort in descending order
            numbers[j], numbers[j+1] = numbers[j+1], numbers[j]
            swapped = True
    if not swapped:
        break

print(numbers)",GPT,"Different Logic, Same Syntax"
4c5k_12,4c5k,python,Sorting Algorithm (Bubble Sort),"x1 = [64, 34, 25, 12, 22, 11, 90]
n = len(x1)

for i in range(n):
    swapped = False
    for j in range(0, n-i-1):
        if x1[j] > x1[j+1]:
            x1[j], x1[j+1] = x1[j+1], x1[j]
            swapped = True
    if not swapped:
        break

print(x1)",GPT,Different Variable Names + Abstract Names
4c5k_13,4c5k,python,Sorting Algorithm (Bubble Sort),"import numpy as np

# Optimized Bubble Sort with early exit and NumPy for array handling
numbers = np.array([64, 34, 25, 12, 22, 11, 90])
length = len(numbers)

for i in range(length):
    swapped = False
    for j in range(0, length-i-1):
        # Swap if the element found is greater than the next element
        if numbers[j] > numbers[j+1]:
            numbers[j], numbers[j+1] = numbers[j+1], numbers[j]
            swapped = True
    # If no two elements were swapped in the inner loop, the list is sorted
    if not swapped:
        break

print(numbers)",GPT,With Documentation + With External Libraries
4c5k_14,4c5k,python,Sorting Algorithm (Bubble Sort),"numbers = [64, 34, 25, 12, 22, 11, 90]
length = len(numbers)

for i in range(length):
    for _ in range(10):  # Extra operations added
        pass
    for j in range(0, length-i-1):
        if numbers[j] > numbers[j+1]:
            numbers[j], numbers[j+1] = numbers[j+1], numbers[j]

print(numbers)",GPT,Without Documentation + Non-Optimized Code
4c5k_15,4c5k,python,Sorting Algorithm (Bubble Sort),"numbers = [64.5, 34.2, 25.1, 12.8, 22.9, 11.4, 90.0]

if not all(isinstance(x, (int, float)) for x in numbers):
    raise TypeError(""All elements must be integers or floats."")

length = len(numbers)

for i in range(length):
    swapped = False
    for j in range(0, length-i-1):
        if numbers[j] > numbers[j+1]:
            numbers[j], numbers[j+1] = numbers[j+1], numbers[j]
            swapped = True
    if not swapped:
        break

print(numbers)",GPT,With Error Handling + Different Data Types
4c5k_16,4c5k,python,Descending Sorting Algorithm (Bubble Sort),"numbers = [64, 34, 25, 12, 22, 11, 90]
length = len(numbers)

for i in range(length):
    swapped = False
    for j in range(0, length-i-1):
        if numbers[j] < numbers[j+1]:  # Sorting in descending order
            numbers[j], numbers[j+1] = numbers[j+1], numbers[j]
            swapped = True
    if not swapped:
        break

print(numbers)",GPT,Different Logic Same Syntax + Optimized Code
4c5k_17,4c5k,python,Sorting Algorithm (Bubble Sort),"def bubble_sort(nums):
 length = len(nums)

 for i in range(length):
  swapped = False
  for j in range(0, length-i-1):
   if nums[j] > nums[j+1]:
    nums[j], nums[j+1] = nums[j+1], nums[j]
    swapped = True
  if not swapped:
   break
 return nums

numbers = [64, 34, 25, 12, 22, 11, 90]
sorted_numbers = bubble_sort(numbers)
print(sorted_numbers)",GPT,Function + Different Indentations
4c5k_18,4c5k,python,Sorting Algorithm (Bubble Sort),"import numpy as np

numbers = np.array([64, 34, 25, 12, 22, 11, 90])
length = len(numbers)

for i in range(length):
    swapped = False
    for j in range(0, length-i-1):
        if numbers[j] > numbers[j+1]:
            numbers[j], numbers[j+1] = numbers[j+1], numbers[j]
            swapped = True
    if not swapped:
        break

print(numbers.tolist())",GPT,No Function + With External Libraries
5d6l_1,5d6l,python,Sorting Algorithm (Insertion Sort),"numbers = [64, 34, 25, 12, 22, 11, 90]
length = len(numbers)

for i in range(1, length):
    key = numbers[i]
    j = i - 1
    while j >= 0 and key < numbers[j]:
        numbers[j + 1] = numbers[j]
        j -= 1
    numbers[j + 1] = key

print(numbers)",GPT,Same code
5d6l_2,5d6l,python,Sorting Algorithm (Insertion Sort),"vals = [64, 34, 25, 12, 22, 11, 90]
n = len(vals)

for i in range(1, n):
    key = vals[i]
    j = i - 1
    while j >= 0 and key < vals[j]:
        vals[j + 1] = vals[j]
        j -= 1
    vals[j + 1] = key

print(vals)",GPT,Different Variable Names
5d6l_3,5d6l,python,Sorting Algorithm (Insertion Sort),"# Insertion Sort: Sorts a list by repeatedly inserting elements in their correct position
numbers = [64, 34, 25, 12, 22, 11, 90]
length = len(numbers)

for i in range(1, length):
    key = numbers[i]
    j = i - 1
    # Move elements of numbers[0...i-1], that are greater than key, to one position ahead
    while j >= 0 and key < numbers[j]:
        numbers[j + 1] = numbers[j]
        j -= 1
    numbers[j + 1] = key

print(numbers)",GPT,With Documentation
5d6l_4,5d6l,python,Sorting Algorithm (Insertion Sort),"import numpy as np

numbers = np.array([64, 34, 25, 12, 22, 11, 90])
length = len(numbers)

for i in range(1, length):
    key = numbers[i]
    j = i - 1
    while j >= 0 and key < numbers[j]:
        numbers[j + 1] = numbers[j]
        j -= 1
    numbers[j + 1] = key

print(numbers)",GPT,With External Libraries
5d6l_5,5d6l,python,Sorting Algorithm (Insertion Sort),"numbers = [64, 34, 25, 12, 22, 11, 90]

if not isinstance(numbers, list):
    raise TypeError(""Input must be a list."")

length = len(numbers)

for i in range(1, length):
    key = numbers[i]
    j = i - 1
    while j >= 0 and key < numbers[j]:
        numbers[j + 1] = numbers[j]
        j -= 1
    numbers[j + 1] = key

print(numbers)",GPT,With Error Handling
5d6l_6,5d6l,python,Sorting Algorithm (Insertion Sort),"numbers = [64, 34, 25, 12, 22, 11, 90]
length = len(numbers)

for i in range(1, length):
    key = numbers[i]
    j = i - 1
    while j >= 0 and key < numbers[j]:
        numbers[j + 1] = numbers[j]
        j -= 1
        for _ in range(10):  # Introducing unnecessary operations
            pass
    numbers[j + 1] = key

print(numbers)",GPT,Non-Optimized Code
5d6l_7,5d6l,python,Sorting Algorithm (Insertion Sort),"x1 = [64, 34, 25, 12, 22, 11, 90]
n = len(x1)

for x2 in range(1, n):
    key = x1[x2]
    j = x2 - 1
    while j >= 0 and key < x1[j]:
        x1[j + 1] = x1[j]
        j -= 1
    x1[j + 1] = key

print(x1)",GPT,Abstract Names
5d6l_8,5d6l,python,Sorting Algorithm (Insertion Sort),"numbers = [64, 34, 25, 12, 22, 11, 90]
length = len(numbers)

for i in range(1, length):
 key = numbers[i]
 j = i - 1
 while j >= 0 and key < numbers[j]:
  numbers[j + 1] = numbers[j]
  j -= 1
 numbers[j + 1] = key

print(numbers)",GPT,Different Indentations
5d6l_9,5d6l,python,Sorting Algorithm (Insertion Sort),"def insertion_sort(nums):
    length = len(nums)

    for i in range(1, length):
        key = nums[i]
        j = i - 1
        while j >= 0 and key < nums[j]:
            nums[j + 1] = nums[j]
            j -= 1
        nums[j + 1] = key
    return nums

numbers = [64, 34, 25, 12, 22, 11, 90]
sorted_numbers = insertion_sort(numbers)
print(sorted_numbers)",GPT,Function
5d6l_10,5d6l,python,Sorting Algorithm (Insertion Sort),"numbers = [64.5, 34.2, 25.1, 12.8, 22.9, 11.4, 90.0]  # Floats instead of integers
length = len(numbers)

for i in range(1, length):
    key = numbers[i]
    j = i - 1
    while j >= 0 and key < numbers[j]:
        numbers[j + 1] = numbers[j]
        j -= 1
    numbers[j + 1] = key

print(numbers)",GPT,Different Data Types
5d6l_11,5d6l,python,Descending Sorting Algorithm (Insertion Sort),"numbers = [64, 34, 25, 12, 22, 11, 90]
length = len(numbers)

for i in range(1, length):
    key = numbers[i]
    j = i - 1
    while j >= 0 and key > numbers[j]:  # Sorting in descending order
        numbers[j + 1] = numbers[j]
        j -= 1
    numbers[j + 1] = key

print(numbers)",GPT,"Different Logic, Same Syntax"
5d6l_12,5d6l,python,Sorting Algorithm (Insertion Sort),"x1 = [64, 34, 25, 12, 22, 11, 90]
n = len(x1)

for x2 in range(1, n):
    key = x1[x2]
    j = x2 - 1
    while j >= 0 and key < x1[j]:
        x1[j + 1] = x1[j]
        j -= 1
    x1[j + 1] = key

print(x1)",GPT,Different Variable Names + Abstract Names
5d6l_13,5d6l,python,Sorting Algorithm (Insertion Sort),"import numpy as np

# Insertion Sort: Sorts an array by repeatedly inserting elements in their correct position
numbers = np.array([64, 34, 25, 12, 22, 11, 90])
length = len(numbers)

for i in range(1, length):
    key = numbers[i]
    j = i - 1
    # Move elements of numbers[0...i-1], that are greater than key, to one position ahead
    while j >= 0 and key < numbers[j]:
        numbers[j + 1] = numbers[j]
        j -= 1
    numbers[j + 1] = key

print(numbers)",GPT,With Documentation + With External Libraries
5d6l_14,5d6l,python,Sorting Algorithm (Insertion Sort),"numbers = [64, 34, 25, 12, 22, 11, 90]
length = len(numbers)

for i in range(1, length):
    key = numbers[i]
    j = i - 1
    while j >= 0 and key < numbers[j]:
        numbers[j + 1] = numbers[j]
        j -= 1
        for _ in range(10):  # Extra operations added
            pass
    numbers[j + 1] = key

print(numbers)",GPT,Without Documentation + Non-Optimized Code
5d6l_15,5d6l,python,Sorting Algorithm (Insertion Sort),"numbers = [64.5, 34.2, 25.1, 12.8, 22.9, 11.4, 90.0]

if not all(isinstance(x, (int, float)) for x in numbers):
    raise TypeError(""All elements must be integers or floats."")

length = len(numbers)

for i in range(1, length):
    key = numbers[i]
    j = i - 1
    while j >= 0 and key < numbers[j]:
        numbers[j + 1] = numbers[j]
        j -= 1
    numbers[j + 1] = key

print(numbers)",GPT,With Error Handling + Different Data Types
5d6l_16,5d6l,python,Descending Sorting Algorithm (Insertion Sort),"numbers = [64, 34, 25, 12, 22, 11, 90]
length = len(numbers)

for i in range(1, length):
    key = numbers[i]
    j = i - 1
    while j >= 0 and key > numbers[j]:  # Sorting in descending order
        numbers[j + 1] = numbers[j]
        j -= 1
    numbers[j + 1] = key

print(numbers)",GPT,"Different Logic, Same Syntax + Optimized Code"
5d6l_17,5d6l,python,Sorting Algorithm (Insertion Sort),"def insertion_sort(nums):
 length = len(nums)

 for i in range(1, length):
  key = nums[i]
  j = i - 1
  while j >= 0 and key < nums[j]:
   nums[j + 1] = nums[j]
   j -= 1
  nums[j + 1] = key
 return nums

numbers = [64, 34, 25, 12, 22, 11, 90]
sorted_numbers = insertion_sort(numbers)
print(sorted_numbers)",GPT,Function + Different Indentations
5d6l_18,5d6l,python,Sorting Algorithm (Insertion Sort),"import numpy as np

numbers = np.array([64, 34, 25, 12, 22, 11, 90])
length = len(numbers)

for i in range(1, length):
    key = numbers[i]
    j = i - 1
    while j >= 0 and key < numbers[j]:
        numbers[j + 1] = numbers[j]
        j -= 1
    numbers[j + 1] = key

print(numbers.tolist())",GPT,No Function + With External Libraries
unrelated_1,,python,Print Hello World,"print('Hello, World!')",GPT,A code snippet unrelated to any found in the examples
8en0g_1,8en0g,go,Sum and product of an array,"package main

import ""fmt""

func main() {
    sum, prod := 0, 1
    for _, x := range []int{1,2,5} {
        sum += x
        prod *= x
    }
    fmt.Println(sum, prod)
}",rosetta,Same code
8en0g_2,8en0g,go,Sum and product of an array,"package main

import ""fmt""

func main() {
    total, product := 0, 1
    for _, value := range []int{1,2,5} {
        total += value
        product *= value
    }
    fmt.Println(total, product)
}",GPT,Different Variable Names
8en0g_3,8en0g,go,Sum and product of an array,"package main

import ""fmt""

// main calculates the sum and product of an array of integers
func main() {
    sum, prod := 0, 1
    for _, x := range []int{1, 2, 5} {
        sum += x // Add current element to sum
        prod *= x // Multiply current element to product
    }
    fmt.Println(sum, prod) // Output the sum and product
}",GPT,With Documentation
8en0g_4,8en0g,go,Sum and product of an array,"package main

import (
    ""fmt""
    ""log""
)

func main() {
    sum, prod := 0, 1
    for _, x := range []int{1, 2, 5} {
        sum += x
        prod *= x
    }
    log.Printf(""Sum: %d, Product: %d"", sum, prod) // Using external library for logging
}",GPT,With External Libraries
8en0g_5,8en0g,go,Sum and product of an array,"package main

import (
    ""fmt""
    ""errors""
)

func main() {
    sum, prod := 0, 1
    for _, x := range []int{1, 2, 5} {
        if x < 0 {
            fmt.Println(errors.New(""negative number in array""))
            return
        }
        sum += x
        prod *= x
    }
    fmt.Println(sum, prod)
}",GPT,With Error Handling
8en0g_6,8en0g,go,Sum and product of an array,"package main

import ""fmt""

func main() {
    sum, prod := 0, 1
    numbers := []int{1, 2, 5}
    for i := 0; i < len(numbers); i++ { // Non-optimized: using index loop instead of range
        sum += numbers[i]
        prod *= numbers[i]
    }
    fmt.Println(sum, prod)
}",GPT,Non-Optimized Code
8en0g_7,8en0g,go,Sum and product of an array,"package main

import ""fmt""

func main() {
    a, b := 0, 1
    for _, c := range []int{1, 2, 5} {
        a += c
        b *= c
    }
    fmt.Println(a, b)
}",GPT,Abstract Names
8en0g_8,8en0g,go,Sum and product of an array,"package main

import ""fmt""

func main() {
 sum, prod := 0, 1
  for _, x := range []int{1, 2, 5} {
     sum += x
      prod *= x
 }
 fmt.Println(sum, prod)
}",GPT,Different Indentations
8en0g_9,8en0g,go,Sum and product of an array,"package main

import ""fmt""

func calculateSumAndProduct(numbers []int) (int, int) {
    sum, prod := 0, 1
    for _, x := range numbers {
        sum += x
        prod *= x
    }
    return sum, prod
}

func main() {
    numbers := []int{1, 2, 5}
    sum, prod := calculateSumAndProduct(numbers)
    fmt.Println(sum, prod)
}",GPT,Function
8en0g_10,8en0g,go,Sum and product of an array,"package main

import ""fmt""

func main() {
    sum, prod := float64(0), float64(1)
    for _, x := range []float64{1.0, 2.0, 5.0} {
        sum += x
        prod *= x
    }
    fmt.Println(sum, prod)
}",GPT,Different Data Types
8en0g_11,8en0g,go,Sum and product of an array,"package main

import ""fmt""

func main() {
    sum, prod := 0, 1
    for _, x := range []int{1, 2, 5} {
        sum -= x // Different logic: subtracting instead of adding
        prod /= x // Different logic: dividing instead of multiplying
    }
    fmt.Println(sum, prod)
}",GPT,"Different Logic, Same Syntax"
8en0g_12,8en0g,go,Sum and product of an array,"package main

import ""fmt""

func main() {
    total, multiplier := 0, 1
    for _, value := range []int{1, 2, 5} {
        total += value
        multiplier *= value
    }
    fmt.Println(total, multiplier)
}",GPT,Different Variable Names + Abstract Names
8en0g_13,8en0g,go,Sum and product of an array,"package main

import (
    ""fmt""
    ""log""
)

// main calculates the sum and product of an array of integers and logs the result
func main() {
    sum, prod := 0, 1
    for _, x := range []int{1, 2, 5} {
        sum += x // Add current element to sum
        prod *= x // Multiply current element to product
    }
    log.Printf(""Sum: %d, Product: %d"", sum, prod)
}",GPT,With Documentation + With External Libraries
8en0g_14,8en0g,go,Sum and product of an array,"package main

import ""fmt""

func main() {
    sum, prod := 0, 1
    numbers := []int{1, 2, 5}
    for i := 0; i < len(numbers); i++ {
        sum += numbers[i]
        prod *= numbers[i]
    }
    fmt.Println(sum, prod)
}",GPT,Without Documentation + Non-Optimized Code
8en0g_15,8en0g,go,Sum and product of an array,"package main

import (
    ""fmt""
    ""errors""
)

func main() {
    sum, prod := float64(0), float64(1)
    for _, x := range []float64{1.0, 2.0, 5.0} {
        if x < 0 {
            fmt.Println(errors.New(""negative number in array""))
            return
        }
        sum += x
        prod *= x
    }
    fmt.Println(sum, prod)
}",GPT,With Error Handling + Different Data Types
8en0g_16,8en0g,go,Sum and product of an array,"package main

import ""fmt""

func main() {
    sum, prod := 0, 1
    for _, x := range []int{1, 2, 5} {
        sum -= x // Different logic: subtracting instead of adding
        prod /= x // Different logic: dividing instead of multiplying
    }
    fmt.Println(sum, prod)
}",GPT,Different Logic Same Syntax + Optimized Code
8en0g_17,8en0g,go,Sum and product of an array,"package main

import ""fmt""

func calculateSumAndProduct(numbers []int) (int, int) {
 sum, prod := 0, 1
  for _, x := range numbers {
   sum += x
    prod *= x
 }
 return sum, prod
}

func main() {
 numbers := []int{1, 2, 5}
  sum, prod := calculateSumAndProduct(numbers)
 fmt.Println(sum, prod)
}",GPT,Function + Different Indentations
8en0g_18,8en0g,go,Sum and product of an array,"package main

import (
    ""fmt""
    ""log""
)

func main() {
    sum, prod := 0, 1
    for _, x := range []int{1, 2, 5} {
        sum += x
        prod *= x
    }
    log.Printf(""Sum: %d, Product: %d"", sum, prod)
}",GPT,No Function + With External Libraries
17ipc_1,17ipc,python,Sum and product puzzle,"from collections import Counter

def decompose_sum(s):
    return [(a,s-a) for a in range(2,int(s/2+1))]


all_pairs = set((a,b) for a in range(2,100) for b in range(a+1,100) if a+b<100)


product_counts = Counter(c*d for c,d in all_pairs)
unique_products = set((a,b) for a,b in all_pairs if product_counts[a*b]==1)
s_pairs = [(a,b) for a,b in all_pairs if
    all((x,y) not in unique_products for (x,y) in decompose_sum(a+b))]


product_counts = Counter(c*d for c,d in s_pairs)
p_pairs = [(a,b) for a,b in s_pairs if product_counts[a*b]==1]


sum_counts = Counter(c+d for c,d in p_pairs)
final_pairs = [(a,b) for a,b in p_pairs if sum_counts[a+b]==1]

print(final_pairs)",rosetta,Same code
17ipc_2,17ipc,python,Sum and product puzzle,"from collections import Counter

def split_sum(s):
    return [(x, s-x) for x in range(2, int(s/2+1))]

pair_set = set((x, y) for x in range(2, 100) for y in range(x+1, 100) if x+y < 100)

prod_counts = Counter(x*y for x, y in pair_set)
unique_pairs = set((x, y) for x, y in pair_set if prod_counts[x*y] == 1)
filtered_pairs = [(x, y) for x, y in pair_set if
    all((a, b) not in unique_pairs for (a, b) in split_sum(x+y))]

prod_counts = Counter(x*y for x, y in filtered_pairs)
final_pairs = [(x, y) for x, y in filtered_pairs if prod_counts[x*y] == 1]

sum_counts = Counter(x+y for x, y in final_pairs)
final_result = [(x, y) for x, y in final_pairs if sum_counts[x+y] == 1]

print(final_result)",GPT,Different Variable Names
17ipc_3,17ipc,python,Sum and product puzzle,"from collections import Counter

def decompose_sum(s):
    """"""
    Decomposes a sum into pairs of integers that add up to 's'.
    """"""
    return [(a, s-a) for a in range(2, int(s/2+1))]

# Generate all pairs (a, b) where a + b < 100
all_pairs = set((a, b) for a in range(2, 100) for b in range(a+1, 100) if a + b < 100)

# Count occurrences of product values
product_counts = Counter(c*d for c, d in all_pairs)

# Filter unique products
unique_products = set((a, b) for a, b in all_pairs if product_counts[a*b] == 1)

# Generate pairs that are not in unique products
s_pairs = [(a, b) for a, b in all_pairs if
           all((x, y) not in unique_products for (x, y) in decompose_sum(a + b))]

# Further filter pairs based on product counts
product_counts = Counter(c*d for c, d in s_pairs)
p_pairs = [(a, b) for a, b in s_pairs if product_counts[a*b] == 1]

# Count sums of pairs and filter final result
sum_counts = Counter(c+d for c, d in p_pairs)
final_pairs = [(a, b) for a, b in p_pairs if sum_counts[a+b] == 1]

# Print the final result
print(final_pairs)",GPT,With Documentation
17ipc_4,17ipc,python,Sum and product puzzle,"from collections import Counter
import numpy as np

def decompose_sum(s):
    return [(a, s-a) for a in range(2, int(s/2+1))]

all_pairs = set((a, b) for a in np.arange(2, 100) for b in np.arange(a+1, 100) if a + b < 100)

product_counts = Counter(np.prod([c, d]) for c, d in all_pairs)
unique_products = set((a, b) for a, b in all_pairs if product_counts[a*b] == 1)
s_pairs = [(a, b) for a, b in all_pairs if
           all((x, y) not in unique_products for (x, y) in decompose_sum(a + b))]

product_counts = Counter(np.prod([c, d]) for c, d in s_pairs)
p_pairs = [(a, b) for a, b in s_pairs if product_counts[a*b] == 1]

sum_counts = Counter(np.sum([c, d]) for c, d in p_pairs)
final_pairs = [(a, b) for a, b in p_pairs if sum_counts[a+b] == 1]

print(final_pairs)",GPT,With External Libraries
17ipc_5,17ipc,python,Sum and product puzzle,"from collections import Counter

def decompose_sum(s):
    try:
        return [(a, s-a) for a in range(2, int(s/2+1))]
    except TypeError:
        print(""Error: Invalid input type for sum decomposition."")
        return []

try:
    all_pairs = set((a, b) for a in range(2, 100) for b in range(a+1, 100) if a + b < 100)

    product_counts = Counter(c*d for c, d in all_pairs)
    unique_products = set((a, b) for a, b in all_pairs if product_counts[a*b] == 1)
    s_pairs = [(a, b) for a, b in all_pairs if
               all((x, y) not in unique_products for (x, y) in decompose_sum(a + b))]

    product_counts = Counter(c*d for c, d in s_pairs)
    p_pairs = [(a, b) for a, b in s_pairs if product_counts[a*b] == 1]

    sum_counts = Counter(c+d for c, d in p_pairs)
    final_pairs = [(a, b) for a, b in p_pairs if sum_counts[a+b] == 1]

    print(final_pairs)

except Exception as e:
    print(f""An error occurred: {e}"")",GPT,With Error Handling
17ipc_6,17ipc,python,Sum and product puzzle,"from collections import Counter

def decompose_sum(s):
    return [(a, s-a) for a in range(2, int(s/2+1))]

all_pairs = set((a, b) for a in range(2, 100) for b in range(a+1, 100) if a + b < 100)

# Unnecessary double counting
product_counts = Counter(c*d for c, d in all_pairs)
for c, d in all_pairs:
    product_counts[c*d] += 1

unique_products = set((a, b) for a, b in all_pairs if product_counts[a*b] == 1)
s_pairs = [(a, b) for a, b in all_pairs if
           all((x, y) not in unique_products for (x, y) in decompose_sum(a + b))]

product_counts = Counter(c*d for c, d in s_pairs)
p_pairs = [(a, b) for a, b in s_pairs if product_counts[a*b] == 1]

sum_counts = Counter(c+d for c, d in p_pairs)
final_pairs = [(a, b) for a, b in p_pairs if sum_counts[a+b] == 1]

print(final_pairs)",GPT,Non-Optimized Code
17ipc_7,17ipc,python,Sum and product puzzle,"from collections import Counter

def dec_sum(s):
    return [(x, s-x) for x in range(2, int(s/2+1))]

pr_set = set((x, y) for x in range(2, 100) for y in range(x+1, 100) if x + y < 100)

prod_cts = Counter(x*y for x, y in pr_set)
uq_pairs = set((x, y) for x, y in pr_set if prod_cts[x*y] == 1)
s_pairs = [(x, y) for x, y in pr_set if
           all((a, b) not in uq_pairs for (a, b) in dec_sum(x + y))]

prod_cts = Counter(x*y for x, y in s_pairs)
p_pairs = [(x, y) for x, y in s_pairs if prod_cts[x*y] == 1]

sum_cts = Counter(x+y for x, y in p_pairs)
fin_prs = [(x, y) for x, y in p_pairs if sum_cts[x+y] == 1]

print(fin_prs)",GPT,Abstract Names
17ipc_8,17ipc,python,Sum and product puzzle,"from collections import Counter

def decompose_sum(s):
 return [(a, s-a) for a in range(2, int(s/2+1))]

all_pairs = set((a, b) for a in range(2, 100) for b in range(a+1, 100) if a + b < 100)

product_counts = Counter(c*d for c, d in all_pairs)
unique_products = set((a, b) for a, b in all_pairs if product_counts[a*b] == 1)
s_pairs = [(a, b) for a, b in all_pairs if
   all((x, y) not in unique_products for (x, y) in decompose_sum(a + b))]

product_counts = Counter(c*d for c, d in s_pairs)
p_pairs = [(a, b) for a, b in s_pairs if product_counts[a*b] == 1]

sum_counts = Counter(c+d for c, d in p_pairs)
final_pairs = [(a, b) for a, b in p_pairs if sum_counts[a+b] == 1]

print(final_pairs)",GPT,Different Indentations
17ipc_9,17ipc,python,Sum and product puzzle,"from collections import Counter

def decompose_sum(s):
    return [(a, s-a) for a in range(2, int(s/2+1))]

def find_final_pairs():
    all_pairs = set((a, b) for a in range(2, 100) for b in range(a+1, 100) if a + b < 100)

    product_counts = Counter(c*d for c, d in all_pairs)
    unique_products = set((a, b) for a, b in all_pairs if",GPT,Function
17ipc_10,17ipc,python,Sum and product puzzle,"from collections import Counter

def decompose_sum(s):
    return [(float(a), float(s-a)) for a in range(2, int(s/2+1))]

all_pairs = set((float(a), float(b)) for a in range(2, 100) for b in range(a+1, 100) if a + b < 100)

product_counts = Counter(float(c*d) for c, d in all_pairs)
unique_products = set((float(a), float(b)) for a, b in all_pairs if product_counts[a*b] == 1)
s_pairs = [(float(a), float(b)) for a, b in all_pairs if
           all((float(x), float(y)) not in unique_products for (x, y) in decompose_sum(a + b))]

product_counts = Counter(float(c*d) for c, d in s_pairs)
p_pairs = [(float(a), float(b)) for a, b in s_pairs if product_counts[a*b] == 1]

sum_counts = Counter(float(c+d) for c, d in p_pairs)
final_pairs = [(float(a), float(b)) for a, b in p_pairs if sum_counts[a+b] == 1]

print(final_pairs)",GPT,Different Data Types
17ipc_11,17ipc,python,Sum and product puzzle,"from collections import Counter

def decompose_sum(s):
    return [(a, s-a) for a in range(2, int(s/2+1))]

# Different logic: Consider pairs where a + b >= 100 instead of a + b < 100
all_pairs = set((a, b) for a in range(2, 100) for b in range(a+1, 100) if a + b >= 100)

product_counts = Counter(c*d for c, d in all_pairs)
unique_products = set((a, b) for a, b in all_pairs if product_counts[a*b] == 1)
s_pairs = [(a, b) for a, b in all_pairs if
           all((x, y) not in unique_products for (x, y) in decompose_sum(a + b))]

product_counts = Counter(c*d for c, d in s_pairs)
p_pairs = [(a, b) for a, b in s_pairs if product_counts[a*b] == 1]

sum_counts = Counter(c+d for c, d in p_pairs)
final_pairs = [(a, b) for a, b in p_pairs if sum_counts[a+b] == 1]

print(final_pairs)",GPT,"Different Logic, Same Syntax"
17ipc_12,17ipc,python,Sum and product puzzle,"from collections import Counter

def split_sum(s):
    return [(x, s-x) for x in range(2, int(s/2+1))]

pair_set = set((x, y) for x in range(2, 100) for y in range(x+1, 100) if x + y < 100)

prod_counts = Counter(x*y for x, y in pair_set)
unique_pairs = set((x, y) for x, y in pair_set if prod_counts[x*y] == 1)
filtered_pairs = [(x, y) for x, y in pair_set if
    all((a, b) not in unique_pairs for (a, b) in split_sum(x + y))]

prod_counts = Counter(x*y for x, y in filtered_pairs)
final_pairs = [(x, y) for x, y in filtered_pairs if prod_counts[x*y] == 1]

sum_counts = Counter(x+y for x, y in final_pairs)
final_result = [(x, y) for x, y in final_pairs if sum_counts[x+y] == 1]

print(final_result)",GPT,Different Variable Names + Abstract Names
17ipc_13,17ipc,python,Sum and product puzzle,"from collections import Counter
import numpy as np

def decompose_sum(s):
    """"""
    Decomposes a sum into pairs of integers that add up to 's'.
    """"""
    return [(a, s-a) for a in range(2, int(s/2+1))]

# Generate all pairs (a, b) where a + b < 100
all_pairs = set((a, b) for a in np.arange(2, 100) for b in np.arange(a+1, 100) if a + b < 100)

# Count occurrences of product values
product_counts = Counter(np.prod([c, d]) for c, d in all_pairs)

# Filter unique products
unique_products = set((a, b) for a, b in all_pairs if product_counts[a*b] == 1)

# Generate pairs that are not in unique products
s_pairs = [(a, b) for a, b in all_pairs if
           all((x, y) not in unique_products for (x, y) in decompose_sum(a + b))]

# Further filter pairs based on product counts
product_counts = Counter(np.prod([c, d]) for c, d in s_pairs)
p_pairs = [(a, b) for a, b in s_pairs if product_counts[a*b] == 1]

# Count sums of pairs and filter final result
sum_counts = Counter(np.sum([c, d]) for c, d in p_pairs)
final_pairs = [(a, b) for a, b in p_pairs if sum_counts[a+b] == 1]

# Print the final result
print(final_pairs)",GPT,With Documentation + With External Libraries
17ipc_14,17ipc,python,Sum and product puzzle,"from collections import Counter

def decompose_sum(s):
    return [(a, s-a) for a in range(2, int(s/2+1))]

all_pairs = set((a, b) for a in range(2, 100) for b in range(a+1, 100) if a + b < 100)

# Unnecessary double counting
product_counts = Counter(c*d for c, d in all_pairs)
for c, d in all_pairs:
    product_counts[c*d] += 1

unique_products = set((a, b) for a, b in all_pairs if product_counts[a*b] == 1)
s_pairs = [(a, b) for a, b in all_pairs if
           all((x, y) not in unique_products for (x, y) in decompose_sum(a + b))]

product_counts = Counter(c*d for c, d in s_pairs)
p_pairs = [(a, b) for a, b in s_pairs if product_counts[a*b] == 1]

sum_counts = Counter(c+d for c, d in p_pairs)
final_pairs = [(a, b) for a, b in p_pairs if sum_counts[a+b] == 1]

print(final_pairs)",GPT,Without Documentation + Non-Optimized Code
17ipc_15,17ipc,python,Sum and product puzzle,"from collections import Counter

def decompose_sum(s):
    try:
        return [(float(a), float(s-a)) for a in range(2, int(s/2+1))]
    except TypeError:
        print(""Error: Invalid input type for sum decomposition."")
        return []

try:
    all_pairs = set((float(a), float(b)) for a in range(2, 100) for b in range(a+1, 100) if a + b < 100)

    product_counts = Counter(float(c*d) for c, d in all_pairs)
    unique_products = set((float(a), float(b)) for a, b in all_pairs if product_counts[a*b] == 1)
    s_pairs = [(float(a), float(b)) for a, b in all_pairs if
               all((float(x), float(y)) not in unique_products for (x, y) in decompose_sum(a + b))]

    product_counts = Counter(float(c*d) for c, d in s_pairs)
    p_pairs = [(float(a), float(b)) for a, b in s_pairs if product_counts[a*b] == 1]

    sum_counts = Counter(float(c+d) for c, d in p_pairs)
    final_pairs = [(float(a), float(b)) for a, b in p_pairs if sum_counts[a+b] == 1]

    print(final_pairs)

except Exception as e:
    print(f""An error occurred: {e}"")",GPT,With Error Handling + Different Data Types
17ipc_16,17ipc,python,Sum and product puzzle,"from collections import Counter

def decompose_sum(s):
    return [(a, s-a) for a in range(2, int(s/2+1))]

# Different logic: Consider pairs where a + b >= 100 instead of a + b < 100
all_pairs = set((a, b) for a in range(2, 100) for b in range(a+1, 100) if a + b >= 100)

product_counts = Counter(c*d for c, d in all_pairs)
unique_products = set((a, b) for a, b in all_pairs if product_counts[a*b] == 1)
s_pairs = [(a, b) for a, b in all_pairs if
           all((x, y) not in unique_products for (x, y) in decompose_sum(a + b))]

product_counts = Counter(c*d for c, d in s_pairs)
p_pairs = [(a, b) for a, b in s_pairs if product_counts[a*b] == 1]

sum_counts = Counter(c+d for c, d in p_pairs)
final_pairs = [(a, b) for a, b in p_pairs if sum_counts[a+b] == 1]

print(final_pairs)",GPT,Different Logic Same Syntax + Optimized Code
17ipc_17,17ipc,python,Sum and product puzzle,"from collections import Counter

def decompose_sum(s):
 return [(a, s-a) for a in range(2, int(s/2+1))]

def find_final_pairs():
 all_pairs = set((a, b) for a in range(2, 100) for b in range(a+1, 100) if a + b < 100)

 product_counts = Counter(c*d for c, d in all_pairs)
 unique_products = set((a, b) for a, b in all_pairs if product_counts[a*b] == 1)
 s_pairs = [(a, b) for a, b in all_pairs if
  all((x, y) not in unique_products for (x, y) in decompose_sum(a + b))]

 product_counts = Counter(c*d for c, d in s_pairs)
 p_pairs = [(a, b) for a, b in s_pairs if product_counts[a*b] == 1]

 sum_counts = Counter(c+d for c, d in p_pairs)
 final_pairs = [(a, b) for a, b in p_pairs if sum_counts[a+b] == 1]

 return final_pairs

final_result = find_final_pairs()
print(final_result)",GPT,Function + Different Indentations
17ipc_18,17ipc,python,Sum and product puzzle,"from collections import Counter
import numpy as np

# Using external libraries (numpy) without encapsulating logic in a function
all_pairs = set((a, b) for a in np.arange(2, 100) for b in np.arange(a+1, 100) if a + b < 100)

product_counts = Counter(np.prod([c, d]) for c, d in all_pairs)
unique_products = set((a, b) for a, b in all_pairs if product_counts[a*b] == 1)
s_pairs = [(a, b) for a, b in all_pairs if
           all((x, y) not in unique_products for (x, y) in [(a, s-a) for a in range(2, int((a+b)/2+1))])]

product_counts = Counter(np.prod([c, d]) for c, d in s_pairs)
p_pairs = [(a, b) for a, b in s_pairs if product_counts[a*b] == 1]

sum_counts = Counter(np.sum([c, d]) for c, d in p_pairs)
final_pairs = [(a, b) for a, b in p_pairs if sum_counts[a+b] == 1]

print(final_pairs)",GPT,No Function + With External Libraries
8ev06_1,8ev06,java,Temperature conversion,"public class TemperatureConversion {
    public static void main(String args[]) {
        if (args.length == 1) {
            try {
                double kelvin = Double.parseDouble(args[0]);
                if (kelvin >= 0) {
                    System.out.printf(""K %2.2f\n"", kelvin);
                    System.out.printf(""C %2.2f\n"", kelvinToCelsius(kelvin));
                    System.out.printf(""F %2.2f\n"", kelvinToFahrenheit(kelvin));
                    System.out.printf(""R %2.2f\n"", kelvinToRankine(kelvin));
                } else {
                    System.out.printf(""%2.2f K is below absolute zero"", kelvin);
                }
            } catch (NumberFormatException e) {
                System.out.println(e);
            }
        }
    }

    public static double kelvinToCelsius(double k) {
        return k - 273.15;
    }

    public static double kelvinToFahrenheit(double k) {
        return k * 1.8 - 459.67;
    }

    public static double kelvinToRankine(double k) {
        return k * 1.8;
    }
}",rosetta,Same code
8ev06_2,8ev07,java,Temperature conversion,"public class TempConversion {
    public static void main(String args[]) {
        if (args.length == 1) {
            try {
                double tempInKelvin = Double.parseDouble(args[0]);
                if (tempInKelvin >= 0) {
                    System.out.printf(""K %2.2f\n"", tempInKelvin);
                    System.out.printf(""C %2.2f\n"", convertKelvinToCelsius(tempInKelvin));
                    System.out.printf(""F %2.2f\n"", convertKelvinToFahrenheit(tempInKelvin));
                    System.out.printf(""R %2.2f\n"", convertKelvinToRankine(tempInKelvin));
                } else {
                    System.out.printf(""%2.2f K is below absolute zero"", tempInKelvin);
                }
            } catch (NumberFormatException ex) {
                System.out.println(ex);
            }
        }
    }

    public static double convertKelvinToCelsius(double k) {
        return k - 273.15;
    }

    public static double convertKelvinToFahrenheit(double k) {
        return k * 1.8 - 459.67;
    }

    public static double convertKelvinToRankine(double k) {
        return k * 1.8;
    }
}",GPT,Different Variable Names
8ev06_3,8ev08,java,Temperature conversion,"/**
 * A simple utility class for temperature conversion from Kelvin to other units.
 */
public class TemperatureConversion {
    
    /**
     * The main method to run the temperature conversion.
     * @param args Command line arguments, expects a single Kelvin value.
     */
    public static void main(String args[]) {
        if (args.length == 1) {
            try {
                double kelvin = Double.parseDouble(args[0]);
                if (kelvin >= 0) {
                    System.out.printf(""K %2.2f\n"", kelvin);
                    System.out.printf(""C %2.2f\n"", kelvinToCelsius(kelvin));
                    System.out.printf(""F %2.2f\n"", kelvinToFahrenheit(kelvin));
                    System.out.printf(""R %2.2f\n"", kelvinToRankine(kelvin));
                } else {
                    System.out.printf(""%2.2f K is below absolute zero"", kelvin);
                }
            } catch (NumberFormatException e) {
                System.out.println(""Error: Invalid input. Please provide a numeric value."");
            }
        } else {
            System.out.println(""Please provide a single temperature in Kelvin."");
        }
    }

    /**
     * Converts Kelvin to Celsius.
     * @param k Temperature in Kelvin.
     * @return Temperature in Celsius.
     */
    public static double kelvinToCelsius(double k) {
        return k - 273.15;
    }

    /**
     * Converts Kelvin to Fahrenheit.
     * @param k Temperature in Kelvin.
     * @return Temperature in Fahrenheit.
     */
    public static double kelvinToFahrenheit(double k) {
        return k * 1.8 - 459.67;
    }

    /**
     * Converts Kelvin to Rankine.
     * @param k Temperature in Kelvin.
     * @return Temperature in Rankine.
     */
    public static double kelvinToRankine(double k) {
        return k * 1.8;
    }
}",GPT,With Documentation
8ev06_4,8ev09,java,Temperature conversion,"import org.apache.commons.math3.util.Precision; // Using Apache Commons Math for precision handling

public class TemperatureConversion {
    public static void main(String args[]) {
        if (args.length == 1) {
            try {
                double kelvin = Double.parseDouble(args[0]);
                if (kelvin >= 0) {
                    System.out.printf(""K %2.2f\n"", kelvin);
                    System.out.printf(""C %2.2f\n"", Precision.round(kelvinToCelsius(kelvin), 2));
                    System.out.printf(""F %2.2f\n"", Precision.round(kelvinToFahrenheit(kelvin), 2));
                    System.out.printf(""R %2.2f\n"", Precision.round(kelvinToRankine(kelvin), 2));
                } else {
                    System.out.printf(""%2.2f K is below absolute zero"", kelvin);
                }
            } catch (NumberFormatException e) {
                System.out.println(e);
            }
        }
    }

    public static double kelvinToCelsius(double k) {
        return k - 273.15;
    }

    public static double kelvinToFahrenheit(double k) {
        return k * 1.8 - 459.67;
    }

    public static double kelvinToRankine(double k) {
        return k * 1.8;
    }
}",GPT,With External Libraries
8ev06_5,8ev10,java,Temperature conversion,"public class TemperatureConversion {
    public static void main(String args[]) {
        if (args.length == 1) {
            try {
                double kelvin = Double.parseDouble(args[0]);
                if (kelvin < 0) {
                    throw new IllegalArgumentException(""Temperature below absolute zero is not possible."");
                }
                System.out.printf(""K %2.2f\n"", kelvin);
                System.out.printf(""C %2.2f\n"", kelvinToCelsius(kelvin));
                System.out.printf(""F %2.2f\n"", kelvinToFahrenheit(kelvin));
                System.out.printf(""R %2.2f\n"", kelvinToRankine(kelvin));
            } catch (NumberFormatException e) {
                System.out.println(""Invalid input. Please enter a valid number."");
            } catch (IllegalArgumentException e) {
                System.out.println(e.getMessage());
            }
        } else {
            System.out.println(""Please provide exactly one argument for the temperature in Kelvin."");
        }
    }

    public static double kelvinToCelsius(double k) {
        return k - 273.15;
    }

    public static double kelvinToFahrenheit(double k) {
        return k * 1.8 - 459.67;
    }

    public static double kelvinToRankine(double k) {
        return k * 1.8;
    }
}",GPT,With Error Handling
8ev06_6,8ev11,java,Temperature conversion,"public class TemperatureConversion {
    public static void main(String args[]) {
        if (args.length == 1) {
            try {
                double kelvin = Double.parseDouble(args[0]);
                if (kelvin >= 0) {
                    System.out.printf(""K %2.2f\n"", kelvin);
                    System.out.printf(""C %2.2f\n"", kelvinToCelsius(kelvin));
                    // Recalculating Fahrenheit unnecessarily
                    System.out.printf(""F %2.2f\n"", kelvin * 1.8 - 459.67);
                    System.out.printf(""R %2.2f\n"", kelvinToRankine(kelvin));
                } else {
                    System.out.printf(""%2.2f K is below absolute zero"", kelvin);
                }
            } catch (NumberFormatException e) {
                System.out.println(e);
            }
        }
    }

    public static double kelvinToCelsius(double k) {
        return k - 273.15;
    }

    public static double kelvinToFahrenheit(double k) {
        return k * 1.8 - 459.67;
    }

    public static double kelvinToRankine(double k) {
        return k * 1.8;
    }
}",GPT,Non-Optimized Code
8ev06_7,8ev12,java,Temperature conversion,"public class TempConv {
    public static void main(String args[]) {
        if (args.length == 1) {
            try {
                double k = Double.parseDouble(args[0]);
                if (k >= 0) {
                    System.out.printf(""K %2.2f\n"", k);
                    System.out.printf(""C %2.2f\n"", kToC(k));
                    System.out.printf(""F %2.2f\n"", kToF(k));
                    System.out.printf(""R %2.2f\n"", kToR(k));
                } else {
                    System.out.printf(""%2.2f K is below absolute zero"", k);
                }
            } catch (NumberFormatException ex) {
                System.out.println(ex);
            }
        }
    }

    public static double kToC(double k) {
        return k - 273.15;
    }

    public static double kToF(double k) {
        return k * 1.8 - 459.67;
    }

    public static double kToR(double k) {
        return k * 1.8;
    }
}",GPT,Abstract Names
8ev06_8,8ev13,java,Temperature conversion,"public class TemperatureConversion {
 public static void main(String args[]) {
  if (args.length == 1) {
   try {
    double kelvin = Double.parseDouble(args[0]);
    if (kelvin >= 0) {
     System.out.printf(""K %2.2f\n"", kelvin);
     System.out.printf(""C %2.2f\n"", kelvinToCelsius(kelvin));
     System.out.printf(""F %2.2f\n"", kelvinToFahrenheit(kelvin));
     System.out.printf(""R %2.2f\n"", kelvinToRankine(kelvin));
    } else {
     System.out.printf(""%2.2f K is below absolute zero"", kelvin);
    }
   } catch (NumberFormatException e) {
    System.out.println(e);
   }
  }
 }

 public static double kelvinToCelsius(double k) {
  return",GPT,Different Indentations
8ev06_9,8ev14,java,Temperature conversion,"public class TemperatureConversion {
    
    public static void main(String args[]) {
        if (args.length == 1) {
            try {
                double kelvin = Double.parseDouble(args[0]);
                convertAndPrintTemperatures(kelvin);
            } catch (NumberFormatException e) {
                System.out.println(e);
            }
        }
    }

    public static void convertAndPrintTemperatures(double kelvin) {
        if (kelvin >= 0) {
            System.out.printf(""K %2.2f\n"", kelvin);
            System.out.printf(""C %2.2f\n"", kelvinToCelsius(kelvin));
            System.out.printf(""F %2.2f\n"", kelvinToFahrenheit(kelvin));
            System.out.printf(""R %2.2f\n"", kelvinToRankine(kelvin));
        } else {
            System.out.printf(""%2.2f K is below absolute zero"", kelvin);
        }
    }

    public static double kelvinToCelsius(double k) {
        return k - 273.15;
    }

    public static double kelvinToFahrenheit(double k) {
        return k * 1.8 - 459.67;
    }

    public static double kelvinToRankine(double k) {
        return k * 1.8;
    }
}",GPT,Function
8ev06_10,8ev15,java,Temperature conversion,"public class TemperatureConversion {
    public static void main(String args[]) {
        if (args.length == 1) {
            try {
                double kelvin = Double.parseDouble(args[0]);
                if (kelvin >= 0) {
                    System.out.printf(""K %2.2f\n"", kelvin);
                    System.out.printf(""C %2.2f\n"", kelvinToCelsius(kelvin));
                    System.out.printf(""F %2.2f\n"", kelvinToFahrenheit(kelvin));
                    System.out.printf(""R %2.2f\n"", kelvinToRankine(kelvin));
                } else {
                    System.out.printf(""%2.2f K is below absolute zero"", kelvin);
                }
            } catch (NumberFormatException e) {
                System.out.println(e);
            }
        }
    }

    public static float kelvinToCelsius(double k) {
        return (float) (k - 273.15);
    }

    public static float kelvinToFahrenheit(double k) {
        return (float) (k * 1.8 - 459.67);
    }

    public static float kelvinToRankine(double k) {
        return (float) (k * 1.8);
    }
}",GPT,Different Data Types
8ev06_11,8ev16,java,Temperature conversion,"public class TemperatureConversion {
    public static void main(String args[]) {
        if (args.length == 1) {
            try {
                double kelvin = Double.parseDouble(args[0]);
                if (kelvin >= 0) {
                    System.out.printf(""K %2.2f\n"", kelvin);
                    System.out.printf(""C %2.2f\n"", kelvinToCelsius(kelvin));
                    System.out.printf(""F %2.2f\n"", kelvinToFahrenheit(kelvin));
                    System.out.printf(""R %2.2f\n"", kelvinToRankine(kelvin));
                } else {
                    System.out.printf(""%2.2f K is below absolute zero"", kelvin);
                }
            } catch (NumberFormatException e) {
                System.out.println(e);
            }
        }
    }

    public static double kelvinToCelsius(double k) {
        return k + 273.15;  // Changed logic: adding instead of subtracting
    }

    public static double kelvinToFahrenheit(double k) {
        return k / 1.8 + 459.67;  // Changed logic: dividing instead of multiplying
    }

    public static double kelvinToRankine(double k) {
        return k / 1.8;  // Changed logic: dividing instead of multiplying
    }
}",GPT,"Different Logic, Same Syntax"
8ev06_12,8ev17,java,Temperature conversion,"public class TempConv {
    public static void main(String args[]) {
        if (args.length == 1) {
            try {
                double k = Double.parseDouble(args[0]);
                if (k >= 0) {
                    System.out.printf(""K %2.2f\n"", k);
                    System.out.printf(""C %2.2f\n"", kToC(k));
                    System.out.printf(""F %2.2f\n"", kToF(k));
                    System.out.printf(""R %2.2f\n"", kToR(k));
                } else {
                    System.out.printf(""%2.2f K is below absolute zero"", k);
                }
            } catch (NumberFormatException ex) {
                System.out.println(ex);
            }
        }
    }

    public static double kToC(double k) {
        return k - 273.15;
    }

    public static double kToF(double k) {
        return k * 1.8 - 459.67;
    }

    public static double kToR(double k) {
        return k * 1.8;
    }
}",GPT,Different Variable Names + Abstract Names
8ev06_13,8ev18,java,Temperature conversion,"import org.apache.commons.math3.util.Precision; // Using Apache Commons Math for precision handling

/**
 * A utility class for temperature conversion from Kelvin to other units.
 */
public class TemperatureConversion {
    
    /**
     * The main method to run the temperature conversion.
     * @param args Command line arguments, expects a single Kelvin value.
     */
    public static void main(String args[]) {
        if (args.length == 1) {
            try {
                double kelvin = Double.parseDouble(args[0]);
                if (kelvin >= 0) {
                    System.out.printf(""K %2.2f\n"", kelvin);
                    System.out.printf(""C %2.2f\n"", Precision.round(kelvinToCelsius(kelvin), 2));
                    System.out.printf(""F %2.2f\n"", Precision.round(kelvinToFahrenheit(kelvin), 2));
                    System.out.printf(""R %2.2f\n"", Precision.round(kelvinToRankine(kelvin), 2));
                } else {
                    System.out.printf(""%2.2f K is below absolute zero"", kelvin);
                }
            } catch (NumberFormatException e) {
                System.out.println(""Error: Invalid input. Please provide a numeric value."");
            }
        } else {
            System.out.println(""Please provide a single temperature in Kelvin."");
        }
    }

    /**
     * Converts Kelvin to Celsius.
     * @param k Temperature in Kelvin.
     * @return Temperature in Celsius.
     */
    public static double kelvinToCelsius(double k) {
        return k - 273.15;
    }

    /**
     * Converts Kelvin to Fahrenheit.
     * @param k Temperature in Kelvin.
     * @return Temperature in Fahrenheit.
     */
    public static double kelvinToFahrenheit(double k) {
        return k * 1.8 - 459.67;
    }

    /**
     * Converts Kelvin to Rankine.
     * @param k Temperature in Kelvin.
     * @return Temperature in Rankine.
     */
    public static double kelvinToRankine(double k) {
        return k * 1.8;
    }
}",GPT,With Documentation + With External Libraries
8ev06_14,8ev19,java,Temperature conversion,"public class TemperatureConversion {
    public static void main(String args[]) {
        if (args.length == 1) {
            try {
                double kelvin = Double.parseDouble(args[0]);
                if (kelvin >= 0) {
                    System.out.printf(""K %2.2f\n"", kelvin);
                    System.out.printf(""C %2.2f\n"", kelvinToCelsius(kelvin));
                    System.out.printf(""F %2.2f\n"", kelvin * 1.8 - 459.67); // Non-optimized: Recalculated Fahrenheit
                    System.out.printf(""R %2.2f\n"", kelvinToRankine(kelvin));
                } else {
                    System.out.printf(""%2.2f K is below absolute zero"", kelvin);
                }
            } catch (NumberFormatException e) {
                System.out.println(e);
            }
        }
    }

    public static double kelvinToCelsius(double k) {
        return k - 273.15;
    }

    public static double kelvinToFahrenheit(double k) {
        return k * 1.8 - 459.67;
    }

    public static double kelvinToRankine(double k) {
        return k * 1.8;
    }
}",GPT,Without Documentation + Non-Optimized Code
8ev06_15,8ev20,java,Temperature conversion,"public class TemperatureConversion {
    public static void main(String args[]) {
        if (args.length == 1) {
            try {
                double kelvin = Double.parseDouble(args[0]);
                if (kelvin < 0) {
                    throw new IllegalArgumentException(""Temperature below absolute zero is not possible."");
                }
                System.out.printf(""K %2.2f\n"", kelvin);
                System.out.printf(""C %2.2f\n"", kelvinToCelsius(kelvin));
                System.out.printf(""F %2.2f\n"", kelvinToFahrenheit(kelvin));
                System.out.printf(""R %2.2f\n"", kelvinToRankine(kelvin));
            } catch (NumberFormatException e) {
                System.out.println(""Invalid",GPT,With Error Handling + Different Data Types
8ev06_16,8ev21,java,Temperature conversion,"public class TemperatureConversion {
    public static void main(String args[]) {
        if (args.length == 1) {
            try {
                double kelvin = Double.parseDouble(args[0]);
                if (kelvin >= 0) {
                    System.out.printf(""K %2.2f\n"", kelvin);
                    System.out.printf(""C %2.2f\n"", kelvinToCelsius(kelvin));
                    System.out.printf(""F %2.2f\n"", kelvinToFahrenheit(kelvin));
                    System.out.printf(""R %2.2f\n"", kelvinToRankine(kelvin));
                } else {
                    System.out.printf(""%2.2f K is below absolute zero"", kelvin);
                }
            } catch (NumberFormatException e) {
                System.out.println(e);
            }
        }
    }

    public static double kelvinToCelsius(double k) {
        return k + 273.15;  // Changed logic: adding instead of subtracting
    }

    public static double kelvinToFahrenheit(double k) {
        return (k * 1.8 - 459.67) / 1.1;  // Changed logic: included an arbitrary division for optimization
    }

    public static double kelvinToRankine(double k) {
        return k * 1.8;
    }
}",GPT,Different Logic Same Syntax + Optimized Code
8ev06_17,8ev22,java,Temperature conversion,"public class TemperatureConversion {

    public static void main(String args[]) {
        if (args.length == 1) {
            try {
                double kelvin = Double.parseDouble(args[0]);
                printTemperatures(kelvin);
            } catch (NumberFormatException e) {
                System.out.println(e);
            }
        }
    }

    public static void printTemperatures(double kelvin) {
     if (kelvin >= 0) {
      System.out.printf(""K %2.2f\n"", kelvin);
      System.out.printf(""C %2.2f\n"", kelvinToCelsius(kelvin));
      System.out.printf(""F %2.2f\n"", kelvinToFahrenheit(kelvin));
      System.out.printf(""R %2.2f\n"", kelvinToRankine(kelvin));
     } else {
      System.out.printf(""%2.2f K is below absolute zero"", kelvin);
     }
    }

    public static double kelvinToCelsius(double k) {
        return k - 273.15;
    }

    public static double kelvinToFahrenheit(double k) {
        return k * 1.8 - 459.67;
    }

    public static double kelvinToRankine(double k) {
        return k * 1.8;
    }
}",GPT,Function + Different Indentations
8ev06_18,8ev23,java,Temperature conversion,"import org.apache.commons.math3.util.Precision; // Using Apache Commons Math for precision handling

public class TemperatureConversion {
    public static void main(String args[]) {
        if (args.length == 1) {
            try {
                double kelvin = Double.parseDouble(args[0]);
                if (kelvin >= 0) {
                    System.out.printf(""K %2.2f\n"", Precision.round(kelvin, 2));
                    System.out.printf(""C %2.2f\n"", Precision.round(kelvin - 273.15, 2));
                    System.out.printf(""F %2.2f\n"", Precision.round(kelvin * 1.8 - 459.67, 2));
                    System.out.printf(""R %2.2f\n"", Precision.round(kelvin * 1.8, 2));
                } else {
                    System.out.printf(""%2.2f K is below absolute zero"", Precision.round(kelvin, 2));
                }
            } catch (NumberFormatException e) {
                System.out.println(e);
            }
        }
    }
}",GPT,No Function + With External Libraries
ydj6g_1,ydj6g,java,Summarize and say sequence,"import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.IntStream;

public class SelfReferentialSequence {

    static Map<String, Integer> cache = new ConcurrentHashMap<>(10_000);

    public static void main(String[] args) {
        Seeds res = IntStream.range(0, 1000_000)
                .parallel()
                .mapToObj(n -> summarize(n, false))
                .collect(Seeds::new, Seeds::accept, Seeds::combine);

        System.out.println(""Seeds:"");
        res.seeds.forEach(e -> System.out.println(Arrays.toString(e)));

        System.out.println(""\nSequence:"");
        summarize(res.seeds.get(0)[0], true);
    }

    static int[] summarize(int seed, boolean display) {
        String n = String.valueOf(seed);

        String k = Arrays.toString(n.chars().sorted().toArray());
        if (!display && cache.get(k) != null)
            return new int[]{seed, cache.get(k)};

        Set<String> seen = new HashSet<>();
        StringBuilder sb = new StringBuilder();

        int[] freq = new int[10];

        while (!seen.contains(n)) {
            seen.add(n);

            int len = n.length();
            for (int i = 0; i < len; i++)
                freq[n.charAt(i) - '0']++;

            sb.setLength(0);
            for (int i = 9; i >= 0; i--) {
                if (freq[i] != 0) {
                    sb.append(freq[i]).append(i);
                    freq[i] = 0;
                }
            }
            if (display)
                System.out.println(n);
            n = sb.toString();
        }

        cache.put(k, seen.size());

        return new int[]{seed, seen.size()};
    }

    static class Seeds {
        int largest = Integer.MIN_VALUE;
        List<int[]> seeds = new ArrayList<>();

        void accept(int[] s) {
            int size = s[1];
            if (size >= largest) {
                if (size > largest) {
                    largest = size;
                    seeds.clear();
                }
                seeds.add(s);
            }
        }

        void combine(Seeds acc) {
            acc.seeds.forEach(this::accept);
        }
    }
}",rosetta,Same code
ydj6g_2,ydj6g,java,Summarize and say sequence,"import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.IntStream;

public class SelfReferentialSequence {

    static Map<String, Integer> cacheMap = new ConcurrentHashMap<>(10_000);

    public static void main(String[] args) {
        Seeds results = IntStream.range(0, 1000_000)
                .parallel()
                .mapToObj(num -> computeSequence(num, false))
                .collect(Seeds::new, Seeds::accept, Seeds::combine);

        System.out.println(""Seeds:"");
        results.seeds.forEach(entry -> System.out.println(Arrays.toString(entry)));

        System.out.println(""\nSequence:"");
        computeSequence(results.seeds.get(0)[0], true);
    }

    static int[] computeSequence(int number, boolean display) {
        String numStr = String.valueOf(number);

        String key = Arrays.toString(numStr.chars().sorted().toArray());
        if (!display && cacheMap.get(key) != null)
            return new int[]{number, cacheMap.get(key)};

        Set<String> seenNumbers = new HashSet<>();
        StringBuilder strBuilder = new StringBuilder();

        int[] frequency = new int[10];

        while (!seenNumbers.contains(numStr)) {
            seenNumbers.add(numStr);

            int length = numStr.length();
            for (int i = 0; i < length; i++)
                frequency[numStr.charAt(i) - '0']++;

            strBuilder.setLength(0);
            for (int i = 9; i >= 0; i--) {
                if (frequency[i] != 0) {
                    strBuilder.append(frequency[i]).append(i);
                    frequency[i] = 0;
                }
            }
            if (display)
                System.out.println(numStr);
            numStr = strBuilder.toString();
        }

        cacheMap.put(key, seenNumbers.size());

        return new int[]{number, seenNumbers.size()};
    }

    static class Seeds {
        int largestSize = Integer.MIN_VALUE;
        List<int[]> seeds = new ArrayList<>();

        void accept(int[] sequence) {
            int size = sequence[1];
            if (size >= largestSize) {
                if (size > largestSize) {
                    largestSize = size;
                    seeds.clear();
                }
                seeds.add(sequence);
            }
        }

        void combine(Seeds accumulator) {
            accumulator.seeds.forEach(this::accept);
        }
    }
}",GPT,Different Variable Names
ydj6g_3,ydj6g,java,Summarize and say sequence,"import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.IntStream;

/**
 * A class to generate self-referential sequences and store them in a cache.
 */
public class SelfReferentialSequence {

    // Cache to store computed sequences with a fixed size
    static Map<String, Integer> cache = new ConcurrentHashMap<>(10_000);

    /**
     * Main method to execute the sequence generation.
     *
     * @param args Command-line arguments.
     */
    public static void main(String[] args) {
        Seeds res = IntStream.range(0, 1000_000)
                .parallel()
                .mapToObj(n -> summarize(n, false))
                .collect(Seeds::new, Seeds::accept, Seeds::combine);

        System.out.println(""Seeds:"");
        res.seeds.forEach(e -> System.out.println(Arrays.toString(e)));

        System.out.println(""\nSequence:"");
        summarize(res.seeds.get(0)[0], true);
    }

    /**
     * Summarizes a sequence based on a seed number and optionally displays it.
     *
     * @param seed    The seed number.
     * @param display Whether to display the sequence.
     * @return An array containing the seed and the size of the sequence.
     */
    static int[] summarize(int seed, boolean display) {
        String n = String.valueOf(seed);

        String k = Arrays.toString(n.chars().sorted().toArray());
        if (!display && cache.get(k) != null)
            return new int[]{seed, cache.get(k)};

        Set<String> seen = new HashSet<>();
        StringBuilder sb = new StringBuilder();

        int[] freq = new int[10];

        while (!seen.contains(n)) {
            seen.add(n);

            int len = n.length();
            for (int i = 0; i < len; i++)
                freq[n.charAt(i) - '0']++;

            sb.setLength(0);
            for (int i = 9; i >= 0; i--) {
                if (freq[i] != 0) {
                    sb.append(freq[i]).append(i);
                    freq[i] = 0;
                }
            }
            if (display)
                System.out.println(n);
            n = sb.toString();
        }

        cache.put(k, seen.size());

        return new int[]{seed, seen.size()};
    }

    /**
     * A nested class to manage the collection of seeds and their corresponding sequences.
     */
    static class Seeds {
        int largest = Integer.MIN_VALUE;
        List<int[]> seeds = new ArrayList<>();

        void accept(int[] s) {
            int size = s[1];
            if (size >= largest) {
                if (size > largest) {
                    largest = size;
                    seeds.clear();
                }
                seeds.add(s);
            }
        }

        void combine(Seeds acc) {
            acc.seeds.forEach(this::accept);
        }
    }
}",GPT,With Documentation
ydj6g_4,ydj6g,java,Summarize and say sequence,"import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.IntStream;
import org.apache.commons.lang3.ArrayUtils; // Using Apache Commons Lang for array utilities

public class SelfReferentialSequence {

    static Map<String, Integer> cache = new ConcurrentHashMap<>(10_000);

    public static void main(String[] args) {
        Seeds res = IntStream.range(0, 1000_000)
                .parallel()
                .mapToObj(n -> summarize(n, false))
                .collect(Seeds::new, Seeds::accept, Seeds::combine);

        System.out.println(""Seeds:"");
        res.seeds.forEach(e -> System.out.println(ArrayUtils.toString(e)));

        System.out.println(""\nSequence:"");
        summarize(res.seeds.get(0)[0], true);
    }

    static int[] summarize(int seed, boolean display) {
        String n = String.valueOf(seed);

        String k = ArrayUtils.toString(n.chars().sorted().toArray());
        if (!display && cache.get(k) != null)
            return new int[]{seed, cache.get(k)};

        Set<String> seen = new HashSet<>();
        StringBuilder sb = new StringBuilder();

        int[] freq = new int[10];

        while (!seen.contains(n)) {
            seen.add(n);

            int len = n.length();
            for (int i = 0; i < len; i++)
                freq[n.charAt(i) - '0']++;

            sb.setLength(0);
            for (int i = 9; i >= 0; i--) {
                if (freq[i] != 0) {
                    sb.append(freq[i]).append(i);
                    freq[i] = 0;
                }
            }
            if (display)
                System.out.println(n);
            n = sb.toString();
        }

        cache.put(k, seen.size());

        return new int[]{seed, seen.size()};
    }

    static class Seeds {
        int largest = Integer.MIN_VALUE;
        List<int[]> seeds = new ArrayList<>();

        void accept(int[] s) {
            int size = s[1];
            if (size >= largest) {
                if (size > largest) {
                    largest = size;
                    seeds.clear();
                }
                seeds.add(s);
            }
        }

        void combine(Seeds acc) {
            acc.seeds.forEach(this::accept);
        }
    }
}",GPT,With External Libraries
ydj6g_5,ydj6g,java,Summarize and say sequence,"import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.IntStream;

public class SelfReferentialSequence {

    static Map<String, Integer> cache = new ConcurrentHashMap<>(10_000);

    public static void main(String[] args) {
        try {
            Seeds res = IntStream.range(0, 1000_000)
                    .parallel()
                    .mapToObj(n -> summarize(n, false))
                    .collect(Seeds::new, Seeds::accept, Seeds::combine);

            System.out.println(""Seeds:"");
            res.seeds.forEach(e -> System.out.println(Arrays.toString(e)));

            System.out.println(""\nSequence:"");
            summarize(res.seeds.get(0)[0], true);
        } catch (Exception e) {
            System.err.println(""An error occurred: "" + e.getMessage());
        }
    }

    static int[] summarize(int seed, boolean display) {
        String n = String.valueOf(seed);

        String k = Arrays.toString(n.chars().sorted().toArray());
        if (!display && cache.get(k) != null)
            return new int[]{seed, cache.get(k)};

        Set<String> seen = new HashSet<>();
        StringBuilder sb = new StringBuilder();

        int[] freq = new int[10];

        while (!seen.contains(n)) {
            seen.add(n);

            int len = n.length();
            for (int i = 0; i < len; i++)
                freq[n.charAt(i) - '0']++;

            sb.setLength(0);
            for (int i = 9; i >= 0; i--) {
                if (freq[i] != 0) {
                    sb.append(freq[i]).append(i);
                    freq[i] = 0;
                }
            }
            if (display)
                System.out.println",GPT,With Error Handling
ydj6g_6,ydj6g,java,Summarize and say sequence,"import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.IntStream;

public class SelfReferentialSequence {

    static Map<String, Integer> cache = new ConcurrentHashMap<>(10_000);

    public static void main(String[] args) {
        Seeds res = IntStream.range(0, 1000_000)
                .parallel()
                .mapToObj(n -> summarize(n, false))
                .collect(Seeds::new, Seeds::accept, Seeds::combine);

        // Additional redundant operations added to simulate non-optimized code
        for (int i = 0; i < 1000; i++) {
            int[] dummy = new int[i];
            Arrays.fill(dummy, i);
        }

        System.out.println(""Seeds:"");
        res.seeds.forEach(e -> System.out.println(Arrays.toString(e)));

        System.out.println(""\nSequence:"");
        summarize(res.seeds.get(0)[0], true);
    }

    static int[] summarize(int seed, boolean display) {
        String n = String.valueOf(seed);

        String k = Arrays.toString(n.chars().sorted().toArray());
        if (!display && cache.get(k) != null)
            return new int[]{seed, cache.get(k)};

        Set<String> seen = new HashSet<>();
        StringBuilder sb = new StringBuilder();

        int[] freq = new int[10];

        while (!seen.contains(n)) {
            seen.add(n);

            int len = n.length();
            for (int i = 0; i < len; i++)
                freq[n.charAt(i) - '0']++;

            // Another unnecessary loop added to simulate non-optimized code
            for (int i = 0; i < freq.length; i++) {
                int temp = freq[i];
                freq[i] = temp;
            }

            sb.setLength(0);
            for (int i = 9; i >= 0; i--) {
                if (freq[i] != 0) {
                    sb.append(freq[i]).append(i);
                    freq[i] = 0;
                }
            }
            if (display)
                System.out.println(n);
            n = sb.toString();
        }

        cache.put(k, seen.size());

        return new int[]{seed, seen.size()};
    }

    static class Seeds {
        int largest = Integer.MIN_VALUE;
        List<int[]> seeds = new ArrayList<>();

        void accept(int[] s) {
            int size = s[1];
            if (size >= largest) {
                if (size > largest) {
                    largest = size;
                    seeds.clear();
                }
                seeds.add(s);
            }
        }

        void combine(Seeds acc) {
            acc.seeds.forEach(this::accept);
        }
    }
}",GPT,Non-Optimized Code
ydj6g_7,ydj6g,java,Summarize and say sequence,"import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.IntStream;

public class SRS {

    static Map<String, Integer> cMap = new ConcurrentHashMap<>(10_000);

    public static void main(String[] args) {
        DataContainer res = IntStream.range(0, 1000_000)
                .parallel()
                .mapToObj(i -> compute(i, false))
                .collect(DataContainer::new, DataContainer::add, DataContainer::merge);

        System.out.println(""Data:"");
        res.dataList.forEach(e -> System.out.println(Arrays.toString(e)));

        System.out.println(""\nComputation:"");
        compute(res.dataList.get(0)[0], true);
    }

    static int[] compute(int num, boolean display) {
        String str = String.valueOf(num);

        String key = Arrays.toString(str.chars().sorted().toArray());
        if (!display && cMap.get(key) != null)
            return new int[]{num, cMap.get(key)};

        Set<String> tracked = new HashSet<>();
        StringBuilder builder = new StringBuilder();

        int[] countArray = new int[10];

        while (!tracked.contains(str)) {
            tracked.add(str);

            int length = str.length();
            for (int i = 0; i < length; i++)
                countArray[str.charAt(i) - '0']++;

            builder.setLength(0);
            for (int i = 9; i >= 0; i--) {
                if (countArray[i] != 0) {
                    builder.append(countArray[i]).append(i);
                    countArray[i] = 0;
                }
            }
            if (display)
                System.out.println(str);
            str = builder.toString();
        }

        cMap.put(key, tracked.size());

        return new int[]{num, tracked.size()};
    }

    static class DataContainer {
        int maxSize = Integer.MIN_VALUE;
        List<int[]> dataList = new ArrayList<>();

        void add(int[] data) {
            int size = data[1];
            if (size >= maxSize) {
                if (size > maxSize) {
                    maxSize = size;
                    dataList.clear();
                }
                dataList.add(data);
            }
        }

        void merge(DataContainer acc) {
            acc.dataList.forEach(this::add);
        }
    }
}",GPT,Abstract Names
ydj6g_8,ydj6g,java,Summarize and say sequence,"import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.IntStream;

public class SelfReferentialSequence {

 static Map<String, Integer> cache = new ConcurrentHashMap<>(10_000);

 public static void main(String[] args) {
  Seeds res = IntStream.range(0, 1000_000)
    .parallel()
    .mapToObj(n -> summarize(n, false))
    .collect(Seeds::new, Seeds::accept, Seeds::combine);

  System.out.println(""Seeds:"");
  res.seeds.forEach(e -> System.out.println(Arrays.toString(e)));

  System.out.println(""\nSequence:"");
  summarize(res.seeds.get(0)[0], true);
 }

 static int[] summarize(int seed, boolean display) {
  String n = String.valueOf(seed);

  String k = Arrays.toString(n.chars().sorted().toArray());
  if (!display && cache.get(k) != null)
   return new int[]{seed, cache.get(k)};

  Set<String> seen = new HashSet<>();
  StringBuilder sb = new StringBuilder();

  int[] freq = new int[10];

  while (!seen.contains(n)) {
   seen.add(n);

   int len = n.length();
   for (int i = 0; i < len; i++)
    freq[n.charAt(i) - '0']++;

   sb.setLength(0);
   for (int i = 9; i >= 0; i--) {
    if (freq[i] != 0) {
     sb.append(freq[i]).append(i);
     freq[i] = 0;
    }
   }
   if (display)
    System.out.println(n);
   n = sb.toString();
  }

  cache.put(k, seen.size());

  return new int[]{seed, seen.size()};
 }

 static class Seeds {
  int largest = Integer.MIN_VALUE;
  List<int[]> seeds = new ArrayList<>();

  void accept(int[] s) {
   int size = s[1];
   if (size >= largest) {
    if (size > largest) {
     largest = size;
     seeds.clear();
    }
    seeds.add(s);
   }
  }

  void combine(Seeds acc) {
   acc.seeds.forEach(this::accept);
  }
 }
}",GPT,Different Indentations
ydj6g_9,ydj6g,java,Summarize and say sequence,"import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.IntStream;

public class SelfReferentialSequence {

    static Map<String, Integer> cache = new ConcurrentHashMap<>(10_000);

    public static void main(String[] args) {
        SelfReferentialSequence sequence = new SelfReferentialSequence();
        Seeds res = sequence.generateSeeds();

        System.out.println(""Seeds:"");
        res.seeds.forEach(e -> System.out.println(Arrays.toString(e)));

        System.out.println(""\nSequence:"");
        sequence.summarize(res.seeds.get(0)[0], true);
    }

    public Seeds generateSeeds() {
        return IntStream.range(0, 1000_000)
                .parallel()
                .mapToObj(n -> summarize(n, false))
                .collect(Seeds::new, Seeds::accept, Seeds::combine);
    }

    public int[] summarize(int seed, boolean display) {
        String n = String.valueOf(seed);

        String k = Arrays.toString(n.chars().sorted().toArray());
        if (!display && cache.get(k) != null)
            return new int[]{seed, cache.get(k)};

        Set<String> seen = new HashSet<>();
        StringBuilder sb = new StringBuilder();

        int[] freq = new int[10];

        while (!seen.contains(n)) {
            seen.add(n);

            int len = n.length();
            for (int i = 0; i < len; i++)
                freq[n.charAt(i) - '0']++;

            sb.setLength(0);
            for (int i = 9; i >= 0; i--) {
                if (freq[i] != 0) {
                    sb.append(freq[i]).append(i);
                    freq[i] = 0;
                }
            }
            if (display)
                System.out.println(n);
            n = sb.toString();
        }

        cache.put(k, seen.size());

        return new int[]{seed, seen.size()};
    }

    static class Seeds {
        int largest = Integer.MIN_VALUE;
        List<int[]> seeds = new ArrayList<>();

        void accept(int[] s) {
            int size = s[1];
            if (",GPT,Function
ydj6g_10,ydj6g,java,Summarize and say sequence,"import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.IntStream;

public class SelfReferentialSequence {

    static Map<String, Long> cache = new ConcurrentHashMap<>(10_000); // Changed Integer to Long

    public static void main(String[] args) {
        Seeds res = IntStream.range(0, 1000_000)
                .parallel()
                .mapToObj(n -> summarize((long) n, false)) // Type cast to long
                .collect(Seeds::new, Seeds::accept, Seeds::combine);

        System.out.println(""Seeds:"");
        res.seeds.forEach(e -> System.out.println(Arrays.toString(e)));

        System.out.println(""\nSequence:"");
        summarize(res.seeds.get(0)[0], true);
    }

    static long[] summarize(long seed, boolean display) {
        String n = String.valueOf(seed);

        String k = Arrays.toString(n.chars().sorted().toArray());
        if (!display && cache.get(k) != null)
            return new long[]{seed, cache.get(k)};

        Set<String> seen = new HashSet<>();
        StringBuilder sb = new StringBuilder();

        long[] freq = new long[10]; // Changed int to long

        while (!seen.contains(n)) {
            seen.add(n);

            int len = n.length();
            for (int i = 0; i < len; i++)
                freq[n.charAt(i) - '0']++;

            sb.setLength(0);
            for (int i = 9; i >= 0; i--) {
                if (freq[i] != 0) {
                    sb.append(freq[i]).append(i);
                    freq[i] = 0;
                }
            }
            if (display)
                System.out.println(n);
            n = sb.toString();
        }

        cache.put(k, (long) seen.size());

        return new long[]{seed, (long) seen.size()};
    }

    static class Seeds {
        long largest = Long.MIN_VALUE; // Changed int to long
        List<long[]> seeds = new ArrayList<>();

        void accept(long[] s) {
            long size = s[1];
            if (size >= largest) {
                if (size > largest) {
                    largest = size;
                    seeds.clear();
                }
                seeds.add(s);
            }
        }

        void combine(Seeds acc) {
            acc.seeds.forEach(this::accept);
        }
    }
}",GPT,Different Data Types
ydj6g_11,ydj6g,java,Summarize and say sequence,"import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.IntStream;

public class SelfReferentialSequence {

    static Map<String, Integer> cache = new ConcurrentHashMap<>(10_000);

    public static void main(String[] args) {
        Seeds res = IntStream.range(0, 1000_000)
                .parallel()
                .mapToObj(n -> summarize(n, false))
                .collect(Seeds::new, Seeds::accept, Seeds::combine);

        System.out.println(""Seeds:"");
        res.seeds.forEach(e -> System.out.println(Arrays.toString(e)));

        System.out.println(""\nSequence:"");
        summarize(res.seeds.get(0)[0], true);
    }

    static int[] summarize(int seed, boolean display) {
        String n = String.valueOf(seed);

        String k = Arrays.toString(n.chars().sorted().toArray());
        if (!display && cache.get(k) != null)
            return new int[]{seed, cache.get(k)};

        Set<String> seen = new TreeSet<>(); // Changed logic by using TreeSet instead of HashSet
        StringBuilder sb = new StringBuilder();

        int[] freq = new int[10];

        while (!seen.contains(n)) {
            seen.add(n);

            int len = n.length();
            for (int i = 0; i < len; i++)
                freq[n.charAt(i) - '0']++;

            sb.setLength(0);
            for (int i = 9; i >= 0; i--) {
                if (freq[i] != 0) {
                    sb.append(freq[i]).append(i);
                    freq[i] = 0;
                }
            }
            if (display)
                System.out.println(n);
            n = sb.toString();
        }

        cache.put(k, seen.size());

        return new int[]{seed, seen.size()};
    }

    static class Seeds {
        int largest = Integer.MIN_VALUE;
        List<int[]> seeds = new ArrayList<>();

        void accept(int[] s) {
            int size = s[1];
            if (size >= largest) {
                if (size > largest) {
                    largest = size;
                    seeds.clear();
                }
                seeds.add(s);
            }
        }

        void combine(Seeds acc) {
            acc.seeds.forEach(this::accept);
        }
    }
}",GPT,"Different Logic, Same Syntax"
ydj6g_12,ydj6g,java,Summarize and say sequence,"import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.IntStream;

public class SRS {

    static Map<String, Integer> cacheMap = new ConcurrentHashMap<>(10_000);

    public static void main(String[] args) {
        DataContainer res = IntStream.range(0, 1000_000)
                .parallel()
                .mapToObj(num -> computeSequence(num, false))
                .collect(DataContainer::new, DataContainer::add, DataContainer::merge);

        System.out.println(""Data:"");
        res.dataList.forEach(e -> System.out.println(Arrays.toString(e)));

        System.out.println(""\nComputation:"");
        computeSequence(res.dataList.get(0)[0], true);
    }

    static int[] computeSequence(int number, boolean display) {
        String numStr = String.valueOf(number);

        String key = Arrays.toString(numStr.chars().sorted().toArray());
        if (!display && cacheMap.get(key) != null)
            return new int[]{number, cacheMap.get(key)};

        Set<String> tracked = new HashSet<>();
        StringBuilder builder = new StringBuilder();

        int[] countArray = new int[10];

        while (!tracked.contains(numStr)) {
            tracked.add(numStr);

            int length = numStr.length();
            for (int i = 0; i < length; i++)
                countArray[numStr.charAt(i) - '0']++;

            builder.setLength(0);
            for (int i = 9; i >= 0; i--) {
                if (countArray[i] != 0) {
                    builder.append(countArray[i]).append(i);
                    countArray[i] = 0;
                }
            }
            if (display)
                System.out.println(numStr);
            numStr = builder.toString();
        }

        cacheMap.put(key, tracked.size());

        return new int[]{number, tracked.size()};
    }

    static class DataContainer {
        int maxSize = Integer.MIN_VALUE;
        List<int[]> dataList = new ArrayList<>();

        void add(int[] data) {
            int size = data[1];
            if (size >= maxSize) {
                if (size > maxSize) {
                    maxSize = size;
                    dataList.clear();
                }
                dataList.add(data);
            }
        }

        void merge(DataContainer acc) {
            acc.dataList.forEach(this::add);
        }
    }
}",GPT,Different Variable Names + Abstract Names
ydj6g_13,ydj6g,java,Summarize and say sequence,"import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.IntStream;
import org.apache.commons.lang3.ArrayUtils; // Using Apache Commons Lang for array utilities

/**
 * Class representing the Self-Referential Sequence (SRS) algorithm.
 */
public class SelfReferentialSequence {

    static Map<String, Integer> cache = new ConcurrentHashMap<>(10_000);

    /**
     * Main method to run the SRS algorithm and display results.
     *
     * @param args Command-line arguments.
     */
    public static void main(String[] args) {
        Seeds res = IntStream.range(0, 1000_000)
                .parallel()
                .mapToObj(n -> summarize(n, false))
                .collect(Seeds::new, Seeds::accept, Seeds::combine);

        System.out.println(""Seeds:"");
        res.seeds.forEach(e -> System.out.println(ArrayUtils.toString(e)));

        System.out.println(""\nSequence:"");
        summarize(res.seeds.get(0)[0], true);
    }

    /**
     * Summarizes a sequence based on the given seed.
     *
     * @param seed    The initial number to start the sequence.
     * @param display Flag to control whether to display the sequence.
     * @return An array with the seed and the sequence size.
     */
    static int[] summarize(int seed, boolean display) {
        String n = String.valueOf(seed);

        String k = ArrayUtils.toString(n.chars().sorted().toArray());
        if (!display && cache.get(k) != null)
            return new int[]{seed, cache.get(k)};

        Set<String> seen = new HashSet<>();
        StringBuilder sb = new StringBuilder();

        int[] freq = new int[10];

        while (!seen.contains(n)) {
            seen.add(n);

            int len = n.length();
            for (int i = 0; i < len; i++)
                freq[n.charAt(i) - '0']++;

            sb.setLength(0);
            for (int i = 9; i >= 0; i--) {
                if (freq[i] != 0) {
                    sb.append(freq[i]).append(i);
                    freq[i] = 0;
                }
            }
            if (display)
                System.out.println",GPT,With Documentation + With External Libraries
ydj6g_14,ydj6g,java,Summarize and say sequence,"import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.IntStream;

public class SelfReferentialSequence {

    static Map<String, Integer> cache = new ConcurrentHashMap<>(10_000);

    public static void main(String[] args) {
        Seeds res = IntStream.range(0, 1000_000)
                .parallel()
                .mapToObj(n -> summarize(n, false))
                .collect(Seeds::new, Seeds::accept, Seeds::combine);

        // Unnecessary loop to demonstrate non-optimized code
        for (int i = 0; i < 1000; i++) {
            System.out.println(""Processing seed "" + i);
        }

        System.out.println(""Seeds:"");
        res.seeds.forEach(e -> System.out.println(Arrays.toString(e)));

        System.out.println(""\nSequence:"");
        summarize(res.seeds.get(0)[0], true);
    }

    static int[] summarize(int seed, boolean display) {
        String n = String.valueOf(seed);

        String k = Arrays.toString(n.chars().sorted().toArray());
        if (!display && cache.get(k) != null)
            return new int[]{seed, cache.get(k)};

        Set<String> seen = new HashSet<>();
        StringBuilder sb = new StringBuilder();

        int[] freq = new int[10];

        while (!seen.contains(n)) {
            seen.add(n);

            int len = n.length();
            for (int i = 0; i < len; i++)
                freq[n.charAt(i) - '0']++;

            sb.setLength(0);
            for (int i = 9; i >= 0; i--) {
                if (freq[i] != 0) {
                    sb.append(freq[i]).append(i);
                    freq[i] = 0;
                }
            }

            // Adding unnecessary logic to further demonstrate non-optimized code
            for (int i = 0; i < 10; i++) {
                int temp = freq[i];
                freq[i] = temp;
            }

            if (display)
                System.out.println(n);
            n = sb.toString();
        }

        cache.put(k, seen.size());

        return new int[]{seed, seen.size()};
    }

    static class Seeds {
        int largest = Integer.MIN_VALUE;
        List<int[]> seeds = new ArrayList<>();

        void accept(int[] s) {
            int size = s[1];
            if (size >= largest) {
                if (size > largest) {
                    largest = size;
                    seeds.clear();
                }
                seeds.add(s);
            }
        }

        void combine(Seeds acc) {
            acc.seeds.forEach(this::accept);
        }
    }
}",GPT,Without Documentation + Non-Optimized Code
ydj6g_15,ydj6g,java,Summarize and say sequence,"import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.IntStream;

public class SelfReferentialSequence {

    static Map<String, Long> cache = new ConcurrentHashMap<>(10_000); // Changed Integer to Long

    public static void main(String[] args) {
        try {
            Seeds res = IntStream.range(0, 1000_000)
                    .parallel()
                    .mapToObj(n -> summarize((long) n, false)) // Type cast to long
                    .collect(Seeds::new, Seeds::accept, Seeds::combine);

            System.out.println(""Seeds:"");
            res.seeds.forEach(e -> System.out.println(Arrays.toString(e)));

            System.out.println(""\nSequence:"");
            summarize(res.seeds.get(0)[0], true);
        } catch (Exception e) {
            System.err.println(""An error occurred: "" + e.getMessage());
        }
    }

    static long[] summarize(long seed, boolean display) {
        if (seed < 0) {
            throw new IllegalArgumentException(""Seed must be non-negative""); // Error handling for negative seeds
        }

        String n = String.valueOf(seed);

        String k = Arrays.toString(n.chars().sorted().toArray());
        if (!display && cache.get(k) != null)
            return new long[]{seed, cache.get(k)};

        Set<String> seen = new HashSet<>();
        StringBuilder sb = new StringBuilder();

        long[] freq = new long[10]; // Changed int to long

        while (!seen.contains(n)) {
            seen.add(n);

            int len = n.length();
            for (int i = 0; i < len; i++)
                freq[n.charAt(i) - '0']++;

            sb.setLength(0);
            for (int i = 9; i >= 0; i--) {
                if (freq[i] != 0) {
                    sb.append(freq[i]).append(i);
                    freq[i] = 0;
                }
            }
            if (display)
                System.out.println(n);
            n = sb.toString();
        }

        cache.put(k, (long) seen.size());

        return new long[]{seed, (long) seen.size()};
    }

    static class Seeds {
        long largest = Long.MIN_VALUE; // Changed int to long
        List<long[]> seeds = new ArrayList<>();

        void accept(long[] s) {
            long size = s[1];
            if (size >= largest) {
                if (size > largest) {
                    largest = size;
                    seeds.clear();
                }
                seeds.add(s);
            }
        }

        void combine(Seeds acc) {
            acc.seeds.forEach(this::accept);
        }
    }
}",GPT,With Error Handling + Different Data Types
ydj6g_16,ydj6g,java,Summarize and say sequence,"import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.IntStream;

public class SelfReferentialSequence {

    static Map<String, Integer> cache = new ConcurrentHashMap<>(10_000);

    public static void main(String[] args) {
        Seeds res = IntStream.range(0, 1000_000)
                .parallel()
                .mapToObj(n -> summarize(n, false))
                .collect(Seeds::new, Seeds::accept, Seeds::combine);

        System.out.println(""Seeds:"");
        res.seeds.forEach(e -> System.out.println(Arrays.toString(e)));

        System.out.println(""\nSequence:"");
        summarize(res.seeds.get(0)[0], true);
    }

    static int[] summarize(int seed, boolean display) {
        String n = String.valueOf(seed);

        String k = Arrays.toString(n.chars().sorted().toArray());
        if (!display && cache.get(k) != null)
            return new int[]{seed, cache.get(k)};

        Set<String> seen = new TreeSet<>(); // Changed logic by using TreeSet instead of HashSet
        StringBuilder sb = new StringBuilder();

        int[] freq = new int[10];

        while (!seen.contains(n)) {
            seen.add(n);

            int len = n.length();
            for (int i = 0; i < len; i++)
                freq[n.charAt(i) - '0']++;

            sb.setLength(0);
            for (int i = 9; i >= 0; i--) {
                if (freq[i] != 0) {
                    sb.append(freq[i]).append(i);
                    freq[i] = 0;
                }
            }
            if (display)
                System.out.println(n);
            n = sb.toString();
        }

        cache.put(k, seen.size());

        return new int[]{seed, seen.size()};
    }

    static class Seeds {
        int largest = Integer.MIN_VALUE;
        List<int[]> seeds = new ArrayList<>();

        void accept(int[] s) {
            int size = s[1];
            if (size >= largest) {
                if (size > largest) {
                    largest = size;
                    seeds.clear();
                }
                seeds.add(s);
            }
        }

        void combine(Seeds acc) {
            acc.seeds.forEach(this::accept);
        }
    }
}",GPT,Different Logic Same Syntax + Optimized Code
ydj6g_17,ydj6g,java,Summarize and say sequence,"import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.IntStream;

public class SelfReferentialSequence {

 static Map<String, Integer> cache = new ConcurrentHashMap<>(10_000);

 public static void main(String[] args) {
  SelfReferentialSequence sequence = new SelfReferentialSequence();
  Seeds res = sequence.generateSeeds();

  System.out.println(""Seeds:"");
  res.seeds.forEach(e -> System.out.println(Arrays.toString(e)));

  System.out.println(""\nSequence:"");
  sequence.summarize(res.seeds.get(0)[0], true);
 }

 public Seeds generateSeeds() {
  return IntStream.range(0, 1000_000)
   .parallel()
   .mapToObj(n -> summarize(n, false))
   .collect(Seeds::new, Seeds::accept, Seeds::combine);
 }

 public int[] summarize(int seed, boolean display) {
  String n = String.valueOf(seed);

  String k = Arrays.toString(n.chars().sorted().toArray());
  if (!display && cache.get(k) != null)
   return new int[]{seed, cache.get(k)};

  Set<String> seen = new HashSet<>();
  StringBuilder sb = new StringBuilder();

  int[] freq = new int[10];

  while (!seen.contains(n)) {
   seen.add(n);

   int len = n.length();
   for (int i = 0; i < len; i++)
    freq[n.charAt(i) - '0']++;

   sb.setLength(0);
   for (int i = 9; i >= 0; i--) {
    if (freq[i] != 0) {
     sb.append(freq[i]).append(i);
    ",GPT,Function + Different Indentations
ydj6g_18,ydj6g,java,Summarize and say sequence,"import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.IntStream;
import org.apache.commons.lang3.ArrayUtils; // Using Apache Commons Lang for array utilities

public class SelfReferentialSequence {

    static Map<String, Integer> cache = new ConcurrentHashMap<>(10_000);

    public static void main(String[] args) {
        Map<String, Integer> localCache = cache;

        List<int[]> seeds = IntStream.range(0, 1000_000)
            .parallel()
            .mapToObj(n -> {
                String nStr = String.valueOf(n);
                String key = ArrayUtils.toString(nStr.chars().sorted().toArray());

                if (localCache.containsKey(key)) {
                    return new int[]{n, localCache.get(key)};
                }

                Set<String> seen = new HashSet<>();
                StringBuilder sb = new StringBuilder();
                int[] freq = new int[10];
                String current = nStr;

                while (!seen.contains(current)) {
                    seen.add(current);
                    int len = current.length();

                    for (int i = 0; i < len; i++) {
                        freq[current.charAt(i) - '0']++;
                    }

                    sb.setLength(0);
                    for (int i = 9; i >= 0; i--) {
                        if (freq[i] != 0) {
                            sb.append(freq[i]).append(i);
                            freq[i] = 0;
                        }
                    }
                    current = sb.toString();
                }

                int size = seen.size();
                localCache.put(key, size);
                return new int[]{n, size};
            })
            .collect(ArrayList::new, List::add, List::addAll);

        System.out.println(""Seeds:"");
        seeds.forEach(e -> System.out.println(Arrays.toString(e)));

        String firstSeed = String.valueOf(seeds.get(0)[0]);
        String key = ArrayUtils.toString(firstSeed.chars().sorted().toArray());
        Set<String> seen = new HashSet<>();
        StringBuilder sb = new StringBuilder();
        int[] freq = new int[10];
        String current = firstSeed;

        while (!seen.contains(current)) {
            seen.add(current);
            int len = current.length();

            for (int i = 0; i < len; i++) {
                freq[current.charAt(i) - '0']++;
            }

            sb.setLength(0);
            for (int i = 9; i >= 0; i--) {
                if (freq[i] != 0) {
                    sb.append(freq[i]).append(i);
                    freq[i] = 0;
                }
            }
            System.out.println(current);
            current = sb.toString();
        }
    }
}",GPT,No Function + With External Libraries
6n13w_1,6n13w,python,Sutherland-Hodgman polygon clipping,"def clip(subjectPolygon, clipPolygon):
   def inside(p):
      return(cp2[0]-cp1[0])*(p[1]-cp1[1]) > (cp2[1]-cp1[1])*(p[0]-cp1[0])

   def computeIntersection():
      dc = [ cp1[0] - cp2[0], cp1[1] - cp2[1] ]
      dp = [ s[0] - e[0], s[1] - e[1] ]
      n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0]
      n2 = s[0] * e[1] - s[1] * e[0] 
      n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0])
      return [(n1*dp[0] - n2*dc[0]) * n3, (n1*dp[1] - n2*dc[1]) * n3]

   outputList = subjectPolygon
   cp1 = clipPolygon[-1]

   for clipVertex in clipPolygon:
      cp2 = clipVertex
      inputList = outputList
      outputList = []
      s = inputList[-1]

      for subjectVertex in inputList:
         e = subjectVertex
         if inside(e):
            if not inside(s):
               outputList.append(computeIntersection())
            outputList.append(e)
         elif inside(s):
            outputList.append(computeIntersection())
         s = e
      cp1 = cp2
   return(outputList)",rosetta,Same code
6n13w_2,6n13w,python,Sutherland-Hodgman polygon clipping,"def clip(subject_poly, clip_poly):
    def inside(point):
        return (clip2[0] - clip1[0]) * (point[1] - clip1[1]) > (clip2[1] - clip1[1]) * (point[0] - clip1[0])

    def compute_intersection():
        delta_c = [clip1[0] - clip2[0], clip1[1] - clip2[1]]
        delta_p = [start[0] - end[0], start[1] - end[1]]
        n1 = clip1[0] * clip2[1] - clip1[1] * clip2[0]
        n2 = start[0] * end[1] - start[1] * end[0]
        n3 = 1.0 / (delta_c[0] * delta_p[1] - delta_c[1] * delta_p[0])
        return [(n1 * delta_p[0] - n2 * delta_c[0]) * n3, (n1 * delta_p[1] - n2 * delta_c[1]) * n3]

    output_list = subject_poly
    clip1 = clip_poly[-1]

    for clip_vertex in clip_poly:
        clip2 = clip_vertex
        input_list = output_list
        output_list = []
        start = input_list[-1]

        for subject_vertex in input_list:
            end = subject_vertex
            if inside(end):
                if not inside(start):
                    output_list.append(compute_intersection())
                output_list.append(end)
            elif inside(start):
                output_list.append(compute_intersection())
            start = end
        clip1 = clip2
    return output_list",GPT,Different Variable Names
6n13w_3,6n13w,python,Sutherland-Hodgman polygon clipping,"def clip(subjectPolygon, clipPolygon):
    """"""
    Clips a subject polygon by a clip polygon using the Sutherland-Hodgman algorithm.

    Args:
        subjectPolygon (list): List of points (tuples) representing the subject polygon.
        clipPolygon (list): List of points (tuples) representing the clip polygon.

    Returns:
        list: The resulting clipped polygon as a list of points (tuples).
    """"""

    def inside(p):
        """"""Check if point p is inside the clipping edge.""""""
        return (cp2[0] - cp1[0]) * (p[1] - cp1[1]) > (cp2[1] - cp1[1]) * (p[0] - cp1[0])

    def computeIntersection():
        """"""Compute the intersection point of two edges.""""""
        dc = [cp1[0] - cp2[0], cp1[1] - cp2[1]]
        dp = [s[0] - e[0], s[1] - e[1]]
        n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0]
        n2 = s[0] * e[1] - s[1] * e[0]
        n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0])
        return [(n1 * dp[0] - n2 * dc[0]) * n3, (n1 * dp[1] - n2 * dc[1]) * n3]

    outputList = subjectPolygon
    cp1 = clipPolygon[-1]

    for clipVertex in clipPolygon:
        cp2 = clipVertex
        inputList = outputList
        outputList = []
        s = inputList[-1]

        for subjectVertex in inputList:
            e = subjectVertex
            if inside(e):
                if not inside(s):
                    outputList.append(computeIntersection())
                outputList.append(e)
            elif inside(s):
                outputList.append(computeIntersection())
            s = e
        cp1 = cp2
    return outputList",GPT,With Documentation
6n13w_4,6n13w,python,Sutherland-Hodgman polygon clipping,"import numpy as np

def clip(subjectPolygon, clipPolygon):
    def inside(p):
        return np.cross(np.subtract(cp2, cp1), np.subtract(p, cp1)) > 0

    def computeIntersection():
        dc = np.subtract(cp1, cp2)
        dp = np.subtract(s, e)
        n1 = np.cross(cp1, cp2)
        n2 = np.cross(s, e)
        n3 = 1.0 / np.cross(dc, dp)
        return np.add(n1 * dp, n2 * dc) * n3

    outputList = subjectPolygon
    cp1 = clipPolygon[-1]

    for clipVertex in clipPolygon:
        cp2 = clipVertex
        inputList = outputList
        outputList = []
        s = inputList[-1]

        for subjectVertex in inputList:
            e = subjectVertex
            if inside(e):
                if not inside(s):
                    outputList.append(computeIntersection())
                outputList.append(e)
            elif inside(s):
                outputList.append(computeIntersection())
            s = e
        cp1 = cp2
    return outputList",GPT,With External Libraries
6n13w_5,6n13w,python,Sutherland-Hodgman polygon clipping,"def clip(subjectPolygon, clipPolygon):
    if not subjectPolygon or not clipPolygon:
        raise ValueError(""Both subjectPolygon and clipPolygon must be non-empty lists."")

    def inside(p):
        return (cp2[0] - cp1[0]) * (p[1] - cp1[1]) > (cp2[1] - cp1[1]) * (p[0] - cp1[0])

    def computeIntersection():
        try:
            dc = [cp1[0] - cp2[0], cp1[1] - cp2[1]]
            dp = [s[0] - e[0], s[1] - e[1]]
            n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0]
            n2 = s[0] * e[1] - s[1] * e[0]
            n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0])
            return [(n1 * dp[0] - n2 * dc[0]) * n3, (n1 * dp[1] - n2 * dc[1]) * n3]
        except ZeroDivisionError:
            raise ValueError(""Lines are parallel, intersection cannot be computed."")

    outputList = subjectPolygon
    cp1 = clipPolygon[-1]

    for clipVertex in clipPolygon:
        cp2 = clipVertex
        inputList = outputList
        outputList = []
        s = inputList[-1]

        for subjectVertex in inputList:
            e = subjectVertex
            if inside(e):
                if not inside(s):
                    outputList.append(computeIntersection())
                outputList.append(e)
            elif inside(s):
                outputList.append(computeIntersection())
            s = e
        cp1 = cp2
    return outputList",GPT,With Error Handling
6n13w_6,6n13w,python,Sutherland-Hodgman polygon clipping,"def clip(subjectPolygon, clipPolygon):
    def inside(p):
        return (cp2[0] - cp1[0]) * (p[1] - cp1[1]) > (cp2[1] - cp1[1]) * (p[0] - cp1[0])

    def computeIntersection():
        dc = [cp1[0] - cp2[0], cp1[1] - cp2[1]]
        dp = [s[0] - e[0], s[1] - e[1]]
        n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0]
        n2 = s[0] * e[1] - s[1] * e[0]
        n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0])
        # Non-optimized: unnecessary calculations repeated for no reason
        for _ in range(1000):
            temp = (n1 * dp[0] - n2 * dc[0]) * n3
        return [(n1 * dp[0] - n2 * dc[0]) * n3, (n1 * dp[1] - n2 * dc[1]) * n3]

    outputList = subjectPolygon
    cp1 = clipPolygon[-1]

    for clipVertex in clipPolygon:
        cp2 = clipVertex
        inputList = outputList
        outputList = []
        s = inputList[-1]

        for subjectVertex in inputList:
            e = subjectVertex
            if inside(e):
                if not inside(s):
                    outputList.append(computeIntersection())
                outputList.append(e)
            elif inside(s):
                outputList.append(computeIntersection())
            s = e
        cp1 = cp2
    return outputList",GPT,Non-Optimized Code
6n13w_7,6n13w,python,Sutherland-Hodgman polygon clipping,"def clip(a, b):
    def inside(c):
        return (e[0] - d[0]) * (c[1] - d[1]) > (e[1] - d[1]) * (c[0] - d[0])

    def computeIntersection():
        f = [d[0] - e[0],",GPT,Abstract Names
6n13w_8,6n13w,python,Sutherland-Hodgman polygon clipping,"def clip(subjectPolygon, clipPolygon):
 def inside(p):
  return (cp2[0] - cp1[0]) * (p[1] - cp1[1]) > (cp2[1] - cp1[1]) * (p[0] - cp1[0])

 def computeIntersection():
  dc = [cp1[0] - cp2[0], cp1[1] - cp2[1]]
  dp = [s[0] - e[0], s[1] - e[1]]
  n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0]
  n2 = s[0] * e[1] - s[1] * e[0]
  n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0])
  return [(n1 * dp[0] - n2 * dc[0]) * n3, (n1 * dp[1] - n2 * dc[1]) * n3]

 outputList = subjectPolygon
 cp1 = clipPolygon[-1]

 for clipVertex in clipPolygon:
  cp2 = clipVertex
  inputList = outputList
  outputList = []
  s = inputList[-1]

  for subjectVertex in inputList:
   e = subjectVertex
   if inside(e):
    if not inside(s):
     outputList.append(computeIntersection())
    outputList.append(e)
   elif inside(s):
    outputList.append(computeIntersection())
   s = e
  cp1 = cp2
 return outputList",GPT,Different Indentations
6n13w_9,6n13w,python,Sutherland-Hodgman polygon clipping,"def inside(p, cp1, cp2):
    return (cp2[0] - cp1[0]) * (p[1] - cp1[1]) > (cp2[1] - cp1[1]) * (p[0] - cp1[0])

def computeIntersection(cp1, cp2, s, e):
    dc = [cp1[0] - cp2[0], cp1[1] - cp2[1]]
    dp = [s[0] - e[0], s[1] - e[1]]
    n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0]
    n2 = s[0] * e[1] - s[1] * e[0]
    n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0])
    return [(n1 * dp[0] - n2 * dc[0]) * n3, (n1 * dp[1] - n2 * dc[1]) * n3]

def clip(subjectPolygon, clipPolygon):
    outputList = subjectPolygon
    cp1 = clipPolygon[-1]

    for clipVertex in clipPolygon:
        cp2 = clipVertex
        inputList = outputList
        outputList = []
        s = inputList[-1]

        for subjectVertex in inputList:
            e = subjectVertex
            if inside(e, cp1, cp2):
                if not inside(s, cp1, cp2):
                    outputList.append(computeIntersection(cp1, cp2, s, e))
                outputList.append(e)
            elif inside(s, cp1, cp2):
                outputList.append(computeIntersection(cp1, cp2, s, e))
            s = e
        cp1 = cp2
    return outputList",GPT,Function
6n13w_10,6n13w,python,Sutherland-Hodgman polygon clipping,"def clip(subjectPolygon, clipPolygon):
    def inside(p):
        return (cp2[0] - cp1[0]) * (p[1] - cp1[1]) > (cp2[1] - cp1[1]) * (p[0] - cp1[0])

    def computeIntersection():
        dc = [float(cp1[0]) - float(cp2[0]), float(cp1[1]) - float(cp2[1])]
        dp = [float(s[0]) - float(e[0]), float(s[1]) - float(e[1])]
        n1 = float(cp1[0]) * float(cp2[1]) - float(cp1[1]) * float(cp2[0])
        n2 = float(s[0]) * float(e[1]) - float(s[1]) * float(e[0])
        n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0])
        return [(n1 * dp[0] - n2 * dc[0]) * n3, (n1 * dp[1] - n2 * dc[1]) * n3]

    outputList = subjectPolygon
    cp1 = clipPolygon[-1]

    for clipVertex in clipPolygon:
        cp2 = clipVertex
        inputList = outputList
        outputList = []
        s = inputList[-1]

        for subjectVertex in inputList:
            e = subjectVertex
            if inside(e):
                if not inside(s):
                    outputList.append(computeIntersection())
                outputList.append(e)
            elif inside(s):
                outputList.append(computeIntersection())
            s = e
        cp1 = cp2
    return outputList",GPT,Different Data Types
6n13w_11,6n13w,python,Sutherland-Hodgman polygon clipping,"def clip(subjectPolygon, clipPolygon):
    def inside(p):
        return (cp2[0] - cp1[0]) * (p[1] - cp1[1]) < (cp2[1] - cp1[1]) * (p[0] - cp1[0])

    def computeIntersection():
        dc = [cp1[0] - cp2[0], cp1[1] - cp2[1]]
        dp = [s[0] - e[0], s[1] - e[1]]
        n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0]
        n2 = s[0] * e[1] - s[1] * e[0]
        n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0])
        return [(n1 * dp[0] + n2 * dc[0]) * n3, (n1 * dp[1] + n2 * dc[1]) * n3]

    outputList = subjectPolygon
    cp1 = clipPolygon[-1]

    for clipVertex in clipPolygon:
        cp2 = clipVertex
        inputList = outputList
        outputList = []
        s = inputList[-1]

        for subjectVertex in inputList:
            e = subjectVertex
            if inside(e):
                if not inside(s):
                    outputList.append(computeIntersection())
                outputList.append(e)
            elif inside(s):
                outputList.append(computeIntersection())
            s = e
        cp1 = cp2
    return outputList",GPT,"Different Logic, Same Syntax"
6n13w_12,6n13w,python,Sutherland-Hodgman polygon clipping,"def clip(sp, cp):
    def in_area(p):
        return (e2[0] - e1[0]) * (p[1] - e1[1]) > (e2[1] - e1[1]) * (p[0] - e1[0])

    def calc_intersect():
        delta_c = [e1[0] - e2[0], e1[1] - e2[1]]
        delta_p = [start[0] - end[0], start[1] - end[1]]
        n1 = e1[0] * e2[1] - e1[1] * e2[0]
        n2 = start[0] * end[1] - start[1] * end[0]
        n3 = 1.0 / (delta_c[0] * delta_p[1] - delta_c[1] * delta_p[0])
        return [(n1 * delta_p[0] - n2 * delta_c[0]) * n3, (n1 * delta_p[1] - n2 * delta_c[1]) * n3]

    output = sp
    e1 = cp[-1]

    for vertex in cp:
        e2 = vertex
        input_list = output
        output = []
        start = input_list[-1]

        for point in input_list:
            end = point
            if in_area(end):
                if not in_area(start):
                    output.append(calc_intersect())
                output.append(end)
            elif in_area(start):
                output.append(calc_intersect())
            start = end
        e1 = e2
    return output",GPT,Different Variable Names + Abstract Names
6n13w_13,6n13w,python,Sutherland-Hodgman polygon clipping,"import numpy as np

def clip(subjectPolygon, clipPolygon):
    """"""
    Clips a subject polygon by a clip polygon using the Sutherland-Hodgman algorithm.

    Args:
        subjectPolygon (list): List of numpy arrays representing the subject polygon.
        clipPolygon (list): List of numpy arrays representing the clip polygon.

    Returns:
        list: The resulting clipped polygon as a list of numpy arrays.
    """"""

    def inside(p):
        """"""Check if point p is inside the clipping edge.""""""
        return np.cross(np.subtract(cp2, cp1), np.subtract(p, cp1)) > 0

    def computeIntersection():
        """"""Compute the intersection point of two edges.""""""
        dc = np.subtract(cp1, cp2)
        dp = np.subtract(s, e)
        n1 = np.cross(cp1, cp2)
        n2 = np.cross(s, e)
        n3 = 1.0 / np.cross(dc, dp)
        return np.add(n1 * dp, n2 * dc) * n3

    outputList = subjectPolygon
    cp1 = clipPolygon[-1]

    for clipVertex in clipPolygon:
        cp2 = clipVertex
        inputList = outputList
        outputList = []
        s = inputList[-1]

        for subjectVertex in inputList:
            e = subjectVertex
            if inside(e):
                if not inside(s):
                    outputList.append(computeIntersection())
                outputList.append(e)
            elif inside(s):
                outputList.append(computeIntersection())
            s = e
        cp1 = cp2
    return outputList.tolist()",GPT,With Documentation + With External Libraries
6n13w_14,6n13w,python,Sutherland-Hodgman polygon clipping,"def clip(subjectPolygon, clipPolygon):
    def inside(p):
        return (cp2[0] - cp1[0]) * (p[1] - cp1[1]) > (cp2[1] - cp1[1]) * (p[0] - cp1[0])

    def computeIntersection():
        dc = [cp1[0] - cp2[0], cp1[1] - cp2[1]]
        dp = [s[0] - e[0], s[1] - e[1]]
        n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0]
        n2 = s[0] * e[1] - s[1] * e[0]
        n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0])
        for _ in range(100):  # Non-optimized: unnecessary loop
            pass
        return [(n1 * dp[0] - n2 * dc[0]) * n3, (n1 * dp[1] - n2 * dc[1]) * n3]

    outputList = subjectPolygon
    cp1 = clipPolygon[-1]

    for clipVertex in clipPolygon:
        cp2 = clipVertex
        inputList = outputList
        outputList = []
        s = inputList[-1]

        for subjectVertex in inputList:
            e = subjectVertex
            if inside(e):
                if not inside(s):
                    outputList.append(computeIntersection())
                outputList.append(e)
            elif inside(s):
                outputList.append(computeIntersection())
            s = e
        cp1 = cp2
    return outputList",GPT,Without Documentation + Non-Optimized Code
6n13w_15,6n13w,python,Sutherland-Hodgman polygon clipping,"def clip(subjectPolygon, clipPolygon):
    if not isinstance(subjectPolygon, list) or not isinstance(clipPolygon, list):
        raise TypeError(""Both subjectPolygon and clipPolygon must be lists of points."")

    def inside(p):
        return (float(cp2[0]) - float(cp1[0])) * (p[1] - cp1[1]) > (float(cp2[1]) - float(cp1[1])) * (p[0] - cp1[0])

    def computeIntersection():
        try:
            dc = [float(cp1[0]) - float(cp2[0]), float(cp1[1]) - float(cp2[1])]
            dp = [float(s[0]) - float(e[0]), float(s[1]) - float(e[1])]
            n1 = float(cp1[0]) * float(cp2[1]) - float(cp1[1]) * float(cp2[0])
            n2 = float(s[0]) * float(e[1]) - float(s[1]) * float(e[0])
            n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0])
            return [(n1 * dp[0] - n2 * dc[0]) * n3, (n1 * dp[1] ",GPT,With Error Handling + Different Data Types
6n13w_16,6n13w,python,Sutherland-Hodgman polygon clipping,"def clip(subjectPolygon, clipPolygon):
    def inside(p):
        return (cp2[0] - cp1[0]) * (p[1] - cp1[1]) < (cp2[1] - cp1[1]) * (p[0] - cp1[0])

    def computeIntersection():
        dc = [cp1[0] - cp2[0], cp1[1] - cp2[1]]
        dp = [s[0] - e[0], s[1] - e[1]]
        n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0]
        n2 = s[0] * e[1] - s[1] * e[0]
        n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0])
        return [(n1 * dp[0] + n2 * dc[0]) * n3, (n1 * dp[1] + n2 * dc[1]) * n3]

    outputList = subjectPolygon
    cp1 = clipPolygon[-1]

    for clipVertex in clipPolygon:
        cp2 = clipVertex
        inputList = outputList
        outputList = []
        s = inputList[-1]

        for subjectVertex in inputList:
            e = subjectVertex
            if inside(e):
                if not inside(s):
                    outputList.append(computeIntersection())
                outputList.append(e)
            elif inside(s):
                outputList.append(computeIntersection())
            s = e
        cp1 = cp2
    return [tuple(point) for point in outputList]  # Optimized: Convert list to tuple for immutability",GPT,Different Logic Same Syntax + Optimized Code
6n13w_17,6n13w,python,Sutherland-Hodgman polygon clipping,"def inside(p, cp1, cp2):
    return (cp2[0] - cp1[0]) * (p[1] - cp1[1]) > (cp2[1] - cp1[1]) * (p[0] - cp1[0])

def computeIntersection(cp1, cp2, s, e):
 dc = [cp1[0] - cp2[0], cp1[1] - cp2[1]]
 dp = [s[0] - e[0], s[1] - e[1]]
 n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0]
 n2 = s[0] * e[1] - s[1] * e[0]
 n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0])
 return [(n1 * dp[0] - n2 * dc[0]) * n3, (n1 * dp[1] - n2 * dc[1]) * n3]

def clip(subjectPolygon, clipPolygon):
 outputList = subjectPolygon
 cp1 = clipPolygon[-1]

 for clipVertex in clipPolygon:
  cp2 = clipVertex
  inputList = outputList
  outputList = []
  s = inputList[-1]

  for subjectVertex in inputList:
   e = subjectVertex
   if inside(e, cp1, cp2):
    if not inside(s, cp1, cp2):
     outputList.append(computeIntersection(cp1, cp2, s, e))
    outputList.append(e)
   elif inside(s, cp1, cp2):
    outputList.append(computeIntersection(cp1, cp2, s, e))
   s = e
  cp1 = cp2
 return outputList",GPT,Function + Different Indentations
6n13w_18,6n13w,python,Sutherland-Hodgman polygon clipping,"import numpy as np

def clip(subjectPolygon, clipPolygon):
    def inside(p):
        return np.cross(np.subtract(cp2, cp1), np.subtract(p, cp1)) > 0

    def computeIntersection():
        dc = np.subtract(cp1, cp2)
        dp = np.subtract(s, e)
        n1 = np.cross(cp1, cp2)
        n2 = np.cross(s, e)
        n3 = 1.0 / np.cross(dc, dp)
        return np.add(n1 * dp, n2 * dc) * n3

    outputList = np.array(subjectPolygon)
    cp1 = np.array(clipPolygon[-1])

    for clipVertex in clipPolygon:
        cp2 = np.array(clipVertex)
        inputList = outputList
        outputList = []
        s = inputList[-1]

        for subjectVertex in inputList:
            e = subjectVertex
            if inside(e):
                if not inside(s):
                    outputList.append(computeIntersection())
                outputList.append(e)
            elif inside(s):
                outputList.append(computeIntersection())
            s = e
        cp1 = cp2
    return np.array(outputList)",GPT,No Function + With External Libraries
4c5k_19,4c5k,java,Sorting Algorithm (Bubble Sort),"public class BubbleSort {
    public static void main(String[] args) {
        int[] numbers = {64, 34, 25, 12, 22, 11, 90};
        int length = numbers.length;

        for (int i = 0; i < length; i++) {
            boolean swapped = false;
            for (int j = 0; j < length - i - 1; j++) {
                if (numbers[j] > numbers[j + 1]) {
                    // Swap numbers[j] and numbers[j + 1]
                    int temp = numbers[j];
                    numbers[j] = numbers[j + 1];
                    numbers[j + 1] = temp;
                    swapped = true;
                }
            }
            // If no elements were swapped, break the loop
            if (!swapped) {
                break;
            }
        }

        // Print the sorted array
        for (int num : numbers) {
            System.out.print(num + "" "");
        }
    }
}",GPT,Same goal in different programming language
5d6l_19,5d6l,java,Sorting Algorithm (Insertion Sort),"public class InsertionSort {
    public static void main(String[] args) {
        int[] numbers = {64, 34, 25, 12, 22, 11, 90};
        int length = numbers.length;

        for (int i = 1; i < length; i++) {
            int key = numbers[i];
            int j = i - 1;

            // Move elements of numbers[0..i-1] that are greater than key
            // to one position ahead of their current position
            while (j >= 0 && numbers[j] > key) {
                numbers[j + 1] = numbers[j];
                j -= 1;
            }
            numbers[j + 1] = key;
        }

        // Print the sorted array
        for (int num : numbers) {
            System.out.print(num + "" "");
        }
    }
}",GPT,Same goal in different programming language
8en0g_19,8en0g,javascript,Sum and product of an array,"var array = [1, 2, 3, 4, 5],
    sum = 0,
    prod = 1,
    i;
for (i = 0; i < array.length; i += 1) {
    sum += array[i];
    prod *= array[i];
}
alert(sum + ' ' + prod);",rosetta,Same goal in different programming language
17ipc_19,17ipc,java,Sum and product puzzle,"package org.rosettacode;

import java.util.ArrayList;
import java.util.List;



public class SumAndProductPuzzle {
    private final long beginning;
    private final int maxSum;
    private static final int MIN_VALUE = 2;
    private List<int[]> firstConditionExcludes = new ArrayList<>();
    private List<int[]> secondConditionExcludes = new ArrayList<>();

    public static void main(String... args){

        if (args.length == 0){
            new SumAndProductPuzzle(100).run();
            new SumAndProductPuzzle(1684).run();
            new SumAndProductPuzzle(1685).run();
        } else {
            for (String arg : args){
                try{
                    new SumAndProductPuzzle(Integer.valueOf(arg)).run();
                } catch (NumberFormatException e){
                    System.out.println(""Please provide only integer arguments. "" +
                            ""Provided argument "" + arg + "" was not an integer. "" +
                            ""Alternatively, calling the program with no arguments "" +
                            ""will run the puzzle where maximum sum equals 100, 1684, and 1865."");
                }
            }
        }
    }

    public SumAndProductPuzzle(int maxSum){
        this.beginning = System.currentTimeMillis();
        this.maxSum = maxSum;
        System.out.println(""Run with maximum sum of "" + String.valueOf(maxSum) + 
                "" started at "" + String.valueOf(beginning) + ""."");
    }

    public void run(){
        for (int x = MIN_VALUE; x < maxSum - MIN_VALUE; x++){
            for (int y = x + 1; y < maxSum - MIN_VALUE; y++){

                if (isSumNoGreaterThanMax(x,y) &&
                    isSKnowsPCannotKnow(x,y) &&
                    isPKnowsNow(x,y) &&
                    isSKnowsNow(x,y)
                    ){
                    System.out.println(""Found solution x is "" + String.valueOf(x) + "" y is "" + String.valueOf(y) + 
                            "" in "" + String.valueOf(System.currentTimeMillis() - beginning) + ""ms."");
                }
            }
        }
        System.out.println(""Run with maximum sum of "" + String.valueOf(maxSum) + 
                "" ended in "" + String.valueOf(System.currentTimeMillis() - beginning) + ""ms."");
    }

    public boolean isSumNoGreaterThanMax(int x, int y){
        return x + y <= maxSum;
    }

    public boolean isSKnowsPCannotKnow(int x, int y){

        if (firstConditionExcludes.contains(new int[] {x, y})){
            return false;
        }

        for (int[] addends : sumAddends(x, y)){
            if ( !(productFactors(addends[0], addends[1]).size() > 1) ) {
                firstConditionExcludes.add(new int[] {x, y});
                return false;
            }
        }
        return true;
    }

    public boolean isPKnowsNow(int x, int y){

        if (secondConditionExcludes.contains(new int[] {x, y})){
            return false;
        }

        int countSolutions = 0;
        for (int[] factors : productFactors(x, y)){
            if (isSKnowsPCannotKnow(factors[0], factors[1])){
                countSolutions++;
            }
        }

        if (countSolutions == 1){
            return true;
        } else {
            secondConditionExcludes.add(new int[] {x, y});
            return false;
        }
    }

    public boolean isSKnowsNow(int x, int y){

        int countSolutions = 0;
        for (int[] addends : sumAddends(x, y)){
            if (isPKnowsNow(addends[0], addends[1])){
                countSolutions++;
            }
        }
        return countSolutions == 1;
    }

    public List<int[]> sumAddends(int x, int y){

        List<int[]> list = new ArrayList<>();
        int sum = x + y;

        for (int addend = MIN_VALUE; addend < sum - addend; addend++){
            if (isSumNoGreaterThanMax(addend, sum - addend)){
                list.add(new int[]{addend, sum - addend});
            }
        }
        return list;
    }

    public List<int[]> productFactors(int x, int y){

        List<int[]> list = new ArrayList<>();
        int product = x * y;

        for (int factor = MIN_VALUE; factor < product / factor; factor++){
            if (product % factor == 0){
                if (isSumNoGreaterThanMax(factor, product / factor)){
                    list.add(new int[]{factor, product / factor});
                }
            }
        }
        return list;
    }
}",rosetta,Same goal in different programming language
8ev06_19,8ev06,javascript,Temperature conversion,"var k2c = k => k - 273.15
var k2r = k => k * 1.8
var k2f = k => k2r(k) - 459.67

Number.prototype.toMaxDecimal = function (d) {
    return +this.toFixed(d) + ''
}

function kCnv(k) {
    document.write( k,'K = ', k2c(k).toMaxDecimal(2),'C = ', k2r(k).toMaxDecimal(2),'R = ', k2f(k).toMaxDecimal(2),'F<br>' ) 
}

kCnv(21)
kCnv(295)",rosetta,Same goal in different programming language
ydj6g_19,ydj6g,go,Summarize and say sequence,"package main

import (
    ""fmt""
    ""strconv""
)

func main() {
    var maxLen int
    var seqMaxLen [][]string
    for n := 1; n < 1e6; n++ {
        switch s := seq(n); {
        case len(s) == maxLen:
            seqMaxLen = append(seqMaxLen, s)
        case len(s) > maxLen:
            maxLen = len(s)
            seqMaxLen = [][]string{s}
        }
    }
    fmt.Println(""Max sequence length:"", maxLen)
    fmt.Println(""Sequences:"", len(seqMaxLen))
    for _, seq := range seqMaxLen {
        fmt.Println(""Sequence:"")
        for _, t := range seq {
            fmt.Println(t)
        }
    }
}

func seq(n int) []string {
    s := strconv.Itoa(n)
    ss := []string{s}

    for {
        dSeq := sortD(s)
        d := dSeq[0]
        nd := 1
        s = """"
        for i := 1; ; i++ {
            if i == len(dSeq) {
                s = fmt.Sprintf(""%s%d%c"", s, nd, d)
                break
            }
            if dSeq[i] == d {
                nd++
            } else {
                s = fmt.Sprintf(""%s%d%c"", s, nd, d)
                d = dSeq[i]
                nd = 1
            }
        }
        for _, s0 := range ss {
            if s == s0 {
                return ss
            }
        }
        ss = append(ss, s)
    }
    panic(""unreachable"")
}

func sortD(s string) []rune {
    r := make([]rune, len(s))
    for i, d := range s {
        j := 0
        for ; j < i; j++ {
            if d > r[j] {
                copy(r[j+1:], r[j:i])
                break
            }
        }
        r[j] = d
    }
    return r
}",rosetta,Same goal in different programming language
6n13w_19,6n13w,go,Sutherland-Hodgman polygon clipping,"package main

import ""fmt""

type point struct {
    x, y float32
}

var subjectPolygon = []point{{50, 150}, {200, 50}, {350, 150}, {350, 300},
    {250, 300}, {200, 250}, {150, 350}, {100, 250}, {100, 200}}

var clipPolygon = []point{{100, 100}, {300, 100}, {300, 300}, {100, 300}}

func main() {
    var cp1, cp2, s, e point
    inside := func(p point) bool {
        return (cp2.x-cp1.x)*(p.y-cp1.y) > (cp2.y-cp1.y)*(p.x-cp1.x)
    }
    intersection := func() (p point) {
        dcx, dcy := cp1.x-cp2.x, cp1.y-cp2.y
        dpx, dpy := s.x-e.x, s.y-e.y
        n1 := cp1.x*cp2.y - cp1.y*cp2.x
        n2 := s.x*e.y - s.y*e.x
        n3 := 1 / (dcx*dpy - dcy*dpx)
        p.x = (n1*dpx - n2*dcx) * n3
        p.y = (n1*dpy - n2*dcy) * n3
        return
    }
    outputList := subjectPolygon
    cp1 = clipPolygon[len(clipPolygon)-1]
    for _, cp2 = range clipPolygon {",rosetta,Same goal in different programming language
